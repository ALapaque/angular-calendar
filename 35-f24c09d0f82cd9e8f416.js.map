{"version":3,"sources":["webpack:///35-f24c09d0f82cd9e8f416.js","webpack:///./node_modules/@angular/cdk/esm5/platform.es5.js","webpack:///./node_modules/@angular/cdk/esm5/scrolling.es5.js","webpack:///./node_modules/@angular/cdk/esm5/portal.es5.js","webpack:///./node_modules/@angular/cdk/esm5/coercion.es5.js","webpack:///./node_modules/@angular/cdk/esm5/overlay.es5.js","webpack:///./node_modules/@angular/cdk/esm5/a11y.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/module.ts","webpack:///./node_modules/@angular/cdk/esm5/bidi.es5.js","webpack:///./node_modules/@angular/cdk/esm5/keycodes.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.service.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js","webpack:///./demos/demo-modules/context-menu/component.ts","webpack:///./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js","webpack:///./demos/demo-modules/context-menu/module.ngfactory.js","webpack:///./node_modules/rxjs/operators/auditTime.js","webpack:///./node_modules/rxjs/operators/audit.js","webpack:///./node_modules/rxjs/observable/timer.js","webpack:///./node_modules/rxjs/observable/TimerObservable.js","webpack:///./node_modules/rxjs/util/isDate.js","webpack:///./node_modules/rxjs/operators/debounceTime.js"],"names":["webpackJsonp","668","module","__webpack_exports__","__webpack_require__","supportsPassiveEventListeners","supportsPassiveEvents","window","addEventListener","Object","defineProperty","get","SCROLL_DISPATCHER_PROVIDER_FACTORY","parentDispatcher","ngZone","platform","scrolling_es5_ScrollDispatcher","VIEWPORT_RULER_PROVIDER_FACTORY","parentRuler","scrolling_es5_ViewportRuler","throwNullPortalError","Error","throwPortalAlreadyAttachedError","throwPortalOutletAlreadyDisposedError","throwUnknownPortalTypeError","throwNullPortalOutletError","throwNoPortalAttachedError","coerceBooleanProperty","value","getMatScrollStrategyAlreadyAttachedError","isElementScrolledOutsideView","element","scrollContainers","some","containerBounds","outsideAbove","bottom","top","outsideBelow","outsideLeft","right","left","outsideRight","isElementClippedByScrolling","scrollContainerRect","clippedAbove","clippedBelow","clippedLeft","clippedRight","formatCssUnit","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY","dispatcher","_document","overlay_es5_OverlayKeyboardDispatcher","OVERLAY_CONTAINER_PROVIDER_FACTORY","parentContainer","overlay_es5_OverlayContainer","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","overlay","scrollStrategies","reposition","hasGeometry","offsetWidth","offsetHeight","getClientRects","length","isNativeFormElement","nodeName","toLowerCase","isHiddenInput","isInputElement","type","isAnchorWithHref","isAnchorElement","hasAttribute","hasValidTabIndex","undefined","tabIndex","getAttribute","isNaN","parseInt","getTabIndexValue","isPotentiallyTabbableIOS","inputType","isPotentiallyFocusable","getWindow","node","ownerDocument","defaultView","addAriaReferencedId","el","attr","id","ids","getAriaReferenceIds","existingId","trim","push","setAttribute","join","ID_DELIMINATOR","removeAriaReferencedId","filteredIds","filter","val","match","ARIA_DESCRIBER_PROVIDER_FACTORY","a11y_es5_AriaDescriber","LIVE_ANNOUNCER_PROVIDER_FACTORY","liveElement","a11y_es5_LiveAnnouncer","FOCUS_MONITOR_PROVIDER_FACTORY","a11y_es5_FocusMonitor","View_ContextMenuContentComponent_3","_l","core","View_ContextMenuContentComponent_2","_v","en","$event","ad","_co","component","onMenuItemSelect","parent","context","$implicit","onOpenSubMenu","common","ngTemplateOutletContext","ngTemplateOutlet","_ck","item","template","useBootstrap4","isActive","isMenuItemEnabled","subMenu","View_ContextMenuContentComponent_5","View_ContextMenuContentComponent_4","stopEvent","View_ContextMenuContentComponent_1","ngIf","divider","passive","View_ContextMenuContentComponent_0","menuElement","menuItemElements","ngForOf","menuItems","View_ContextMenuContentComponent_Host_0","onKeyEvent","keyboardOpenSubMenu","keyboardMenuItemSelect","onCloseLeafMenu","closeMenu","RenderType_ContextMenuContentComponent","contextMenuContent_component_ContextMenuContentComponent","CONTEXT_MENU_OPTIONS","View_ContextMenuComponent_0","View_ContextMenuComponent_Host_0","RenderType_ContextMenuComponent","contextMenu_component_ContextMenuComponent","contextMenu_service_ContextMenuService","View_DemoComponent_1","View_DemoComponent_3","day","badgeTotal","View_DemoComponent_4","onMouseOver","onMouseOut","highlightDay","emit","event","unhighlightDay","stopPropagation","eventClicked","klass","ngClass","calendar_tooltip_directive","contents","placement","cssClass","title","tooltipPlacement","color","primary","View_DemoComponent_2","onContextMenu","contextMenu_attach_directive_ContextMenuAttachDirective","contextMenuSubject","contextMenu","date","events","locale","View_DemoComponent_6","dayHeaderClicked","isPast","isToday","isFuture","isWeekend","dragOver","View_DemoComponent_5","days","View_DemoComponent_7","segment","isStart","View_DemoComponent_8","calendar_month_view_component_ngfactory","calendar_month_view_component","calendar_utils_provider","viewDate","refresh","cellTemplate","View_DemoComponent_9","calendar_week_view_component_ngfactory","calendar_week_view_component","headerTemplate","View_DemoComponent_10","calendar_day_view_component_ngfactory","calendar_day_view_component","hourSegmentTemplate","View_DemoComponent_0","calendar_date_pipe","calendar_date_formatter_provider","calendar_event_title_pipe","calendar_event_title_formatter_provider","view","calendar_header_component_ngfactory","calendar_header_component","viewChange","viewDateChange","addEvent","contextMenu_item_directive_ContextMenuItemDirective","execute","ngSwitch","ngSwitchCase","View_DemoComponent_Host_0","RenderType_DemoComponent","component_DemoComponent","DemoModule","calendar_tooltip_directive_ngfactory","hasV8BreakIterator","v8BreakIterator","platform_es5_Platform","Platform","this","isBrowser","document","EDGE","test","navigator","userAgent","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","MSStream","FIREFOX","ANDROID","SAFARI","decorators","ctorParameters","platform_es5_PlatformModule","PlatformModule","args","providers","Subject","Observable","of","fromEvent","auditTime","merge","ScrollDispatcher","_ngZone","_platform","_scrolled","_globalSubscription","_scrolledCount","Map","prototype","register","scrollable","_this","scrollSubscription","elementScrolled","subscribe","next","set","deregister","scrollableReference","unsubscribe","delete","scrolled","auditTimeInMs","create","observer","_addGlobalListener","subscription","pipe","ancestorScrolled","elementRef","ancestors","getAncestorScrollContainers","target","indexOf","scrollingContainers","forEach","_subscription","_scrollableContainsElement","nativeElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","SCROLL_DISPATCHER_PROVIDER","provide","deps","useFactory","scrolling_es5_CdkScrollable","CdkScrollable","_elementRef","_scroll","_elementScrolled","_scrollListener","ngOnInit","ngOnDestroy","removeEventListener","asObservable","selector","ViewportRuler","_change","_invalidateCache","change","_updateViewportSize","getViewportSize","_viewportSize","width","height","getViewportRect","scrollPosition","getViewportScrollPosition","_a","documentRect","documentElement","getBoundingClientRect","body","scrollTop","scrollY","scrollLeft","scrollX","throttleTime","innerWidth","innerHeight","VIEWPORT_RULER_PROVIDER","scrolling_es5_ScrollDispatchModule","ScrollDispatchModule","imports","exports","declarations","DIR_DOCUMENT","bidi_es5_Directionality","Directionality","bodyDir","dir","htmlDir","bidi_es5_Dir","Dir","_dir","_isInitialized","v","old","enumerable","configurable","ngAfterContentInit","complete","useExisting","host","[dir]","exportAs","propDecorators","bidi_es5_BidiModule","BidiModule","tslib_es6","Portal","attach","hasAttached","_attachedHost","detach","setAttachedHost","portal_es5_ComponentPortal","_super","ComponentPortal","viewContainerRef","injector","call","portal_es5_TemplatePortal","TemplatePortal","templateRef","BasePortalOutlet","_isDisposed","_attachedPortal","portal","attachComponentPortal","attachTemplatePortal","_invokeDisposeFn","dispose","setDisposeFn","fn","_disposeFn","portal_es5_DomPortalOutlet","DomPortalOutlet","_hostDomElement","_componentFactoryResolver","_appRef","_defaultInjector","componentRef","componentFactory","resolveComponentFactory","createComponent","parentInjector","destroy","attachView","hostView","detachView","appendChild","_getComponentRootNode","viewContainer","viewRef","createEmbeddedView","detectChanges","rootNodes","rootNode","index","remove","parentNode","removeChild","portal_es5_CdkPortal","CdkPortal","portal_es5_CdkPortalOutlet","CdkPortalOutlet","_viewContainerRef","ref","clear","inputs","_deprecatedPortal","_deprecatedPortalHost","portal_es5_PortalModule","PortalModule","take","PortalInjector","_parentInjector","_customTokens","token","notFoundValue","Subscription","NoopScrollStrategy","enable","disable","OverlayConfig","config","scrollStrategy","panelClass","hasBackdrop","backdropClass","direction","keys","key","ConnectionPositionPair","origin","offsetX","offsetY","originX","originY","overlayX","overlayY","ScrollingVisibility","overlay_es5_ConnectedOverlayPositionChange","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","CloseScrollStrategy","_scrollDispatcher","_viewportRuler","_config","_scrollSubscription","_detach","_overlayRef","run","overlayRef","stream","threshold","_initialScrollPosition","Math","abs","updatePosition","BlockScrollStrategy","_previousHTMLStyles","_isEnabled","_canBeEnabled","root","_previousScrollPosition","style","classList","add","html","previousHtmlScrollBehavior","previousBodyScrollBehavior","scroll","contains","viewport","scrollHeight","scrollWidth","RepositionScrollStrategy","throttle","scrollThrottle","autoClose","overlayRect","overlayElement","overlay_es5_ScrollStrategyOptions","ScrollStrategyOptions","noop","close","block","overlay_es5_OverlayRef","OverlayRef","_portalOutlet","_pane","_keyboardDispatcher","_backdropElement","_backdropClick","_attachments","_detachments","_keydownEvents","attachResult","positionStrategy","_updateStackingOrder","_updateElementSize","_updateElementDirection","onStable","_togglePointerEvents","_attachBackdrop","Array","isArray","cls","detachBackdrop","detachmentResult","isAttached","backdropClick","attachments","detachments","keydownEvents","getConfig","apply","updateSize","sizeConfig","setDirection","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","createElement","insertBefore","requestAnimationFrame","nextSibling","backdropToDetach","finishDetach_1","setTimeout","overlay_es5_ConnectedPositionStrategy","ConnectedPositionStrategy","originPos","overlayPos","_connectedTo","_offsetX","_offsetY","scrollables","_resizeSubscription","EMPTY","_preferredPositions","_applied","_positionLocked","_onPositionChange","_origin","withFallbackPosition","_lastConnectedPosition","recalculateLastPosition","fallbackPoint","fallbackPosition","originRect","viewportSize","_i","pos","originPoint","_getOriginConnectionPoint","overlayPoint","_getOverlayPoint","fitsInViewport","_setElementPosition","visibleArea","lastPosition","withScrollableContainers","position","withDirection","withOffsetX","offset","withOffsetY","withLockedPosition","isLocked","withPositions","positions","slice","_getStartX","rect","_isRtl","_getEndX","x","originStartX","originEndX","y","overlayStartX","overlayStartY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","_getScrollVisibility","originBounds","overlayBounds","scrollContainerBounds","map","s","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","horizontalStyleProperty","verticalStyleProperty","clientHeight","clientWidth","p","positionChange","overflows","arguments","reduce","currentValue","currentOverflow","max","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","_wrapper","centerHorizontally","centerVertically","styles","parentStyles","marginTop","marginLeft","marginBottom","marginRight","justifyContent","alignItems","overlay_es5_OverlayPositionBuilder","OverlayPositionBuilder","global","connectedTo","OverlayKeyboardDispatcher","_attachedOverlays","_unsubscribeFromKeydownEvents","_keydownEventSubscription","_subscribeToKeydownEvents","splice","bodyKeydownEvents","_selectOverlayFromEvent","find","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER","OverlayContainer","_containerElement","getContainerElement","_createContainer","container","OVERLAY_CONTAINER_PROVIDER","nextUniqueId","defaultConfig","overlay_es5_Overlay","Overlay","_overlayContainer","_positionBuilder","_injector","pane","_createPaneElement","portalOutlet","_createPortalOutlet","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","overlay_es5_CdkOverlayOrigin","CdkOverlayOrigin","overlay_es5_CdkConnectedOverlay","CdkConnectedOverlay","_overlay","_scrollStrategy","_hasBackdrop","_backdropSubscription","_positionSubscription","open","_templatePortal","_position","_positions","_minWidth","_minHeight","_backdropClass","_open","_destroyOverlay","ngOnChanges","changes","_attachOverlay","_detachOverlay","_createOverlay","_buildConfig","_createPositionStrategy","overlayConfig","strategy","_handlePositionChanges","i","onPositionChange","keyCode","_deprecatedOrigin","_deprecatedPositions","_deprecatedOffsetX","_deprecatedOffsetY","_deprecatedWidth","_deprecatedHeight","_deprecatedMinWidth","_deprecatedMinHeight","_deprecatedBackdropClass","_deprecatedScrollStrategy","_deprecatedOpen","_deprecatedHasBackdrop","OVERLAY_PROVIDERS","overlay_es5_OverlayModule","OverlayModule","FullscreenOverlayContainer","_adjustParentForFullscreenChange","_addFullscreenChangeListener","getFullscreenElement","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","debounceTime","tap","a11y_es5_InteractivityChecker","InteractivityChecker","isDisabled","isVisible","getComputedStyle","visibility","isTabbable","frameElement","frameType","tabIndexValue","isFocusable","a11y_es5_FocusTrap","FocusTrap","_element","_checker","deferAnchors","_enabled","attachAnchors","_startAnchor","_endAnchor","_createAnchor","focusLastTabbableElement","focusFirstTabbableElement","focusInitialElementWhenReady","Promise","resolve","_executeOnStable","focusInitialElement","focusFirstTabbableElementWhenReady","focusLastTabbableElementWhenReady","_getRegionBoundary","bound","markers","querySelectorAll","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","focus","children","childNodes","tabbableChild","nodeType","anchor","isStable","a11y_es5_FocusTrapFactory","FocusTrapFactory","deferCaptureElements","a11y_es5_FocusTrapDeprecatedDirective","FocusTrapDeprecatedDirective","_focusTrapFactory","focusTrap","enabled","disabled","a11y_es5_CdkTrapFocus","CdkTrapFocus","_previouslyFocusedElement","_autoCapture","autoCapture","a11y_es5_ListKeyManager","ListKeyManager","_items","_activeItemIndex","_wrap","_letterKeyStream","_typeaheadSubscription","_pressedLetters","tabOut","withWrap","withTypeAhead","debounceInterval","getLabel","inputString","items","toArray","toUpperCase","setActiveItem","previousIndex","_activeItem","onKeydown","setNextItemActive","setPreviousItemActive","toLocaleUpperCase","String","fromCharCode","preventDefault","setFirstItemActive","_setActiveItemByIndex","setLastItemActive","_setActiveItemByDelta","updateActiveItemIndex","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","a11y_es5_ActiveDescendantKeyManager","ActiveDescendantKeyManager","activeItem","setInactiveStyles","setActiveStyles","nextId","messageRegistry","messagesContainer","AriaDescriber","describe","hostElement","message","has","_createMessageElement","_isElementDescribedByMessage","_addMessageReference","removeDescription","_removeMessageReference","registeredMessage","referenceCount","_deleteMessageElement","_deleteMessagesContainer","describedElements","_removeCdkDescribedByReferenceIds","removeAttribute","messageElement","CDK_DESCRIBEDBY_ID_PREFIX","createTextNode","_createMessagesContainer","display","originalReferenceIds","referenceIds","messageId","ARIA_DESCRIBER_PROVIDER","LIVE_ANNOUNCER_ELEMENT_TOKEN","FocusKeyManager","LiveAnnouncer","elementToken","_liveElement","_createLiveElement","announce","politeness","textContent","liveEl","LIVE_ANNOUNCER_PROVIDER","FocusMonitor","_windowFocused","_elementInfo","WeakMap","_unregisterGlobalListeners","_monitoredElementCount","monitor","renderer","checkChildren","cachedInfo","subject","info","unlisten","_incrementMonitoredElementCount","focusListener","_onFocus","blurListener","_onBlur","stopMonitoring","elementInfo","_setClasses","_decrementMonitoredElementCount","focusVia","_setOriginForCurrentEventQueue","_registerGlobalListeners","documentKeydownListener","_lastTouchTarget","documentMousedownListener","documentTouchstartListener","_touchTimeout","clearTimeout","windowFocusListener","capture","_toggleClass","className","shouldSet","_wasCausedByTouch","focusTarget","Node","_lastFocusOrigin","relatedTarget","a11y_es5_CdkMonitorFocus","CdkMonitorFocus","_focusMonitor","cdkFocusChange","_monitorSubscription","FOCUS_MONITOR_PROVIDER","__assign","A11yModule","assign","t","n","hasOwnProperty","ContextMenuContentComponent","changeDetector","options","isLeaf","openSubMenu","closeLeafMenu","closeAllMenus","autoFocus","menuItem","currentItem","queryList","reset","_keyManager","ngAfterViewInit","evaluateIfFunction","isMenuItemVisible","visible","Function","link","cancelEvent","activeItemIndex","exceptRootMenu","button","anchorElementRef","anchorElement","parentContextMenu","triggerExecute","tagName","isContentEditable","styles_ContextMenuContentComponent","encapsulation","data","ContextMenuContentComponentNgFactory","datepicker_ngfactory","ContextMenuItemDirective","ContextMenuService","isDestroyingLeafMenu","show","triggerClose","overlays","fakeElement","openContextMenu","newOverlay","destroySubMenus","concat","attachContextMenu","clientY","clientX","closeAllContextMenus","contextMenuContent","instance","subscriptions","closeLeafMenuEvent","destroyLeafMenu","subMenuEvent","onDestroy","getLastAttachedOverlay","newLeaf","subMenuOverlay","isLeafMenu","contextMenu_component___assign","ContextMenuComponent","_contextMenuService","visibleMenuItems","links","menuEvent","onMenuEvent","setVisibleMenuItems","None","ContextMenuAttachDirective","contextMenuService","styles_ContextMenuComponent","colors","DemoComponent","Date","start","red","styles_DemoComponent","DemoComponentNgFactory","esm5_forms","ngb_calendar","datepicker_i18n","ngb_date_parser_formatter","ngb_date_adapter","datepicker_config","timepicker_config","angular_draggable_droppable","calendar_common_module","calendar_month_module","angular_resizable_element","calendar_week_module","calendar_day_module","calendar_module","ngx_contextmenu_ContextMenuModule","ContextMenuModule","forRoot","ngModule","useValue","entryComponents","datepicker_module","timepicker_module","demo_utils_module","router","d","DemoModuleNgFactory","path","714","duration","scheduler","async_1","async","audit_1","audit","timer_1","timer","715","durationSelector","source","lift","AuditOperator","__extends","b","__","constructor","tryCatch_1","errorObject_1","OuterSubscriber_1","subscribeToResult_1","subscriber","AuditSubscriber","destination","hasValue","_next","throttled","tryCatch","errorObject","error","e","innerSubscription","subscribeToResult","closed","clearThrottle","notifyNext","outerValue","innerValue","outerIndex","innerIndex","notifyComplete","OuterSubscriber","716","TimerObservable_1","TimerObservable","717","isNumeric_1","Observable_1","isScheduler_1","isDate_1","dueTime","period","isNumeric","Number","isScheduler","isDate","now","initialDelay","dispatch","state","action","schedule","_subscribe","718","719","DebounceTimeOperator","dispatchNext","debouncedNext","Subscriber_1","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","_complete","Subscriber"],"mappings":"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","file":"35-f24c09d0f82cd9e8f416.js","sourcesContent":["webpackJsonp([35],{\n\n/***/ 668:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ts\nvar DemoModule = /** @class */ (function () {\n    function DemoModule() {\n    }\n    return DemoModule;\n}());\n\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ngfactory.js\nvar calendar_tooltip_directive_ngfactory = __webpack_require__(294);\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/platform.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar platform_es5_Platform = /** @class */ (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser &&\n            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of <input> that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar platform_es5_PlatformModule = /** @class */ (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    providers: [platform_es5_Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=platform.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js\nvar Subject = __webpack_require__(29);\nvar Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Observable.js\nvar Observable = __webpack_require__(11);\nvar Observable_default = /*#__PURE__*/__webpack_require__.n(Observable);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/of.js\nvar of = __webpack_require__(301);\nvar of_default = /*#__PURE__*/__webpack_require__.n(of);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/fromEvent.js\nvar fromEvent = __webpack_require__(305);\nvar fromEvent_default = /*#__PURE__*/__webpack_require__.n(fromEvent);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/auditTime.js\nvar auditTime = __webpack_require__(714);\nvar auditTime_default = /*#__PURE__*/__webpack_require__.n(auditTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/filter.js\nvar filter = __webpack_require__(91);\nvar filter_default = /*#__PURE__*/__webpack_require__.n(filter);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/merge.js\nvar merge = __webpack_require__(132);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar scrolling_es5_ScrollDispatcher = /** @class */ (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject[\"Subject\"]();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable[\"Observable\"].create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(Object(auditTime[\"auditTime\"])(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (_this._globalSubscription && !_this._scrolledCount) {\n                    _this._globalSubscription.unsubscribe();\n                    _this._globalSubscription = null;\n                }\n            };\n        }) : Object(of[\"of\"])();\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(Object(filter[\"filter\"])(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return Object(fromEvent[\"fromEvent\"])(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    ScrollDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new scrolling_es5_ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ScrollDispatcher,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar scrolling_es5_CdkScrollable = /** @class */ (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._elementScrolled = new Subject[\"Subject\"]();\n        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar scrolling_es5_ViewportRuler = /** @class */ (function () {\n    function ViewportRuler(platform, ngZone) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return Object(merge[\"merge\"])(Object(fromEvent[\"fromEvent\"])(window, 'resize'), Object(fromEvent[\"fromEvent\"])(window, 'orientationchange'));\n        }) : Object(of[\"of\"])();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        return { width: this._viewportSize.width, height: this._viewportSize.height };\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(Object(auditTime[\"auditTime\"])(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    ViewportRuler.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new scrolling_es5_ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ViewportRuler,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */]],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar scrolling_es5_ScrollDispatchModule = /** @class */ (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [platform_es5_PlatformModule],\n                    exports: [scrolling_es5_CdkScrollable],\n                    declarations: [scrolling_es5_CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=scrolling.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/bidi.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new core[\"y\" /* InjectionToken */]('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar bidi_es5_Directionality = /** @class */ (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar bidi_es5_Dir = /** @class */ (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    Dir.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.change.complete();\n    };\n    Dir.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: bidi_es5_Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: core[\"L\" /* Output */], args: ['dirChange',] },],\n        \"dir\": [{ type: core[\"A\" /* Input */], args: ['dir',] },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar bidi_es5_BidiModule = /** @class */ (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [bidi_es5_Dir],\n                    declarations: [bidi_es5_Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: common[\"d\" /* DOCUMENT */] },\n                        bidi_es5_Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=bidi.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(45);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/portal.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-privatew\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface that can be used to generically type a class.\n * @record\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n */\nvar Portal = /** @class */ (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar portal_es5_ComponentPortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar portal_es5_TemplatePortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        if (context) {\n            _this.context = context;\n        }\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = /** @class */ (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof portal_es5_ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof portal_es5_TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar portal_es5_DomPortalOutlet = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(DomPortalOutlet, _super);\n    function DomPortalOutlet(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar portal_es5_CdkPortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    return CdkPortal;\n}(portal_es5_TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>\n */\nvar portal_es5_CdkPortalOutlet = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Whether the portal component is initialized.\n         */\n        _this._isInitialized = false;\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._attachedPortal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._attachedPortal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._attachedPortal = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._attachedPortal = portal;\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._attachedPortal = portal;\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: core[\"A\" /* Input */], args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: core[\"A\" /* Input */], args: ['cdkPortalHost',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar portal_es5_PortalModule = /** @class */ (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                    declarations: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = /** @class */ (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=portal.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/take.js\nvar take = __webpack_require__(129);\nvar take_default = /*#__PURE__*/__webpack_require__.n(take);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subscription.js\nvar Subscription = __webpack_require__(52);\nvar Subscription_default = /*#__PURE__*/__webpack_require__.n(Subscription);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/coercion.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=coercion.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 91;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=keycodes.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/overlay.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = /** @class */ (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = /** @class */ (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config).forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = /** @class */ (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = /** @class */ (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar overlay_es5_ConnectedOverlayPositionChange = /** @class */ (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the CloseScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = /** @class */ (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /**\n         * Detaches the overlay ref and disables the scroll strategy.\n         */\n        this._detach = function () {\n            _this.disable();\n            if (_this._overlayRef.hasAttached()) {\n                _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached overlay on scroll. */\n    /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._scrollSubscription) {\n            return;\n        }\n        var /** @type {?} */ stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(function () {\n                var /** @type {?} */ scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - _this._initialScrollPosition) > /** @type {?} */ ((/** @type {?} */ ((_this._config)).threshold))) {\n                    _this._detach();\n                }\n                else {\n                    _this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = /** @class */ (function () {\n    function BlockScrollStrategy(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = document.documentElement;\n            var /** @type {?} */ body = document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = /** @class */ (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (_this._config && _this._config.autoClose) {\n                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        _this.disable();\n                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                    }\n                }\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar overlay_es5_ScrollStrategyOptions = /** @class */ (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = function (config) {\n            return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config);\n        };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: scrolling_es5_ViewportRuler, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar overlay_es5_OverlayRef = /** @class */ (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._backdropElement = null;\n        this._backdropClick = new Subject[\"Subject\"]();\n        this._attachments = new Subject[\"Subject\"]();\n        this._detachments = new Subject[\"Subject\"]();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject[\"Subject\"]();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(Object(take[\"take\"])(1)).subscribe(function () {\n            _this.updatePosition();\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    function (sizeConfig) {\n        this._config = Object(tslib_es6[\"a\" /* __assign */])({}, this._config, sizeConfig);\n        this._updateElementSize();\n    };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    function (dir) {\n        this._config = Object(tslib_es6[\"a\" /* __assign */])({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });\n        // Add class to fade-in the backdrop after one frame.\n        this._ngZone.runOutsideAngular(function () {\n            requestAnimationFrame(function () {\n                if (_this._backdropElement) {\n                    _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\n                }\n            });\n        });\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar overlay_es5_ConnectedPositionStrategy = /** @class */ (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription[\"Subscription\"].EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject[\"Subject\"]();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the  old position, in order to\n        // prevent the overlay from jumping around.\n        if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n            this.recalculateLastPosition();\n            return;\n        }\n        this._applied = true;\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    function (isLocked) {\n        this._positionLocked = isLocked;\n        return this;\n    };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    function (positions) {\n        this._preferredPositions = positions.slice();\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new overlay_es5_ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = /** @class */ (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef.hasAttached()) {\n            return;\n        }\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = this._document.createElement('div'); /** @type {?} */\n            ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n            ((this._wrapper)).appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar overlay_es5_OverlayPositionBuilder = /** @class */ (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy(this._document);\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new overlay_es5_ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: scrolling_es5_ViewportRuler, },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar overlay_es5_OverlayKeyboardDispatcher = /** @class */ (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._unsubscribeFromKeydownEvents();\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._unsubscribeFromKeydownEvents();\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = Object(fromEvent[\"fromEvent\"])(this._document.body, 'keydown');\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(Object(filter[\"filter\"])(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to correct overlay reference\n            // Dispatch keydown event to correct overlay reference\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use that overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new overlay_es5_OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: overlay_es5_OverlayKeyboardDispatcher,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        common[\"d\" /* DOCUMENT */])\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar overlay_es5_OverlayContainer = /** @class */ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = this._document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new overlay_es5_OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: overlay_es5_OverlayContainer,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayContainer],\n        /** @type {?} */ (common[\"d\" /* DOCUMENT */] // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * The default config for newly created overlays.\n */\nvar defaultConfig = new OverlayConfig();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar overlay_es5_Overlay = /** @class */ (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        if (config === void 0) { config = defaultConfig; }\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new overlay_es5_OverlayRef(portalOutlet, pane, config, this._ngZone, this._keyboardDispatcher);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = this._document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new portal_es5_DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: overlay_es5_ScrollStrategyOptions, },\n        { type: overlay_es5_OverlayContainer, },\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: overlay_es5_OverlayPositionBuilder, },\n        { type: overlay_es5_OverlayKeyboardDispatcher, },\n        { type: core[\"g\" /* ApplicationRef */], },\n        { type: core[\"z\" /* Injector */], },\n        { type: core[\"J\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new core[\"y\" /* InjectionToken */]('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [overlay_es5_Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkOverlayOrigin = /** @class */ (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkConnectedOverlay = /** @class */ (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._positionSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new core[\"s\" /* EventEmitter */]();\n        this._templatePortal = new portal_es5_TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ pos = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        this._handlePositionChanges(strategy);\n        return strategy;\n    };\n    /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._handlePositionChanges = /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    function (strategy) {\n        var _this = this;\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        this._positionSubscription =\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay(); /** @type {?} */\n            ((this._overlayRef)).keydownEvents().subscribe(function (event) {\n                if (event.keyCode === ESCAPE) {\n                    _this._detachOverlay();\n                }\n            });\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.setDirection(this.dir);\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: bidi_es5_Directionality, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"_deprecatedOrigin\": [{ type: core[\"A\" /* Input */], args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: core[\"A\" /* Input */], args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: core[\"A\" /* Input */], args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: core[\"A\" /* Input */], args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: core[\"A\" /* Input */], args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: core[\"A\" /* Input */], args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: core[\"A\" /* Input */], args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: core[\"A\" /* Input */], args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: core[\"A\" /* Input */], args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: core[\"A\" /* Input */], args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: core[\"A\" /* Input */], args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: core[\"A\" /* Input */], args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: core[\"L\" /* Output */] },],\n        \"positionChange\": [{ type: core[\"L\" /* Output */] },],\n        \"attach\": [{ type: core[\"L\" /* Output */] },],\n        \"detach\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    overlay_es5_Overlay,\n    overlay_es5_OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar overlay_es5_OverlayModule = /** @class */ (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [bidi_es5_BidiModule, portal_es5_PortalModule, scrolling_es5_ScrollDispatchModule],\n                    exports: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin, scrolling_es5_ScrollDispatchModule],\n                    declarations: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, overlay_es5_ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar overlay_es5_FullscreenOverlayContainer = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n    */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(overlay_es5_OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=overlay.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n\nvar CONTEXT_MENU_OPTIONS = new core[\"y\" /* InjectionToken */]('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/debounceTime.js\nvar debounceTime = __webpack_require__(719);\nvar debounceTime_default = /*#__PURE__*/__webpack_require__.n(debounceTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/map.js\nvar map = __webpack_require__(92);\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/tap.js\nvar tap = __webpack_require__(309);\nvar tap_default = /*#__PURE__*/__webpack_require__.n(tap);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/a11y.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar a11y_es5_InteractivityChecker = /** @class */ (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server 😎\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = /** @type {?} */ (getWindow(element).frameElement);\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Node type of element nodes. Used instead of Node.ELEMENT_NODE\n * which is unsupported in Universal.\n * \\@docs-private\n */\nvar ELEMENT_NODE_TYPE = 1;\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar a11y_es5_FocusTrap = /** @class */ (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === ELEMENT_NODE_TYPE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === ELEMENT_NODE_TYPE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(Object(take[\"take\"])(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar a11y_es5_FocusTrapFactory = /** @class */ (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new a11y_es5_FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: a11y_es5_InteractivityChecker, },\n        { type: core[\"J\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n */\nvar a11y_es5_FocusTrapDeprecatedDirective = /** @class */ (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: core[\"A\" /* Input */] },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar a11y_es5_CdkTrapFocus = /** @class */ (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: core[\"A\" /* Input */], args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: core[\"A\" /* Input */], args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar a11y_es5_ListKeyManager = /** @class */ (function () {\n    function ListKeyManager(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"Subject\"]();\n        this._typeaheadSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"Subject\"]();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject[\"Subject\"]();\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(tap[\"tap\"])(function (keyCode) { return _this._pressedLetters.push(keyCode); }), Object(debounceTime[\"debounceTime\"])(debounceInterval), Object(filter[\"filter\"])(function () { return _this._pressedLetters.length > 0; }), Object(map[\"map\"])(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        switch (event.keyCode) {\n            case DOWN_ARROW:\n                this.setNextItemActive();\n                break;\n            case UP_ARROW:\n                this.setPreviousItemActive();\n                break;\n            case TAB:\n                this.tabOut.next();\n                return;\n            default:\n                var /** @type {?} */ keyCode = event.keyCode;\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\nvar a11y_es5_ActiveDescendantKeyManager = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar a11y_es5_AriaDescriber = /** @class */ (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!message.trim()) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        if (!messagesContainer) {\n            this._createMessagesContainer();\n        } /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        messagesContainer = this._document.createElement('div');\n        messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n        messagesContainer.setAttribute('aria-hidden', 'true');\n        messagesContainer.style.display = 'none';\n        this._document.body.appendChild(messagesContainer);\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    AriaDescriber.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new a11y_es5_AriaDescriber(_document);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_AriaDescriber,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_AriaDescriber],\n        /** @type {?} */ (common[\"d\" /* DOCUMENT */])\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\nvar a11y_es5_FocusKeyManager = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus();\n        }\n    };\n    return FocusKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new core[\"y\" /* InjectionToken */]('liveAnnouncerElement');\nvar a11y_es5_LiveAnnouncer = /** @class */ (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        this._document = _document;\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new a11y_es5_LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_LiveAnnouncer,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_LiveAnnouncer],\n        [new core[\"K\" /* Optional */](), new core[\"w\" /* Inject */](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        common[\"d\" /* DOCUMENT */],\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar a11y_es5_FocusMonitor = /** @class */ (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Weak map of elements being monitored to their info.\n         */\n        this._elementInfo = new WeakMap();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    FocusMonitor.prototype.monitor = /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof core[\"S\" /* Renderer2 */])) {\n            checkChildren = renderer;\n        }\n        checkChildren = !!checkChildren;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return Object(of[\"of\"])(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject[\"Subject\"]()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeout != null) {\n                clearTimeout(_this._touchTimeout);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar a11y_es5_CdkMonitorFocus = /** @class */ (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new core[\"s\" /* EventEmitter */]();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new a11y_es5_FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_FocusMonitor,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_FocusMonitor], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar a11y_es5_A11yModule = /** @class */ (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [common[\"c\" /* CommonModule */], platform_es5_PlatformModule],\n                    declarations: [a11y_es5_CdkTrapFocus, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    exports: [a11y_es5_CdkTrapFocus, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    providers: [\n                        a11y_es5_InteractivityChecker,\n                        a11y_es5_FocusTrapFactory,\n                        a11y_es5_AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=a11y.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar ARROW_LEFT_KEYCODE = 37;\nvar contextMenuContent_component_ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.openSubMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeLeafMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeAllMenus = new core[\"s\" /* EventEmitter */]();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new core[\"P\" /* QueryList */]();\n        queryList.reset(this.menuItems);\n        this._keyManager = new a11y_es5_ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit();\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: core[\"R\" /* Renderer */], },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: core[\"A\" /* Input */] },],\n        \"item\": [{ type: core[\"A\" /* Input */] },],\n        \"event\": [{ type: core[\"A\" /* Input */] },],\n        \"parentContextMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"overlay\": [{ type: core[\"A\" /* Input */] },],\n        \"isLeaf\": [{ type: core[\"A\" /* Input */] },],\n        \"execute\": [{ type: core[\"L\" /* Output */] },],\n        \"openSubMenu\": [{ type: core[\"L\" /* Output */] },],\n        \"closeLeafMenu\": [{ type: core[\"L\" /* Output */] },],\n        \"closeAllMenus\": [{ type: core[\"L\" /* Output */] },],\n        \"menuElement\": [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n        \"menuItemElements\": [{ type: core[\"_5\" /* ViewChildren */], args: ['li',] },],\n        \"onKeyEvent\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowDown', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Enter', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Escape', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: core[\"v\" /* HostListener */], args: ['document:click', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\n\n//# sourceMappingURL=contextMenuContent.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = core[\"_21\" /* ɵcrt */]({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\n\nfunction View_ContextMenuContentComponent_3(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_18\" /* ɵand */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), core[\"_22\" /* ɵdid */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_39\" /* ɵpod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_18\" /* ɵand */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), core[\"_22\" /* ɵdid */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_39\" /* ɵpod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n          \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), core[\"_22\" /* ɵdid */](3, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n          \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), core[\"_22\" /* ɵdid */](6, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nfunction View_ContextMenuContentComponent_0(_l) { return core[\"_47\" /* ɵvid */](0, [core[\"_43\" /* ɵqud */](402653184, 1, { menuElement: 0 }), core[\"_43\" /* ɵqud */](671088640, 2, { menuItemElements: 1 }), (_l()(), core[\"_23\" /* ɵeld */](2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* ɵeld */](4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n        \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), core[\"_22\" /* ɵdid */](7, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nfunction View_ContextMenuContentComponent_Host_0(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (core[\"_35\" /* ɵnov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (core[\"_35\" /* ɵnov */](_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (core[\"_35\" /* ɵnov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (core[\"_35\" /* ɵnov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (core[\"_35\" /* ɵnov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (core[\"_35\" /* ɵnov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (core[\"_35\" /* ɵnov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (core[\"_35\" /* ɵnov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), core[\"_22\" /* ɵdid */](1, 4440064, null, 0, contextMenuContent_component_ContextMenuContentComponent, [core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS], core[\"R\" /* Renderer */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = core[\"_19\" /* ɵccf */](\"context-menu-content\", contextMenuContent_component_ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\n\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory.js + 4 modules\nvar datepicker_ngfactory = __webpack_require__(295);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ts + 1 modules\nvar calendar_tooltip_directive = __webpack_require__(64);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n\nvar contextMenu_item_directive_ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"divider\": [{ type: core[\"A\" /* Input */] },],\n        \"enabled\": [{ type: core[\"A\" /* Input */] },],\n        \"passive\": [{ type: core[\"A\" /* Input */] },],\n        \"visible\": [{ type: core[\"A\" /* Input */] },],\n        \"execute\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return ContextMenuItemDirective;\n}());\n\n//# sourceMappingURL=contextMenu.item.directive.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n\n\n\n\n\n\nvar contextMenu_service_ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject[\"Subject\"]();\n        this.triggerClose = new Subject[\"Subject\"]();\n        this.close = new Subject[\"Subject\"]();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: event.clientY,\n                    height: 0,\n                    left: event.clientX,\n                    right: event.clientX,\n                    top: event.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus();\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: anchorElement || this.fakeElement }, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new portal_es5_ComponentPortal(contextMenuContent_component_ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription[\"Subscription\"]();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function () {\n        if (this.overlays) {\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var exceptRootMenu = (_a === void 0 ? {} : _a).exceptRootMenu;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > (exceptRootMenu ? 1 : 0) && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: overlay_es5_ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\n\n//# sourceMappingURL=contextMenu.service.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\nvar contextMenu_component___assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\nvar contextMenu_component_ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new core[\"s\" /* EventEmitter */]();\n        this.open = new core[\"s\" /* EventEmitter */]();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) { return _this.onMenuEvent(menuEvent); }));\n        this.subscription.add(_contextMenuService.close.subscribe(function (event) { return _this.close.emit(event); }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(contextMenu_component___assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    encapsulation: core[\"_7\" /* ViewEncapsulation */].None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"autoFocus\": [{ type: core[\"A\" /* Input */] },],\n        \"useBootstrap4\": [{ type: core[\"A\" /* Input */] },],\n        \"disabled\": [{ type: core[\"A\" /* Input */] },],\n        \"close\": [{ type: core[\"L\" /* Output */] },],\n        \"open\": [{ type: core[\"L\" /* Output */] },],\n        \"menuItems\": [{ type: core[\"o\" /* ContentChildren */], args: [contextMenu_item_directive_ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\n\n//# sourceMappingURL=contextMenu.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n\n\n\nvar contextMenu_attach_directive_ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: core[\"A\" /* Input */] },],\n        \"contextMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"onContextMenu\": [{ type: core[\"v\" /* HostListener */], args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\n\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ngfactory.js + 6 modules\nvar calendar_month_view_component_ngfactory = __webpack_require__(297);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ts\nvar calendar_month_view_component = __webpack_require__(88);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-utils.provider.ts\nvar calendar_utils_provider = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ngfactory.js + 4 modules\nvar calendar_week_view_component_ngfactory = __webpack_require__(299);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ts\nvar calendar_week_view_component = __webpack_require__(90);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ngfactory.js + 6 modules\nvar calendar_day_view_component_ngfactory = __webpack_require__(298);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ts\nvar calendar_day_view_component = __webpack_require__(89);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date.pipe.ts\nvar calendar_date_pipe = __webpack_require__(63);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date-formatter.provider.ts\nvar calendar_date_formatter_provider = __webpack_require__(34);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title.pipe.ts\nvar calendar_event_title_pipe = __webpack_require__(95);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title-formatter.provider.ts\nvar calendar_event_title_formatter_provider = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ngfactory.js\nvar calendar_header_component_ngfactory = __webpack_require__(707);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ts\nvar calendar_header_component = __webpack_require__(706);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = core[\"_21\" /* ɵcrt */]({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\n\nfunction View_ContextMenuComponent_0(_l) { return core[\"_47\" /* ɵvid */](0, [core[\"_43\" /* ɵqud */](402653184, 1, { menuElement: 0 }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\" \"]))], null, null); }\nfunction View_ContextMenuComponent_Host_0(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* ɵdid */](1, 180224, null, 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* ɵqud */](603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = core[\"_19\" /* ɵccf */](\"context-menu\", contextMenu_component_ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\n\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/colors.ts\nvar colors = __webpack_require__(708);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ts\n\n\n\nvar component_DemoComponent = /** @class */ (function () {\n    function DemoComponent() {\n        this.view = 'month';\n        this.viewDate = new Date();\n        this.events = [];\n        this.refresh = new Subject[\"Subject\"]();\n    }\n    DemoComponent.prototype.addEvent = function (date) {\n        this.events.push({\n            start: date,\n            title: 'New event',\n            color: colors[\"a\" /* colors */].red\n        });\n        this.refresh.next();\n    };\n    return DemoComponent;\n}());\n\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = core[\"_21\" /* ɵcrt */]({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\n\nfunction View_DemoComponent_1(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (core[\"_35\" /* ɵnov */](_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* ɵdid */](1, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* ɵdid */](2, 147456, null, 0, calendar_tooltip_directive[\"a\" /* CalendarTooltipDirective */], [core[\"q\" /* ElementRef */], core[\"z\" /* Injector */], core[\"S\" /* Renderer2 */], core[\"m\" /* ComponentFactoryResolver */], core[\"_6\" /* ViewContainerRef */], common[\"d\" /* DOCUMENT */]], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), core[\"_40\" /* ɵppd */](3, 3), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* ɵand */](0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = core[\"_46\" /* ɵunv */](_v, 2, 0, _ck(_v, 3, 0, core[\"_35\" /* ɵnov */](_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n  \"])), (_l()(), core[\"_23\" /* ɵeld */](1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* ɵdid */](2, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* ɵeld */](4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_3)), core[\"_22\" /* ɵdid */](7, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* ɵeld */](9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](10, null, [\"\", \"\"])), core[\"_40\" /* ɵppd */](11, 3), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* ɵeld */](14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_4)), core[\"_22\" /* ɵdid */](17, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = core[\"_35\" /* ɵnov */](_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = core[\"_46\" /* ɵunv */](_v, 10, 0, _ck(_v, 11, 0, core[\"_35\" /* ɵnov */](_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* ɵdid */](1, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* ɵeld */](3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](4, null, [\"\", \"\"])), core[\"_40\" /* ɵppd */](5, 3), (_l()(), core[\"_23\" /* ɵeld */](6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* ɵeld */](8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](9, null, [\"\", \"\"])), core[\"_40\" /* ɵppd */](10, 3), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = core[\"_35\" /* ɵnov */](_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = core[\"_46\" /* ɵunv */](_v, 4, 0, _ck(_v, 5, 0, core[\"_35\" /* ɵnov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = core[\"_46\" /* ɵunv */](_v, 9, 0, _ck(_v, 10, 0, core[\"_35\" /* ɵnov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* ɵeld */](1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_6)), core[\"_22\" /* ɵdid */](4, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* ɵeld */](1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* ɵdid */](2, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* ɵdid */](3, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* ɵeld */](5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](6, null, [\"\\n      \", \"\\n    \"])), core[\"_40\" /* ɵppd */](7, 3), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = core[\"_35\" /* ɵnov */](_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = core[\"_46\" /* ɵunv */](_v, 6, 0, _ck(_v, 7, 0, core[\"_35\" /* ɵnov */](_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, calendar_month_view_component_ngfactory[\"b\" /* View_CalendarMonthViewComponent_0 */], calendar_month_view_component_ngfactory[\"a\" /* RenderType_CalendarMonthViewComponent */])), core[\"_22\" /* ɵdid */](1, 770048, null, 0, calendar_month_view_component[\"a\" /* CalendarMonthViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_35\" /* ɵnov */](_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, calendar_week_view_component_ngfactory[\"b\" /* View_CalendarWeekViewComponent_0 */], calendar_week_view_component_ngfactory[\"a\" /* RenderType_CalendarWeekViewComponent */])), core[\"_22\" /* ɵdid */](1, 770048, null, 0, calendar_week_view_component[\"a\" /* CalendarWeekViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_35\" /* ɵnov */](_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, calendar_day_view_component_ngfactory[\"b\" /* View_CalendarDayViewComponent_0 */], calendar_day_view_component_ngfactory[\"a\" /* RenderType_CalendarDayViewComponent */])), core[\"_22\" /* ɵdid */](1, 770048, null, 0, calendar_day_view_component[\"a\" /* CalendarDayViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_35\" /* ɵnov */](_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_0(_l) { return core[\"_47\" /* ɵvid */](2, [core[\"_38\" /* ɵpid */](0, calendar_date_pipe[\"a\" /* CalendarDatePipe */], [calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], core[\"D\" /* LOCALE_ID */]]), core[\"_38\" /* ɵpid */](0, calendar_event_title_pipe[\"a\" /* CalendarEventTitlePipe */], [calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */]]), (_l()(), core[\"_23\" /* ɵeld */](2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, calendar_header_component_ngfactory[\"b\" /* View_CalendarHeaderComponent_0 */], calendar_header_component_ngfactory[\"a\" /* RenderType_CalendarHeaderComponent */])), core[\"_22\" /* ɵdid */](3, 49152, null, 0, calendar_header_component[\"a\" /* CalendarHeaderComponent */], [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* ɵeld */](6, 0, null, null, 6, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* ɵdid */](7, 180224, [[\"basicMenu\", 4]], 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* ɵqud */](603979776, 1, { menuItems: 1 }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* ɵand */](0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), core[\"_22\" /* ɵdid */](11, 16384, [[1, 4]], 0, contextMenu_item_directive_ContextMenuItemDirective, [core[\"_1\" /* TemplateRef */], core[\"q\" /* ElementRef */]], null, { execute: \"execute\" }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* ɵand */](0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* ɵand */](0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* ɵand */](0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* ɵeld */](20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), core[\"_22\" /* ɵdid */](21, 16384, null, 0, common[\"p\" /* NgSwitch */], [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_8)), core[\"_22\" /* ɵdid */](24, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_9)), core[\"_22\" /* ɵdid */](27, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_10)), core[\"_22\" /* ɵdid */](30, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nfunction View_DemoComponent_Host_0(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), core[\"_22\" /* ɵdid */](1, 49152, null, 0, component_DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = core[\"_19\" /* ɵccf */](\"mwl-demo-component\", component_DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\n\n//# sourceMappingURL=component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js\nvar esm5_forms = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar.js\nvar ngb_calendar = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n.js\nvar datepicker_i18n = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter.js\nvar ngb_date_parser_formatter = __webpack_require__(62);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-adapter.js\nvar ngb_date_adapter = __webpack_require__(44);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config.js\nvar datepicker_config = __webpack_require__(61);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config.js\nvar timepicker_config = __webpack_require__(51);\n\n// EXTERNAL MODULE: ./node_modules/angular-draggable-droppable/esm5/angular-draggable-droppable.js\nvar angular_draggable_droppable = __webpack_require__(28);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-common.module.ts + 2 modules\nvar calendar_common_module = __webpack_require__(126);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month.module.ts\nvar calendar_month_module = __webpack_require__(183);\n\n// EXTERNAL MODULE: ./node_modules/angular-resizable-element/esm5/angular-resizable-element.js\nvar angular_resizable_element = __webpack_require__(125);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week.module.ts\nvar calendar_week_module = __webpack_require__(184);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day.module.ts\nvar calendar_day_module = __webpack_require__(185);\n\n// EXTERNAL MODULE: ./src/modules/calendar.module.ts\nvar calendar_module = __webpack_require__(293);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n\n\n\n\n\n\n\n\n\nvar ngx_contextmenu_ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                contextMenu_service_ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    declarations: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenuContent_component_ContextMenuContentComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        contextMenuContent_component_ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        common[\"c\" /* CommonModule */],\n                        overlay_es5_OverlayModule,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\n\n//# sourceMappingURL=ngx-contextmenu.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module.js + 3 modules\nvar datepicker_module = __webpack_require__(127);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module.js\nvar timepicker_module = __webpack_require__(128);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/module.ts\nvar demo_utils_module = __webpack_require__(296);\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(87);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DemoModuleNgFactory\", function() { return DemoModuleNgFactory; });\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DemoModuleNgFactory = core[\"_20\" /* ɵcmf */](DemoModule, [], function (_l) { return core[\"_31\" /* ɵmod */]([core[\"_32\" /* ɵmpd */](512, core[\"m\" /* ComponentFactoryResolver */], core[\"_16\" /* ɵCodegenComponentFactoryResolver */], [[8, [calendar_tooltip_directive_ngfactory[\"a\" /* CalendarTooltipWindowComponentNgFactory */], ContextMenuContentComponentNgFactory, datepicker_ngfactory[\"a\" /* NgbDatepickerNgFactory */], DemoComponentNgFactory]], [3, core[\"m\" /* ComponentFactoryResolver */]], core[\"H\" /* NgModuleRef */]]), core[\"_32\" /* ɵmpd */](4608, common[\"o\" /* NgLocalization */], common[\"n\" /* NgLocaleLocalization */], [core[\"D\" /* LOCALE_ID */], [2, common[\"y\" /* ɵa */]]]), core[\"_32\" /* ɵmpd */](6144, DIR_DOCUMENT, null, [common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](4608, bidi_es5_Directionality, bidi_es5_Directionality, [[2, DIR_DOCUMENT]]), core[\"_32\" /* ɵmpd */](4608, platform_es5_Platform, platform_es5_Platform, []), core[\"_32\" /* ɵmpd */](5120, scrolling_es5_ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform]), core[\"_32\" /* ɵmpd */](5120, scrolling_es5_ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, [[3, scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */]]), core[\"_32\" /* ɵmpd */](4608, overlay_es5_ScrollStrategyOptions, overlay_es5_ScrollStrategyOptions, [scrolling_es5_ScrollDispatcher, scrolling_es5_ViewportRuler, core[\"J\" /* NgZone */]]), core[\"_32\" /* ɵmpd */](5120, overlay_es5_OverlayContainer, OVERLAY_CONTAINER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayContainer], common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](4608, overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayPositionBuilder, [scrolling_es5_ViewportRuler, common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](5120, overlay_es5_OverlayKeyboardDispatcher, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayKeyboardDispatcher], common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](4608, overlay_es5_Overlay, overlay_es5_Overlay, [overlay_es5_ScrollStrategyOptions, overlay_es5_OverlayContainer, core[\"m\" /* ComponentFactoryResolver */], overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayKeyboardDispatcher, core[\"g\" /* ApplicationRef */], core[\"z\" /* Injector */], core[\"J\" /* NgZone */], common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](5120, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY, [overlay_es5_Overlay]), core[\"_32\" /* ɵmpd */](4608, esm5_forms[\"o\" /* ɵi */], esm5_forms[\"o\" /* ɵi */], []), core[\"_32\" /* ɵmpd */](4608, ngb_calendar[\"a\" /* NgbCalendar */], ngb_calendar[\"b\" /* NgbCalendarGregorian */], []), core[\"_32\" /* ɵmpd */](4608, datepicker_i18n[\"a\" /* NgbDatepickerI18n */], datepicker_i18n[\"b\" /* NgbDatepickerI18nDefault */], []), core[\"_32\" /* ɵmpd */](4608, ngb_date_parser_formatter[\"b\" /* NgbDateParserFormatter */], ngb_date_parser_formatter[\"a\" /* NgbDateISOParserFormatter */], []), core[\"_32\" /* ɵmpd */](4608, ngb_date_adapter[\"a\" /* NgbDateAdapter */], ngb_date_adapter[\"b\" /* NgbDateStructAdapter */], []), core[\"_32\" /* ɵmpd */](4608, datepicker_config[\"a\" /* NgbDatepickerConfig */], datepicker_config[\"a\" /* NgbDatepickerConfig */], []), core[\"_32\" /* ɵmpd */](4608, timepicker_config[\"a\" /* NgbTimepickerConfig */], timepicker_config[\"a\" /* NgbTimepickerConfig */], []), core[\"_32\" /* ɵmpd */](4608, angular_draggable_droppable[\"b\" /* DraggableHelper */], angular_draggable_droppable[\"b\" /* DraggableHelper */], []), core[\"_32\" /* ɵmpd */](4608, calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], []), core[\"_32\" /* ɵmpd */](4608, calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], []), core[\"_32\" /* ɵmpd */](4608, calendar_utils_provider[\"a\" /* CalendarUtils */], calendar_utils_provider[\"a\" /* CalendarUtils */], []), core[\"_32\" /* ɵmpd */](4608, contextMenu_service_ContextMenuService, contextMenu_service_ContextMenuService, [overlay_es5_Overlay, overlay_es5_ScrollStrategyOptions]), core[\"_32\" /* ɵmpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_common_module[\"a\" /* CalendarCommonModule */], calendar_common_module[\"a\" /* CalendarCommonModule */], []), core[\"_32\" /* ɵmpd */](512, angular_draggable_droppable[\"a\" /* DragAndDropModule */], angular_draggable_droppable[\"a\" /* DragAndDropModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_month_module[\"a\" /* CalendarMonthModule */], calendar_month_module[\"a\" /* CalendarMonthModule */], []), core[\"_32\" /* ɵmpd */](512, angular_resizable_element[\"b\" /* ResizableModule */], angular_resizable_element[\"b\" /* ResizableModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_week_module[\"a\" /* CalendarWeekModule */], calendar_week_module[\"a\" /* CalendarWeekModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_day_module[\"a\" /* CalendarDayModule */], calendar_day_module[\"a\" /* CalendarDayModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_module[\"c\" /* CalendarModule */], calendar_module[\"c\" /* CalendarModule */], []), core[\"_32\" /* ɵmpd */](512, bidi_es5_BidiModule, bidi_es5_BidiModule, []), core[\"_32\" /* ɵmpd */](512, portal_es5_PortalModule, portal_es5_PortalModule, []), core[\"_32\" /* ɵmpd */](512, platform_es5_PlatformModule, platform_es5_PlatformModule, []), core[\"_32\" /* ɵmpd */](512, scrolling_es5_ScrollDispatchModule, scrolling_es5_ScrollDispatchModule, []), core[\"_32\" /* ɵmpd */](512, overlay_es5_OverlayModule, overlay_es5_OverlayModule, []), core[\"_32\" /* ɵmpd */](512, ngx_contextmenu_ContextMenuModule, ngx_contextmenu_ContextMenuModule, []), core[\"_32\" /* ɵmpd */](512, esm5_forms[\"m\" /* ɵba */], esm5_forms[\"m\" /* ɵba */], []), core[\"_32\" /* ɵmpd */](512, esm5_forms[\"d\" /* FormsModule */], esm5_forms[\"d\" /* FormsModule */], []), core[\"_32\" /* ɵmpd */](512, datepicker_module[\"a\" /* NgbDatepickerModule */], datepicker_module[\"a\" /* NgbDatepickerModule */], []), core[\"_32\" /* ɵmpd */](512, timepicker_module[\"a\" /* NgbTimepickerModule */], timepicker_module[\"a\" /* NgbTimepickerModule */], []), core[\"_32\" /* ɵmpd */](512, demo_utils_module[\"a\" /* DemoUtilsModule */], demo_utils_module[\"a\" /* DemoUtilsModule */], []), core[\"_32\" /* ɵmpd */](512, router[\"o\" /* RouterModule */], router[\"o\" /* RouterModule */], [[2, router[\"t\" /* ɵa */]], [2, router[\"m\" /* Router */]]]), core[\"_32\" /* ɵmpd */](512, DemoModule, DemoModule, []), core[\"_32\" /* ɵmpd */](256, CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), core[\"_32\" /* ɵmpd */](1024, router[\"k\" /* ROUTES */], function () { return [[{ path: \"\", component: component_DemoComponent }]]; }, [])]); });\n\n//# sourceMappingURL=module.ngfactory.js.map\n\n/***/ }),\n\n/***/ 714:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(300);\nvar audit_1 = __webpack_require__(715);\nvar timer_1 = __webpack_require__(716);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n\n/***/ 715:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(131);\nvar errorObject_1 = __webpack_require__(94);\nvar OuterSubscriber_1 = __webpack_require__(55);\nvar subscribeToResult_1 = __webpack_require__(54);\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n/***/ }),\n\n/***/ 716:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(717);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 717:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(307);\nvar Observable_1 = __webpack_require__(11);\nvar async_1 = __webpack_require__(300);\nvar isScheduler_1 = __webpack_require__(188);\nvar isDate_1 = __webpack_require__(718);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n\n/***/ 718:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n\n/***/ 719:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(10);\nvar async_1 = __webpack_require__(300);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 35-f24c09d0f82cd9e8f416.js","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar Platform = /** @class */ (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser &&\n            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of <input> that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar PlatformModule = /** @class */ (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: NgModule, args: [{\n                    providers: [Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, supportsPassiveEventListeners, getSupportedInputTypes, PlatformModule };\n//# sourceMappingURL=platform.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/platform.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Injectable, NgModule, NgZone, Optional, SkipSelf } from '@angular/core';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\nimport { of } from 'rxjs/observable/of';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { auditTime } from 'rxjs/operators/auditTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { merge } from 'rxjs/observable/merge';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar ScrollDispatcher = /** @class */ (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable.create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (_this._globalSubscription && !_this._scrolledCount) {\n                    _this._globalSubscription.unsubscribe();\n                    _this._globalSubscription = null;\n                }\n            };\n        }) : of();\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll and resize listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    ScrollDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: ScrollDispatcher,\n    deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar CdkScrollable = /** @class */ (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._elementScrolled = new Subject();\n        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: ScrollDispatcher, },\n        { type: NgZone, },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar ViewportRuler = /** @class */ (function () {\n    function ViewportRuler(platform, ngZone) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange'));\n        }) : of();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        return { width: this._viewportSize.width, height: this._viewportSize.height };\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    ViewportRuler.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: ViewportRuler,\n    deps: [[new Optional(), new SkipSelf(), ViewportRuler], Platform, NgZone],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar ScrollDispatchModule = /** @class */ (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [PlatformModule],\n                    exports: [CdkScrollable],\n                    declarations: [CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_SCROLL_TIME, ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, SCROLL_DISPATCHER_PROVIDER, CdkScrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, VIEWPORT_RULER_PROVIDER, ScrollDispatchModule };\n//# sourceMappingURL=scrolling.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { ComponentFactoryResolver, Directive, Input, NgModule, TemplateRef, ViewContainerRef } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-privatew\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface that can be used to generically type a class.\n * @record\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n */\nvar Portal = /** @class */ (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar ComponentPortal = /** @class */ (function (_super) {\n    __extends(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar TemplatePortal = /** @class */ (function (_super) {\n    __extends(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        if (context) {\n            _this.context = context;\n        }\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = /** @class */ (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar DomPortalOutlet = /** @class */ (function (_super) {\n    __extends(DomPortalOutlet, _super);\n    function DomPortalOutlet(_hostDomElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this._hostDomElement = _hostDomElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar CdkPortal = /** @class */ (function (_super) {\n    __extends(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n    ]; };\n    return CdkPortal;\n}(TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>\n */\nvar CdkPortalOutlet = /** @class */ (function (_super) {\n    __extends(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Whether the portal component is initialized.\n         */\n        _this._isInitialized = false;\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._attachedPortal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._attachedPortal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._attachedPortal = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._attachedPortal = portal;\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._attachedPortal = portal;\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: ComponentFactoryResolver, },\n        { type: ViewContainerRef, },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: Input, args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: Input, args: ['cdkPortalHost',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar PortalModule = /** @class */ (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [CdkPortal, CdkPortalOutlet],\n                    declarations: [CdkPortal, CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = /** @class */ (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DomPortalOutlet as DomPortalHost, CdkPortalOutlet as PortalHostDirective, CdkPortal as TemplatePortalDirective, BasePortalOutlet as BasePortalHost, Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, DomPortalOutlet, CdkPortal, CdkPortalOutlet, PortalModule, PortalInjector };\n//# sourceMappingURL=portal.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/portal.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return isNaN(parseFloat(/** @type {?} */ (value))) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceBooleanProperty, coerceNumberProperty, coerceArray };\n//# sourceMappingURL=coercion.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/coercion.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, SkipSelf, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { CdkScrollable, ScrollDispatchModule, ScrollDispatcher, VIEWPORT_RULER_PROVIDER, ViewportRuler } from '@angular/cdk/scrolling';\nimport { BidiModule, Directionality } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { __assign, __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { take } from 'rxjs/operators/take';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { DOCUMENT } from '@angular/common';\nimport { filter } from 'rxjs/operators/filter';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = /** @class */ (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = /** @class */ (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config).forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = /** @class */ (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = /** @class */ (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar ConnectedOverlayPositionChange = /** @class */ (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: Optional },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the CloseScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = /** @class */ (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /**\n         * Detaches the overlay ref and disables the scroll strategy.\n         */\n        this._detach = function () {\n            _this.disable();\n            if (_this._overlayRef.hasAttached()) {\n                _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached overlay on scroll. */\n    /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._scrollSubscription) {\n            return;\n        }\n        var /** @type {?} */ stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(function () {\n                var /** @type {?} */ scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - _this._initialScrollPosition) > /** @type {?} */ ((/** @type {?} */ ((_this._config)).threshold))) {\n                    _this._detach();\n                }\n                else {\n                    _this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = /** @class */ (function () {\n    function BlockScrollStrategy(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = document.documentElement;\n            var /** @type {?} */ body = document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        if (document.documentElement.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = /** @class */ (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (_this._config && _this._config.autoClose) {\n                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        _this.disable();\n                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                    }\n                }\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar ScrollStrategyOptions = /** @class */ (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = function (config) {\n            return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config);\n        };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: ScrollDispatcher, },\n        { type: ViewportRuler, },\n        { type: NgZone, },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = /** @class */ (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n            _this.updatePosition();\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    function (sizeConfig) {\n        this._config = __assign({}, this._config, sizeConfig);\n        this._updateElementSize();\n    };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    function (dir) {\n        this._config = __assign({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () { return _this._backdropClick.next(null); });\n        // Add class to fade-in the backdrop after one frame.\n        this._ngZone.runOutsideAngular(function () {\n            requestAnimationFrame(function () {\n                if (_this._backdropElement) {\n                    _this._backdropElement.classList.add('cdk-overlay-backdrop-showing');\n                }\n            });\n        });\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar ConnectedPositionStrategy = /** @class */ (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the  old position, in order to\n        // prevent the overlay from jumping around.\n        if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n            this.recalculateLastPosition();\n            return;\n        }\n        this._applied = true;\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    function (isLocked) {\n        this._positionLocked = isLocked;\n        return this;\n    };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    function (positions) {\n        this._preferredPositions = positions.slice();\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = /** @class */ (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef.hasAttached()) {\n            return;\n        }\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = this._document.createElement('div'); /** @type {?} */\n            ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n            ((this._wrapper)).appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar OverlayPositionBuilder = /** @class */ (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy(this._document);\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: ViewportRuler, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar OverlayKeyboardDispatcher = /** @class */ (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._unsubscribeFromKeydownEvents();\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._unsubscribeFromKeydownEvents();\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = fromEvent(this._document.body, 'keydown');\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(filter(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to correct overlay reference\n            // Dispatch keydown event to correct overlay reference\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use that overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: OverlayKeyboardDispatcher,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        DOCUMENT)\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar OverlayContainer = /** @class */ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = this._document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayContainer],\n        /** @type {?} */ (DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * The default config for newly created overlays.\n */\nvar defaultConfig = new OverlayConfig();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar Overlay = /** @class */ (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        if (config === void 0) { config = defaultConfig; }\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new OverlayRef(portalOutlet, pane, config, this._ngZone, this._keyboardDispatcher);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = this._document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: ScrollStrategyOptions, },\n        { type: OverlayContainer, },\n        { type: ComponentFactoryResolver, },\n        { type: OverlayPositionBuilder, },\n        { type: OverlayKeyboardDispatcher, },\n        { type: ApplicationRef, },\n        { type: Injector, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar CdkOverlayOrigin = /** @class */ (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: ElementRef, },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar CdkConnectedOverlay = /** @class */ (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._positionSubscription = Subscription.EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ pos = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: pos.originX, originY: pos.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: pos.overlayX, overlayY: pos.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        this._handlePositionChanges(strategy);\n        return strategy;\n    };\n    /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._handlePositionChanges = /**\n     * @param {?} strategy\n     * @return {?}\n     */\n    function (strategy) {\n        var _this = this;\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        this._positionSubscription =\n            strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay(); /** @type {?} */\n            ((this._overlayRef)).keydownEvents().subscribe(function (event) {\n                if (event.keyCode === ESCAPE) {\n                    _this._detachOverlay();\n                }\n            });\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.setDirection(this.dir);\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n        this._positionSubscription.unsubscribe();\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: Directionality, decorators: [{ type: Optional },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: Input, args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: Input, args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: Input, args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: Input, args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: Input, args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"_deprecatedOrigin\": [{ type: Input, args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: Input, args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: Input, args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: Input, args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: Input, args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: Input, args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: Input, args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: Input, args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: Input, args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: Input, args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: Input, args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: Input, args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: Output },],\n        \"positionChange\": [{ type: Output },],\n        \"attach\": [{ type: Output },],\n        \"detach\": [{ type: Output },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar OverlayModule = /** @class */ (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [BidiModule, PortalModule, ScrollDispatchModule],\n                    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollDispatchModule],\n                    declarations: [CdkConnectedOverlay, CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar FullscreenOverlayContainer = /** @class */ (function (_super) {\n    __extends(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n    */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, ViewportRuler, OverlayKeyboardDispatcher, GlobalPositionStrategy, ConnectedPositionStrategy, VIEWPORT_RULER_PROVIDER, CdkConnectedOverlay as ConnectedOverlayDirective, CdkOverlayOrigin as OverlayOrigin, OverlayConfig, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, CdkScrollable, ScrollDispatcher, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER as ɵg, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY as ɵf, OVERLAY_CONTAINER_PROVIDER as ɵb, OVERLAY_CONTAINER_PROVIDER_FACTORY as ɵa, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as ɵc, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as ɵe, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as ɵd, OverlayPositionBuilder as ɵh };\n//# sourceMappingURL=overlay.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/overlay.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { take } from 'rxjs/operators/take';\nimport { Platform, PlatformModule, supportsPassiveEventListeners } from '@angular/cdk/platform';\nimport { CommonModule, DOCUMENT } from '@angular/common';\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { A, DOWN_ARROW, NINE, TAB, UP_ARROW, Z, ZERO } from '@angular/cdk/keycodes';\nimport { debounceTime } from 'rxjs/operators/debounceTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\nimport { tap } from 'rxjs/operators/tap';\nimport { of } from 'rxjs/observable/of';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar InteractivityChecker = /** @class */ (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server 😎\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = /** @type {?} */ (getWindow(element).frameElement);\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an <input type=\"hidden\">.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Node type of element nodes. Used instead of Node.ELEMENT_NODE\n * which is unsupported in Universal.\n * \\@docs-private\n */\nvar ELEMENT_NODE_TYPE = 1;\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar FocusTrap = /** @class */ (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === ELEMENT_NODE_TYPE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === ELEMENT_NODE_TYPE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar FocusTrapFactory = /** @class */ (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: InteractivityChecker, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n */\nvar FocusTrapDeprecatedDirective = /** @class */ (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: Input },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar CdkTrapFocus = /** @class */ (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: Input, args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: Input, args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar ListKeyManager = /** @class */ (function () {\n    function ListKeyManager(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject();\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), debounceTime(debounceInterval), filter(function () { return _this._pressedLetters.length > 0; }), map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        switch (event.keyCode) {\n            case DOWN_ARROW:\n                this.setNextItemActive();\n                break;\n            case UP_ARROW:\n                this.setPreviousItemActive();\n                break;\n            case TAB:\n                this.tabOut.next();\n                return;\n            default:\n                var /** @type {?} */ keyCode = event.keyCode;\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\nvar ActiveDescendantKeyManager = /** @class */ (function (_super) {\n    __extends(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar AriaDescriber = /** @class */ (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (!message.trim()) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        if (!messagesContainer) {\n            this._createMessagesContainer();\n        } /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        messagesContainer = this._document.createElement('div');\n        messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n        messagesContainer.setAttribute('aria-hidden', 'true');\n        messagesContainer.style.display = 'none';\n        this._document.body.appendChild(messagesContainer);\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    AriaDescriber.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new AriaDescriber(_document);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: AriaDescriber,\n    deps: [\n        [new Optional(), new SkipSelf(), AriaDescriber],\n        /** @type {?} */ (DOCUMENT)\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\nvar FocusKeyManager = /** @class */ (function (_super) {\n    __extends(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus();\n        }\n    };\n    return FocusKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement');\nvar LiveAnnouncer = /** @class */ (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        this._document = _document;\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: LiveAnnouncer,\n    deps: [\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        DOCUMENT,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar FocusMonitor = /** @class */ (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Weak map of elements being monitored to their info.\n         */\n        this._elementInfo = new WeakMap();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    FocusMonitor.prototype.monitor = /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof Renderer2)) {\n            checkChildren = renderer;\n        }\n        checkChildren = !!checkChildren;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return of(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeout != null) {\n                clearTimeout(_this._touchTimeout);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeout = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            setTimeout(function () { return _this._windowFocused = false; }, 0);\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar CdkMonitorFocus = /** @class */ (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: Output },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar A11yModule = /** @class */ (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule, PlatformModule],\n                    declarations: [CdkTrapFocus, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    exports: [CdkTrapFocus, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    providers: [\n                        InteractivityChecker,\n                        FocusTrapFactory,\n                        AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkTrapFocus as FocusTrapDirective, ActiveDescendantKeyManager, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER_FACTORY, ARIA_DESCRIBER_PROVIDER, isFakeMousedownFromScreenReader, FocusKeyManager, FocusTrap, FocusTrapFactory, FocusTrapDeprecatedDirective, CdkTrapFocus, InteractivityChecker, ListKeyManager, LIVE_ANNOUNCER_ELEMENT_TOKEN, LiveAnnouncer, LIVE_ANNOUNCER_PROVIDER_FACTORY, LIVE_ANNOUNCER_PROVIDER, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER_FACTORY, FOCUS_MONITOR_PROVIDER, A11yModule };\n//# sourceMappingURL=a11y.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/a11y.es5.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./contextMenuContent.component\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = i0.ɵcrt({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\nexport { RenderType_ContextMenuContentComponent as RenderType_ContextMenuContentComponent };\nfunction View_ContextMenuContentComponent_3(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵand(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n            \"])), (_l()(), i0.ɵand(16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), i0.ɵdid(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.ɵpod(4, { $implicit: 0 }), (_l()(), i0.ɵted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵand(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n            \"])), (_l()(), i0.ɵand(16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), i0.ɵdid(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.ɵpod(4, { $implicit: 0 }), (_l()(), i0.ɵted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n          \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), i0.ɵdid(3, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n\\n          \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), i0.ɵdid(6, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nexport function View_ContextMenuContentComponent_0(_l) { return i0.ɵvid(0, [i0.ɵqud(402653184, 1, { menuElement: 0 }), i0.ɵqud(671088640, 2, { menuItemElements: 1 }), (_l()(), i0.ɵeld(2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵeld(4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n        \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), i0.ɵdid(7, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nexport function View_ContextMenuContentComponent_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (i0.ɵnov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (i0.ɵnov(_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (i0.ɵnov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (i0.ɵnov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (i0.ɵnov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (i0.ɵnov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (i0.ɵnov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (i0.ɵnov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), i0.ɵdid(1, 4440064, null, 0, i2.ContextMenuContentComponent, [i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS], i0.Renderer], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = i0.ɵccf(\"context-menu-content\", i2.ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\nexport { ContextMenuContentComponentNgFactory as ContextMenuContentComponentNgFactory };\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./contextMenu.component\";\nimport * as i2 from \"./contextMenu.service\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = i0.ɵcrt({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\nexport { RenderType_ContextMenuComponent as RenderType_ContextMenuComponent };\nexport function View_ContextMenuComponent_0(_l) { return i0.ɵvid(0, [i0.ɵqud(402653184, 1, { menuElement: 0 }), (_l()(), i0.ɵted(-1, null, [\" \"]))], null, null); }\nexport function View_ContextMenuComponent_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), i0.ɵdid(1, 180224, null, 1, i1.ContextMenuComponent, [i2.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS]], null, null), i0.ɵqud(603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = i0.ɵccf(\"context-menu\", i1.ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\nexport { ContextMenuComponentNgFactory as ContextMenuComponentNgFactory };\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive\";\nimport * as i3 from \"ngx-contextmenu/lib/contextMenu.attach.directive\";\nimport * as i4 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i5 from \"../../../src/modules/month/calendar-month-view.component.ngfactory\";\nimport * as i6 from \"../../../src/modules/month/calendar-month-view.component\";\nimport * as i7 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i8 from \"../../../src/modules/week/calendar-week-view.component.ngfactory\";\nimport * as i9 from \"../../../src/modules/week/calendar-week-view.component\";\nimport * as i10 from \"../../../src/modules/day/calendar-day-view.component.ngfactory\";\nimport * as i11 from \"../../../src/modules/day/calendar-day-view.component\";\nimport * as i12 from \"../../../src/modules/common/calendar-date.pipe\";\nimport * as i13 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i14 from \"../../../src/modules/common/calendar-event-title.pipe\";\nimport * as i15 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i16 from \"../demo-utils/calendar-header.component.ngfactory\";\nimport * as i17 from \"../demo-utils/calendar-header.component\";\nimport * as i18 from \"../../../node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory\";\nimport * as i19 from \"ngx-contextmenu/lib/contextMenu.component\";\nimport * as i20 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i21 from \"ngx-contextmenu/lib/contextMenu.item.directive\";\nimport * as i22 from \"./component\";\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = i0.ɵcrt({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\nexport { RenderType_DemoComponent as RenderType_DemoComponent };\nfunction View_DemoComponent_1(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵted(-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), i0.ɵted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (i0.ɵnov(_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), i0.ɵdid(1, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.ɵdid(2, 147456, null, 0, i2.CalendarTooltipDirective, [i0.ElementRef, i0.Injector, i0.Renderer2, i0.ComponentFactoryResolver, i0.ViewContainerRef, i1.DOCUMENT], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), i0.ɵppd(3, 3), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵand(0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = i0.ɵunv(_v, 2, 0, _ck(_v, 3, 0, i0.ɵnov(_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵted(-1, null, [\"\\n\\n  \"])), (_l()(), i0.ɵeld(1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.ɵdid(2, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵeld(4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_3)), i0.ɵdid(7, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵeld(9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), i0.ɵted(10, null, [\"\", \"\"])), i0.ɵppd(11, 3), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵeld(14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_4)), i0.ɵdid(17, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = i0.ɵnov(_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = i0.ɵunv(_v, 10, 0, _ck(_v, 11, 0, i0.ɵnov(_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), i0.ɵdid(1, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵeld(3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), i0.ɵted(4, null, [\"\", \"\"])), i0.ɵppd(5, 3), (_l()(), i0.ɵeld(6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵeld(8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), i0.ɵted(9, null, [\"\", \"\"])), i0.ɵppd(10, 3), (_l()(), i0.ɵted(-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = i0.ɵnov(_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = i0.ɵunv(_v, 4, 0, _ck(_v, 5, 0, i0.ɵnov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = i0.ɵunv(_v, 9, 0, _ck(_v, 10, 0, i0.ɵnov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵeld(1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_6)), i0.ɵdid(4, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵeld(1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.ɵdid(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.ɵdid(3, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵeld(5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), i0.ɵted(6, null, [\"\\n      \", \"\\n    \"])), i0.ɵppd(7, 3), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = i0.ɵnov(_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = i0.ɵunv(_v, 6, 0, _ck(_v, 7, 0, i0.ɵnov(_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, i5.View_CalendarMonthViewComponent_0, i5.RenderType_CalendarMonthViewComponent)), i0.ɵdid(1, 770048, null, 0, i6.CalendarMonthViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.ɵnov(_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, i8.View_CalendarWeekViewComponent_0, i8.RenderType_CalendarWeekViewComponent)), i0.ɵdid(1, 770048, null, 0, i9.CalendarWeekViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.ɵnov(_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, i10.View_CalendarDayViewComponent_0, i10.RenderType_CalendarDayViewComponent)), i0.ɵdid(1, 770048, null, 0, i11.CalendarDayViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.ɵnov(_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nexport function View_DemoComponent_0(_l) { return i0.ɵvid(2, [i0.ɵpid(0, i12.CalendarDatePipe, [i13.CalendarDateFormatter, i0.LOCALE_ID]), i0.ɵpid(0, i14.CalendarEventTitlePipe, [i15.CalendarEventTitleFormatter]), (_l()(), i0.ɵeld(2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, i16.View_CalendarHeaderComponent_0, i16.RenderType_CalendarHeaderComponent)), i0.ɵdid(3, 49152, null, 0, i17.CalendarHeaderComponent, [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), i0.ɵted(-1, null, [\"\\n\"])), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵeld(6, 0, null, null, 6, \"context-menu\", [], null, null, null, i18.View_ContextMenuComponent_0, i18.RenderType_ContextMenuComponent)), i0.ɵdid(7, 180224, [[\"basicMenu\", 4]], 1, i19.ContextMenuComponent, [i4.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i20.CONTEXT_MENU_OPTIONS]], null, null), i0.ɵqud(603979776, 1, { menuItems: 1 }), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵand(0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), i0.ɵdid(11, 16384, [[1, 4]], 0, i21.ContextMenuItemDirective, [i0.TemplateRef, i0.ElementRef], null, { execute: \"execute\" }), (_l()(), i0.ɵted(-1, null, [\"\\n\"])), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵand(0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵand(0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵand(0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵeld(20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), i0.ɵdid(21, 16384, null, 0, i1.NgSwitch, [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_8)), i0.ɵdid(24, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_9)), i0.ɵdid(27, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_10)), i0.ɵdid(30, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nexport function View_DemoComponent_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), i0.ɵdid(1, 49152, null, 0, i22.DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = i0.ɵccf(\"mwl-demo-component\", i22.DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\nexport { DemoComponentNgFactory as DemoComponentNgFactory };\n//# sourceMappingURL=component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/component.ngfactory.js\n// module id = null\n// module chunks = ","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { CalendarModule } from 'angular-calendar';\nimport { ContextMenuModule } from 'ngx-contextmenu';\nimport { DemoUtilsModule } from '../demo-utils/module';\nimport { DemoComponent } from './component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CalendarModule.forRoot(),\n    ContextMenuModule.forRoot({\n      useBootstrap4: true\n    }),\n    DemoUtilsModule,\n    RouterModule.forChild([{ path: '', component: DemoComponent }])\n  ],\n  declarations: [DemoComponent],\n  exports: [DemoComponent]\n})\nexport class DemoModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/module.ts","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, Optional, Output } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new InjectionToken('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar Directionality = /** @class */ (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new EventEmitter();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar Dir = /** @class */ (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new EventEmitter();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    Dir.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.change.complete();\n    };\n    Dir.decorators = [\n        { type: Directive, args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: Output, args: ['dirChange',] },],\n        \"dir\": [{ type: Input, args: ['dir',] },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar BidiModule = /** @class */ (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [Dir],\n                    declarations: [Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: DOCUMENT },\n                        Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Directionality, DIR_DOCUMENT, Dir, BidiModule };\n//# sourceMappingURL=bidi.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/bidi.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 91;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, PAGE_UP, PAGE_DOWN, HOME, END, ENTER, SPACE, TAB, ESCAPE, BACKSPACE, DELETE, A, Z, ZERO, NINE, COMMA };\n//# sourceMappingURL=keycodes.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n// module id = null\n// module chunks = ","import { InjectionToken } from '@angular/core';\nexport var CONTEXT_MENU_OPTIONS = new InjectionToken('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { ChangeDetectorRef, Component, ElementRef, Inject, Input, Optional, Renderer, ViewChild, ViewChildren, } from '@angular/core';\nimport { EventEmitter, Output, QueryList, HostListener } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nvar ARROW_LEFT_KEYCODE = 37;\nvar ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new EventEmitter();\n        this.openSubMenu = new EventEmitter();\n        this.closeLeafMenu = new EventEmitter();\n        this.closeAllMenus = new EventEmitter();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new QueryList();\n        queryList.reset(this.menuItems);\n        this._keyManager = new ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit();\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: Renderer, },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: Input },],\n        \"item\": [{ type: Input },],\n        \"event\": [{ type: Input },],\n        \"parentContextMenu\": [{ type: Input },],\n        \"overlay\": [{ type: Input },],\n        \"isLeaf\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n        \"openSubMenu\": [{ type: Output },],\n        \"closeLeafMenu\": [{ type: Output },],\n        \"closeAllMenus\": [{ type: Output },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n        \"menuItemElements\": [{ type: ViewChildren, args: ['li',] },],\n        \"onKeyEvent\": [{ type: HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: HostListener, args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: HostListener, args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: HostListener, args: ['document:click', ['$event'],] }, { type: HostListener, args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\nexport { ContextMenuContentComponent };\n//# sourceMappingURL=contextMenuContent.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\n// module id = null\n// module chunks = ","import { Directive, ElementRef, EventEmitter, Input, Output, TemplateRef } from '@angular/core';\nvar ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new EventEmitter();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ElementRef, },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: Input },],\n        \"divider\": [{ type: Input },],\n        \"enabled\": [{ type: Input },],\n        \"passive\": [{ type: Input },],\n        \"visible\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n    };\n    return ContextMenuItemDirective;\n}());\nexport { ContextMenuItemDirective };\n//# sourceMappingURL=contextMenu.item.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n// module id = null\n// module chunks = ","import { Overlay, ScrollStrategyOptions } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject();\n        this.triggerClose = new Subject();\n        this.close = new Subject();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: event.clientY,\n                    height: 0,\n                    left: event.clientX,\n                    right: event.clientX,\n                    top: event.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus();\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: anchorElement || this.fakeElement }, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new ComponentPortal(ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function () { return _this.closeAllContextMenus(); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function () {\n        if (this.overlays) {\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var exceptRootMenu = (_a === void 0 ? {} : _a).exceptRootMenu;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > (exceptRootMenu ? 1 : 0) && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\nexport { ContextMenuService };\n//# sourceMappingURL=contextMenu.service.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Optional, Output, QueryList, ViewChild, ViewEncapsulation, } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nvar ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new EventEmitter();\n        this.open = new EventEmitter();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) { return _this.onMenuEvent(menuEvent); }));\n        this.subscription.add(_contextMenuService.close.subscribe(function (event) { return _this.close.emit(event); }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(__assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this.open.next(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: Component, args: [{\n                    encapsulation: ViewEncapsulation.None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"autoFocus\": [{ type: Input },],\n        \"useBootstrap4\": [{ type: Input },],\n        \"disabled\": [{ type: Input },],\n        \"close\": [{ type: Output },],\n        \"open\": [{ type: Output },],\n        \"menuItems\": [{ type: ContentChildren, args: [ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\nexport { ContextMenuComponent };\n//# sourceMappingURL=contextMenu.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\n// module id = null\n// module chunks = ","import { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuService } from './contextMenu.service';\nimport { Directive, HostListener, Input } from '@angular/core';\nvar ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: Input },],\n        \"contextMenu\": [{ type: Input },],\n        \"onContextMenu\": [{ type: HostListener, args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\nexport { ContextMenuAttachDirective };\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n// module id = null\n// module chunks = ","import { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { CalendarEvent } from 'angular-calendar';\nimport { Subject } from 'rxjs/Subject';\nimport { colors } from '../demo-utils/colors';\n\n@Component({\n  selector: 'mwl-demo-component',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  templateUrl: 'template.html',\n  styles: [\n    `\n    .fill-height {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n      align-items: stretch;\n    }\n  `\n  ]\n})\nexport class DemoComponent {\n  view: string = 'month';\n\n  viewDate: Date = new Date();\n\n  events: CalendarEvent[] = [];\n\n  refresh: Subject<any> = new Subject();\n\n  addEvent(date: Date): void {\n    this.events.push({\n      start: date,\n      title: 'New event',\n      color: colors.red\n    });\n    this.refresh.next();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/component.ts","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { ContextMenuAttachDirective } from './contextMenu.attach.directive';\nimport { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuContentComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        CommonModule,\n                        OverlayModule,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\nexport { ContextMenuModule };\n//# sourceMappingURL=ngx-contextmenu.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./module\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive.ngfactory\";\nimport * as i3 from \"../../../node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory\";\nimport * as i4 from \"../../../node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory\";\nimport * as i5 from \"./component.ngfactory\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"@angular/cdk/bidi\";\nimport * as i8 from \"@angular/cdk/platform\";\nimport * as i9 from \"@angular/cdk/scrolling\";\nimport * as i10 from \"@angular/cdk/overlay\";\nimport * as i11 from \"@angular/forms\";\nimport * as i12 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar\";\nimport * as i13 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n\";\nimport * as i14 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter\";\nimport * as i15 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-adapter\";\nimport * as i16 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config\";\nimport * as i17 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config\";\nimport * as i18 from \"angular-draggable-droppable\";\nimport * as i19 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i20 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i21 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i22 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i23 from \"../../../src/modules/common/calendar-common.module\";\nimport * as i24 from \"../../../src/modules/month/calendar-month.module\";\nimport * as i25 from \"angular-resizable-element\";\nimport * as i26 from \"../../../src/modules/week/calendar-week.module\";\nimport * as i27 from \"../../../src/modules/day/calendar-day.module\";\nimport * as i28 from \"../../../src/modules/calendar.module\";\nimport * as i29 from \"@angular/cdk/portal\";\nimport * as i30 from \"ngx-contextmenu/lib/ngx-contextmenu\";\nimport * as i31 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module\";\nimport * as i32 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module\";\nimport * as i33 from \"../demo-utils/module\";\nimport * as i34 from \"@angular/router\";\nimport * as i35 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i36 from \"./component\";\nvar DemoModuleNgFactory = i0.ɵcmf(i1.DemoModule, [], function (_l) { return i0.ɵmod([i0.ɵmpd(512, i0.ComponentFactoryResolver, i0.ɵCodegenComponentFactoryResolver, [[8, [i2.CalendarTooltipWindowComponentNgFactory, i3.ContextMenuContentComponentNgFactory, i4.NgbDatepickerNgFactory, i5.DemoComponentNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.ɵmpd(4608, i6.NgLocalization, i6.NgLocaleLocalization, [i0.LOCALE_ID, [2, i6.ɵa]]), i0.ɵmpd(6144, i7.DIR_DOCUMENT, null, [i6.DOCUMENT]), i0.ɵmpd(4608, i7.Directionality, i7.Directionality, [[2, i7.DIR_DOCUMENT]]), i0.ɵmpd(4608, i8.Platform, i8.Platform, []), i0.ɵmpd(5120, i9.ScrollDispatcher, i9.SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, i9.ScrollDispatcher], i0.NgZone, i8.Platform]), i0.ɵmpd(5120, i9.ViewportRuler, i9.VIEWPORT_RULER_PROVIDER_FACTORY, [[3, i9.ViewportRuler], i8.Platform, i0.NgZone]), i0.ɵmpd(4608, i10.ScrollStrategyOptions, i10.ScrollStrategyOptions, [i9.ScrollDispatcher, i9.ViewportRuler, i0.NgZone]), i0.ɵmpd(5120, i10.OverlayContainer, i10.ɵa, [[3, i10.OverlayContainer], i6.DOCUMENT]), i0.ɵmpd(4608, i10.ɵh, i10.ɵh, [i9.ViewportRuler, i6.DOCUMENT]), i0.ɵmpd(5120, i10.OverlayKeyboardDispatcher, i10.ɵf, [[3, i10.OverlayKeyboardDispatcher], i6.DOCUMENT]), i0.ɵmpd(4608, i10.Overlay, i10.Overlay, [i10.ScrollStrategyOptions, i10.OverlayContainer, i0.ComponentFactoryResolver, i10.ɵh, i10.OverlayKeyboardDispatcher, i0.ApplicationRef, i0.Injector, i0.NgZone, i6.DOCUMENT]), i0.ɵmpd(5120, i10.ɵc, i10.ɵd, [i10.Overlay]), i0.ɵmpd(4608, i11.ɵi, i11.ɵi, []), i0.ɵmpd(4608, i12.NgbCalendar, i12.NgbCalendarGregorian, []), i0.ɵmpd(4608, i13.NgbDatepickerI18n, i13.NgbDatepickerI18nDefault, []), i0.ɵmpd(4608, i14.NgbDateParserFormatter, i14.NgbDateISOParserFormatter, []), i0.ɵmpd(4608, i15.NgbDateAdapter, i15.NgbDateStructAdapter, []), i0.ɵmpd(4608, i16.NgbDatepickerConfig, i16.NgbDatepickerConfig, []), i0.ɵmpd(4608, i17.NgbTimepickerConfig, i17.NgbTimepickerConfig, []), i0.ɵmpd(4608, i18.DraggableHelper, i18.DraggableHelper, []), i0.ɵmpd(4608, i19.CalendarEventTitleFormatter, i19.CalendarEventTitleFormatter, []), i0.ɵmpd(4608, i20.CalendarDateFormatter, i20.CalendarDateFormatter, []), i0.ɵmpd(4608, i21.CalendarUtils, i21.CalendarUtils, []), i0.ɵmpd(4608, i22.ContextMenuService, i22.ContextMenuService, [i10.Overlay, i10.ScrollStrategyOptions]), i0.ɵmpd(512, i6.CommonModule, i6.CommonModule, []), i0.ɵmpd(512, i23.CalendarCommonModule, i23.CalendarCommonModule, []), i0.ɵmpd(512, i18.DragAndDropModule, i18.DragAndDropModule, []), i0.ɵmpd(512, i24.CalendarMonthModule, i24.CalendarMonthModule, []), i0.ɵmpd(512, i25.ResizableModule, i25.ResizableModule, []), i0.ɵmpd(512, i26.CalendarWeekModule, i26.CalendarWeekModule, []), i0.ɵmpd(512, i27.CalendarDayModule, i27.CalendarDayModule, []), i0.ɵmpd(512, i28.CalendarModule, i28.CalendarModule, []), i0.ɵmpd(512, i7.BidiModule, i7.BidiModule, []), i0.ɵmpd(512, i29.PortalModule, i29.PortalModule, []), i0.ɵmpd(512, i8.PlatformModule, i8.PlatformModule, []), i0.ɵmpd(512, i9.ScrollDispatchModule, i9.ScrollDispatchModule, []), i0.ɵmpd(512, i10.OverlayModule, i10.OverlayModule, []), i0.ɵmpd(512, i30.ContextMenuModule, i30.ContextMenuModule, []), i0.ɵmpd(512, i11.ɵba, i11.ɵba, []), i0.ɵmpd(512, i11.FormsModule, i11.FormsModule, []), i0.ɵmpd(512, i31.NgbDatepickerModule, i31.NgbDatepickerModule, []), i0.ɵmpd(512, i32.NgbTimepickerModule, i32.NgbTimepickerModule, []), i0.ɵmpd(512, i33.DemoUtilsModule, i33.DemoUtilsModule, []), i0.ɵmpd(512, i34.RouterModule, i34.RouterModule, [[2, i34.ɵa], [2, i34.Router]]), i0.ɵmpd(512, i1.DemoModule, i1.DemoModule, []), i0.ɵmpd(256, i35.CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), i0.ɵmpd(1024, i34.ROUTES, function () { return [[{ path: \"\", component: i36.DemoComponent }]]; }, [])]); });\nexport { DemoModuleNgFactory as DemoModuleNgFactory };\n//# sourceMappingURL=module.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar audit_1 = require('./audit');\nvar timer_1 = require('../observable/timer');\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/auditTime.js\n// module id = 714\n// module chunks = 35","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/audit.js\n// module id = 715\n// module chunks = 35","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/timer.js\n// module id = 716\n// module chunks = 35","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/TimerObservable.js\n// module id = 717\n// module chunks = 35","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isDate.js\n// module id = 718\n// module chunks = 35","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounceTime.js\n// module id = 719\n// module chunks = 35"],"sourceRoot":""}