{"version":3,"sources":["webpack:///1-74d469d659b90d80f1e3.js","webpack:///./node_modules/@angular/cdk/esm5/platform.es5.js","webpack:///./node_modules/@angular/cdk/esm5/scrolling.es5.js","webpack:///./node_modules/@angular/cdk/esm5/portal.es5.js","webpack:///./node_modules/@angular/cdk/esm5/coercion.es5.js","webpack:///./node_modules/@angular/cdk/esm5/overlay.es5.js","webpack:///./node_modules/@angular/cdk/esm5/a11y.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/component.ngfactory.js","webpack:///./demos/demo-modules/context-menu/module.ts","webpack:///./node_modules/@angular/cdk/esm5/bidi.es5.js","webpack:///./node_modules/@angular/cdk/esm5/keycodes.es5.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.service.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.component.js","webpack:///./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js","webpack:///./demos/demo-modules/context-menu/component.ts","webpack:///./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js","webpack:///./demos/demo-modules/context-menu/module.ngfactory.js","webpack:///./node_modules/rxjs/util/isDate.js","webpack:///./node_modules/rxjs/observable/concat.js","webpack:///./node_modules/rxjs/operators/auditTime.js","webpack:///./node_modules/rxjs/operators/audit.js","webpack:///./node_modules/rxjs/operators/debounceTime.js","webpack:///./node_modules/rxjs/operators/combineLatest.js","webpack:///./node_modules/rxjs/operators/find.js","webpack:///./node_modules/rxjs/ReplaySubject.js","webpack:///./node_modules/rxjs/operators/zip.js","webpack:///./node_modules/rxjs/observable/timer.js","webpack:///./node_modules/rxjs/observable/TimerObservable.js","webpack:///./node_modules/rxjs/operators.js","webpack:///./node_modules/rxjs/operators/buffer.js","webpack:///./node_modules/rxjs/operators/bufferCount.js","webpack:///./node_modules/rxjs/operators/bufferTime.js","webpack:///./node_modules/rxjs/operators/bufferToggle.js","webpack:///./node_modules/rxjs/operators/bufferWhen.js","webpack:///./node_modules/rxjs/operators/combineAll.js","webpack:///./node_modules/rxjs/operators/concat.js","webpack:///./node_modules/rxjs/operators/concatMapTo.js","webpack:///./node_modules/rxjs/operators/count.js","webpack:///./node_modules/rxjs/operators/debounce.js","webpack:///./node_modules/rxjs/operators/delay.js","webpack:///./node_modules/rxjs/operators/delayWhen.js","webpack:///./node_modules/rxjs/operators/dematerialize.js","webpack:///./node_modules/rxjs/operators/distinct.js","webpack:///./node_modules/rxjs/util/Set.js","webpack:///./node_modules/rxjs/operators/distinctUntilKeyChanged.js","webpack:///./node_modules/rxjs/operators/elementAt.js","webpack:///./node_modules/rxjs/operators/exhaust.js","webpack:///./node_modules/rxjs/operators/exhaustMap.js","webpack:///./node_modules/rxjs/operators/expand.js","webpack:///./node_modules/rxjs/operators/finalize.js","webpack:///./node_modules/rxjs/operators/findIndex.js","webpack:///./node_modules/rxjs/operators/groupBy.js","webpack:///./node_modules/rxjs/util/Map.js","webpack:///./node_modules/rxjs/util/MapPolyfill.js","webpack:///./node_modules/rxjs/util/FastMap.js","webpack:///./node_modules/rxjs/operators/ignoreElements.js","webpack:///./node_modules/rxjs/operators/isEmpty.js","webpack:///./node_modules/rxjs/operators/mapTo.js","webpack:///./node_modules/rxjs/operators/materialize.js","webpack:///./node_modules/rxjs/operators/max.js","webpack:///./node_modules/rxjs/operators/merge.js","webpack:///./node_modules/rxjs/operators/mergeMapTo.js","webpack:///./node_modules/rxjs/operators/mergeScan.js","webpack:///./node_modules/rxjs/operators/min.js","webpack:///./node_modules/rxjs/operators/onErrorResumeNext.js","webpack:///./node_modules/rxjs/operators/partition.js","webpack:///./node_modules/rxjs/util/not.js","webpack:///./node_modules/rxjs/operators/pluck.js","webpack:///./node_modules/rxjs/operators/publish.js","webpack:///./node_modules/rxjs/operators/publishBehavior.js","webpack:///./node_modules/rxjs/operators/publishLast.js","webpack:///./node_modules/rxjs/AsyncSubject.js","webpack:///./node_modules/rxjs/operators/publishReplay.js","webpack:///./node_modules/rxjs/scheduler/queue.js","webpack:///./node_modules/rxjs/scheduler/QueueAction.js","webpack:///./node_modules/rxjs/scheduler/QueueScheduler.js","webpack:///./node_modules/rxjs/operators/race.js","webpack:///./node_modules/rxjs/observable/race.js","webpack:///./node_modules/rxjs/operators/repeat.js","webpack:///./node_modules/rxjs/operators/repeatWhen.js","webpack:///./node_modules/rxjs/operators/retry.js","webpack:///./node_modules/rxjs/operators/retryWhen.js","webpack:///./node_modules/rxjs/operators/sample.js","webpack:///./node_modules/rxjs/operators/sampleTime.js","webpack:///./node_modules/rxjs/operators/sequenceEqual.js","webpack:///./node_modules/rxjs/operators/shareReplay.js","webpack:///./node_modules/rxjs/operators/single.js","webpack:///./node_modules/rxjs/operators/skip.js","webpack:///./node_modules/rxjs/operators/skipLast.js","webpack:///./node_modules/rxjs/operators/skipUntil.js","webpack:///./node_modules/rxjs/operators/skipWhile.js","webpack:///./node_modules/rxjs/operators/startWith.js","webpack:///./node_modules/rxjs/operators/switchAll.js","webpack:///./node_modules/rxjs/operators/switchMapTo.js","webpack:///./node_modules/rxjs/operators/takeWhile.js","webpack:///./node_modules/rxjs/operators/throttleTime.js","webpack:///./node_modules/rxjs/operators/timeInterval.js","webpack:///./node_modules/rxjs/operators/timeout.js","webpack:///./node_modules/rxjs/util/TimeoutError.js","webpack:///./node_modules/rxjs/operators/timeoutWith.js","webpack:///./node_modules/rxjs/operators/timestamp.js","webpack:///./node_modules/rxjs/operators/toArray.js","webpack:///./node_modules/rxjs/operators/window.js","webpack:///./node_modules/rxjs/operators/windowCount.js","webpack:///./node_modules/rxjs/operators/windowTime.js","webpack:///./node_modules/rxjs/operators/windowToggle.js","webpack:///./node_modules/rxjs/operators/windowWhen.js","webpack:///./node_modules/rxjs/operators/withLatestFrom.js","webpack:///./node_modules/rxjs/operators/zipAll.js"],"names":["webpackJsonp","668","module","__webpack_exports__","__webpack_require__","supportsPassiveEventListeners","supportsPassiveEvents","window","addEventListener","Object","defineProperty","get","SCROLL_DISPATCHER_PROVIDER_FACTORY","parentDispatcher","ngZone","platform","scrolling_es5_ScrollDispatcher","VIEWPORT_RULER_PROVIDER_FACTORY","parentRuler","scrolling_es5_ViewportRuler","throwNullPortalError","Error","throwPortalAlreadyAttachedError","throwPortalOutletAlreadyDisposedError","throwUnknownPortalTypeError","throwNullPortalOutletError","throwNoPortalAttachedError","coerceBooleanProperty","value","getMatScrollStrategyAlreadyAttachedError","isElementScrolledOutsideView","element","scrollContainers","some","containerBounds","outsideAbove","bottom","top","outsideBelow","outsideLeft","right","left","outsideRight","isElementClippedByScrolling","scrollContainerRect","clippedAbove","clippedBelow","clippedLeft","clippedRight","formatCssUnit","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY","dispatcher","_document","overlay_es5_OverlayKeyboardDispatcher","OVERLAY_CONTAINER_PROVIDER_FACTORY","parentContainer","overlay_es5_OverlayContainer","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY","overlay","scrollStrategies","reposition","getFrameElement","e","hasGeometry","offsetWidth","offsetHeight","getClientRects","length","isNativeFormElement","nodeName","toLowerCase","isHiddenInput","isInputElement","type","isAnchorWithHref","isAnchorElement","hasAttribute","hasValidTabIndex","undefined","tabIndex","getAttribute","isNaN","parseInt","getTabIndexValue","isPotentiallyTabbableIOS","inputType","isPotentiallyFocusable","getWindow","node","ownerDocument","defaultView","addAriaReferencedId","el","attr","id","ids","getAriaReferenceIds","existingId","trim","push","setAttribute","join","ID_DELIMINATOR","removeAriaReferencedId","filteredIds","filter","val","match","ARIA_DESCRIBER_PROVIDER_FACTORY","a11y_es5_AriaDescriber","LIVE_ANNOUNCER_PROVIDER_FACTORY","liveElement","a11y_es5_LiveAnnouncer","FOCUS_MONITOR_PROVIDER_FACTORY","a11y_es5_FocusMonitor","View_ContextMenuContentComponent_3","_l","core","View_ContextMenuContentComponent_2","_v","en","$event","ad","_co","component","onMenuItemSelect","parent","context","$implicit","onOpenSubMenu","common","ngTemplateOutletContext","ngTemplateOutlet","_ck","item","template","useBootstrap4","isActive","isMenuItemEnabled","subMenu","View_ContextMenuContentComponent_5","View_ContextMenuContentComponent_4","stopEvent","View_ContextMenuContentComponent_1","ngIf","divider","passive","View_ContextMenuContentComponent_0","menuElement","menuItemElements","ngForOf","menuItems","View_ContextMenuContentComponent_Host_0","onKeyEvent","keyboardOpenSubMenu","keyboardMenuItemSelect","onCloseLeafMenu","closeMenu","RenderType_ContextMenuContentComponent","contextMenuContent_component_ContextMenuContentComponent","CONTEXT_MENU_OPTIONS","View_ContextMenuComponent_0","View_ContextMenuComponent_Host_0","RenderType_ContextMenuComponent","contextMenu_component_ContextMenuComponent","contextMenu_service_ContextMenuService","View_DemoComponent_1","View_DemoComponent_3","day","badgeTotal","View_DemoComponent_4","onMouseOver","onMouseOut","highlightDay","emit","event","unhighlightDay","stopPropagation","eventClicked","klass","ngClass","calendar_tooltip_directive","contents","placement","cssClass","title","tooltipPlacement","color","primary","View_DemoComponent_2","onContextMenu","contextMenu_attach_directive_ContextMenuAttachDirective","contextMenuSubject","contextMenu","date","events","locale","View_DemoComponent_6","dayHeaderClicked","isPast","isToday","isFuture","isWeekend","dragOver","View_DemoComponent_5","days","View_DemoComponent_7","segment","isStart","View_DemoComponent_8","calendar_month_view_component_ngfactory","calendar_month_view_component","calendar_utils_provider","viewDate","refresh","cellTemplate","View_DemoComponent_9","calendar_week_view_component_ngfactory","calendar_week_view_component","headerTemplate","View_DemoComponent_10","calendar_day_view_component_ngfactory","calendar_day_view_component","hourSegmentTemplate","View_DemoComponent_0","calendar_date_pipe","calendar_date_formatter_provider","calendar_event_title_pipe","calendar_event_title_formatter_provider","view","calendar_header_component_ngfactory","calendar_header_component","viewChange","viewDateChange","addEvent","contextMenu_item_directive_ContextMenuItemDirective","execute","ngSwitch","ngSwitchCase","View_DemoComponent_Host_0","RenderType_DemoComponent","component_DemoComponent","DemoModule","calendar_tooltip_directive_ngfactory","hasV8BreakIterator","v8BreakIterator","platform_es5_Platform","Platform","this","isBrowser","document","EDGE","test","navigator","userAgent","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","MSStream","FIREFOX","ANDROID","SAFARI","decorators","ctorParameters","platform_es5_PlatformModule","PlatformModule","args","providers","Subject","Observable","of","fromEvent","auditTime","merge","ScrollDispatcher","_ngZone","_platform","_scrolled","_globalSubscription","_scrolledCount","Map","prototype","register","scrollable","_this","scrollSubscription","elementScrolled","subscribe","next","set","deregister","scrollableReference","unsubscribe","delete","scrolled","auditTimeInMs","create","observer","_addGlobalListener","subscription","pipe","_removeGlobalListener","ngOnDestroy","forEach","_","container","ancestorScrolled","elementRef","ancestors","getAncestorScrollContainers","target","indexOf","scrollingContainers","_subscription","_scrollableContainsElement","nativeElement","scrollableElement","getElementRef","parentElement","runOutsideAngular","SCROLL_DISPATCHER_PROVIDER","provide","deps","useFactory","scrolling_es5_CdkScrollable","CdkScrollable","_elementRef","_scroll","_elementScrolled","_scrollListener","ngOnInit","removeEventListener","asObservable","selector","ViewportRuler","_change","_invalidateCache","change","_updateViewportSize","getViewportSize","_viewportSize","width","height","getViewportRect","scrollPosition","getViewportScrollPosition","_a","documentRect","documentElement","getBoundingClientRect","body","scrollTop","scrollY","scrollLeft","scrollX","throttleTime","innerWidth","innerHeight","VIEWPORT_RULER_PROVIDER","scrolling_es5_ScrollDispatchModule","ScrollDispatchModule","imports","exports","declarations","DIR_DOCUMENT","bidi_es5_Directionality","Directionality","bodyDir","dir","htmlDir","bidi_es5_Dir","Dir","_dir","_isInitialized","v","old","enumerable","configurable","ngAfterContentInit","complete","useExisting","host","[dir]","exportAs","propDecorators","bidi_es5_BidiModule","BidiModule","tslib_es6","Portal","attach","hasAttached","_attachedHost","detach","setAttachedHost","portal_es5_ComponentPortal","_super","ComponentPortal","viewContainerRef","injector","call","portal_es5_TemplatePortal","TemplatePortal","templateRef","BasePortalOutlet","_isDisposed","_attachedPortal","portal","attachComponentPortal","attachTemplatePortal","_invokeDisposeFn","dispose","setDisposeFn","fn","_disposeFn","portal_es5_DomPortalOutlet","DomPortalOutlet","outletElement","_componentFactoryResolver","_appRef","_defaultInjector","componentRef","componentFactory","resolveComponentFactory","createComponent","parentInjector","destroy","attachView","hostView","detachView","appendChild","_getComponentRootNode","viewContainer","viewRef","createEmbeddedView","detectChanges","rootNodes","rootNode","index","remove","parentNode","removeChild","portal_es5_CdkPortal","CdkPortal","portal_es5_CdkPortalOutlet","CdkPortalOutlet","_viewContainerRef","attached","_attachedRef","ref","clear","inputs","_deprecatedPortal","_deprecatedPortalHost","portal_es5_PortalModule","PortalModule","take","PortalInjector","_parentInjector","_customTokens","token","notFoundValue","Subscription","NoopScrollStrategy","enable","disable","OverlayConfig","config","scrollStrategy","panelClass","hasBackdrop","backdropClass","direction","keys","key","ConnectionPositionPair","origin","offsetX","offsetY","originX","originY","overlayX","overlayY","ScrollingVisibility","overlay_es5_ConnectedOverlayPositionChange","ConnectedOverlayPositionChange","connectionPair","scrollableViewProperties","CloseScrollStrategy","_scrollDispatcher","_viewportRuler","_config","_scrollSubscription","_detach","_overlayRef","run","overlayRef","stream","threshold","_initialScrollPosition","Math","abs","updatePosition","BlockScrollStrategy","_previousHTMLStyles","_isEnabled","_canBeEnabled","root","_previousScrollPosition","style","classList","add","html","previousHtmlScrollBehavior","previousBodyScrollBehavior","scroll","contains","viewport","scrollHeight","scrollWidth","RepositionScrollStrategy","throttle","scrollThrottle","autoClose","overlayRect","overlayElement","overlay_es5_ScrollStrategyOptions","ScrollStrategyOptions","noop","close","block","overlay_es5_OverlayRef","OverlayRef","_portalOutlet","_pane","_keyboardDispatcher","_backdropElement","_backdropClick","_attachments","_detachments","_keydownEvents","attachResult","positionStrategy","_updateStackingOrder","_updateElementSize","_updateElementDirection","onStable","_togglePointerEvents","_attachBackdrop","Array","isArray","cls","detachBackdrop","detachmentResult","isAttached","backdropClick","attachments","detachments","keydownEvents","getConfig","apply","updateSize","sizeConfig","setDirection","minWidth","minHeight","maxWidth","maxHeight","enablePointer","pointerEvents","createElement","insertBefore","requestAnimationFrame","nextSibling","backdropToDetach","finishDetach_1","setTimeout","overlay_es5_ConnectedPositionStrategy","ConnectedPositionStrategy","originPos","overlayPos","_connectedTo","_offsetX","_offsetY","scrollables","_resizeSubscription","EMPTY","_preferredPositions","_applied","_positionLocked","_onPositionChange","_origin","withFallbackPosition","_lastConnectedPosition","recalculateLastPosition","fallbackPoint","fallbackPosition","originRect","viewportSize","_i","pos","originPoint","_getOriginConnectionPoint","overlayPoint","_getOverlayPoint","fitsInViewport","_setElementPosition","visibleArea","lastPosition","withScrollableContainers","position","withDirection","withOffsetX","offset","withOffsetY","withLockedPosition","isLocked","withPositions","positions","slice","setOrigin","_getStartX","rect","_isRtl","_getEndX","x","originStartX","originEndX","y","overlayStartX","overlayStartY","leftOverflow","rightOverflow","topOverflow","bottomOverflow","visibleWidth","_subtractOverflows","visibleHeight","_getScrollVisibility","originBounds","overlayBounds","scrollContainerBounds","map","s","isOriginClipped","isOriginOutsideView","isOverlayClipped","isOverlayOutsideView","horizontalStyleProperty","verticalStyleProperty","clientHeight","clientWidth","p","positionChange","overflows","arguments","reduce","currentValue","currentOverflow","max","GlobalPositionStrategy","_cssPosition","_topOffset","_bottomOffset","_leftOffset","_rightOffset","_alignItems","_justifyContent","_width","_height","_wrapper","centerHorizontally","centerVertically","styles","parentStyles","marginTop","marginLeft","marginBottom","marginRight","justifyContent","alignItems","overlay_es5_OverlayPositionBuilder","OverlayPositionBuilder","global","connectedTo","OverlayKeyboardDispatcher","_attachedOverlays","_unsubscribeFromKeydownEvents","_keydownEventSubscription","_subscribeToKeydownEvents","splice","bodyKeydownEvents","_selectOverlayFromEvent","find","OVERLAY_KEYBOARD_DISPATCHER_PROVIDER","OverlayContainer","_containerElement","getContainerElement","_createContainer","OVERLAY_CONTAINER_PROVIDER","nextUniqueId","overlay_es5_Overlay","Overlay","_overlayContainer","_positionBuilder","_injector","pane","_createPaneElement","portalOutlet","_createPortalOutlet","defaultPositionList","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY","CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER","overlay_es5_CdkOverlayOrigin","CdkOverlayOrigin","overlay_es5_CdkConnectedOverlay","CdkConnectedOverlay","_overlay","_scrollStrategy","_hasBackdrop","_backdropSubscription","open","_templatePortal","_position","_positions","_minWidth","_minHeight","_backdropClass","_open","_destroyOverlay","ngOnChanges","changes","_attachOverlay","_detachOverlay","_createOverlay","_buildConfig","_createPositionStrategy","overlayConfig","primaryPosition","strategy","i","onPositionChange","keyCode","_deprecatedOrigin","_deprecatedPositions","_deprecatedOffsetX","_deprecatedOffsetY","_deprecatedWidth","_deprecatedHeight","_deprecatedMinWidth","_deprecatedMinHeight","_deprecatedBackdropClass","_deprecatedScrollStrategy","_deprecatedOpen","_deprecatedHasBackdrop","OVERLAY_PROVIDERS","overlay_es5_OverlayModule","OverlayModule","FullscreenOverlayContainer","_adjustParentForFullscreenChange","_addFullscreenChangeListener","getFullscreenElement","fullscreenEnabled","webkitFullscreenEnabled","mozFullScreenEnabled","msFullscreenEnabled","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","debounceTime","tap","a11y_es5_InteractivityChecker","InteractivityChecker","isDisabled","isVisible","getComputedStyle","visibility","isTabbable","frameElement","frameType","tabIndexValue","isFocusable","a11y_es5_FocusTrap","FocusTrap","_element","_checker","deferAnchors","_enabled","attachAnchors","_startAnchor","_endAnchor","_createAnchor","focusLastTabbableElement","focusFirstTabbableElement","focusInitialElementWhenReady","Promise","resolve","_executeOnStable","focusInitialElement","focusFirstTabbableElementWhenReady","focusLastTabbableElementWhenReady","_getRegionBoundary","bound","markers","querySelectorAll","console","warn","_getFirstTabbableElement","_getLastTabbableElement","redirectToElement","querySelector","focus","children","childNodes","tabbableChild","nodeType","ELEMENT_NODE","anchor","isStable","a11y_es5_FocusTrapFactory","FocusTrapFactory","deferCaptureElements","a11y_es5_FocusTrapDeprecatedDirective","FocusTrapDeprecatedDirective","_focusTrapFactory","focusTrap","enabled","disabled","a11y_es5_CdkTrapFocus","CdkTrapFocus","_previouslyFocusedElement","_autoCapture","autoCapture","nextId","messageRegistry","messagesContainer","AriaDescriber","describe","hostElement","message","has","_createMessageElement","_isElementDescribedByMessage","_addMessageReference","removeDescription","_removeMessageReference","registeredMessage","referenceCount","_deleteMessageElement","_deleteMessagesContainer","describedElements","_removeCdkDescribedByReferenceIds","removeAttribute","messageElement","CDK_DESCRIBEDBY_ID_PREFIX","createTextNode","_createMessagesContainer","display","originalReferenceIds","referenceIds","messageId","ARIA_DESCRIBER_PROVIDER","a11y_es5_ListKeyManager","ListKeyManager","_items","_activeItemIndex","_wrap","_letterKeyStream","_typeaheadSubscription","_vertical","_pressedLetters","tabOut","newItems","_activeItem","itemArray","toArray","newIndex","withWrap","withVerticalOrientation","withHorizontalOrientation","_horizontal","withTypeAhead","debounceInterval","getLabel","inputString","items","toUpperCase","setActiveItem","previousIndex","onKeydown","setNextItemActive","setPreviousItemActive","toLocaleUpperCase","String","fromCharCode","preventDefault","setFirstItemActive","_setActiveItemByIndex","setLastItemActive","_setActiveItemByDelta","updateActiveItemIndex","delta","_setActiveInWrapMode","_setActiveInDefaultMode","fallbackDelta","a11y_es5_ActiveDescendantKeyManager","ActiveDescendantKeyManager","activeItem","setInactiveStyles","setActiveStyles","LIVE_ANNOUNCER_ELEMENT_TOKEN","FocusKeyManager","setFocusOrigin","LiveAnnouncer","elementToken","_liveElement","_createLiveElement","announce","politeness","textContent","liveEl","LIVE_ANNOUNCER_PROVIDER","FocusMonitor","_windowFocused","_elementInfo","_unregisterGlobalListeners","_monitoredElementCount","monitor","renderer","checkChildren","cachedInfo","subject","info","unlisten","_incrementMonitoredElementCount","focusListener","_onFocus","blurListener","_onBlur","stopMonitoring","elementInfo","_setClasses","_decrementMonitoredElementCount","focusVia","_setOriginForCurrentEventQueue","_info","_registerGlobalListeners","documentKeydownListener","_lastTouchTarget","documentMousedownListener","documentTouchstartListener","_touchTimeoutId","clearTimeout","windowFocusListener","_windowFocusTimeoutId","capture","_originTimeoutId","_toggleClass","className","shouldSet","_wasCausedByTouch","focusTarget","Node","_lastFocusOrigin","relatedTarget","a11y_es5_CdkMonitorFocus","CdkMonitorFocus","_focusMonitor","cdkFocusChange","_monitorSubscription","FOCUS_MONITOR_PROVIDER","__assign","A11yModule","assign","t","n","hasOwnProperty","ContextMenuContentComponent","changeDetector","options","isLeaf","openSubMenu","closeLeafMenu","closeAllMenus","autoFocus","menuItem","currentItem","queryList","reset","_keyManager","ngAfterViewInit","evaluateIfFunction","isMenuItemVisible","visible","Function","link","cancelEvent","activeItemIndex","exceptRootMenu","button","anchorElementRef","anchorElement","parentContextMenu","triggerExecute","tagName","isContentEditable","styles_ContextMenuContentComponent","encapsulation","data","ContextMenuContentComponentNgFactory","datepicker_ngfactory","operators","ContextMenuItemDirective","contextMenu_service___assign","ContextMenuService","isDestroyingLeafMenu","show","triggerClose","overlays","fakeElement","openContextMenu","newOverlay","destroySubMenus","concat","attachContextMenu","mouseEvent_1","clientY","clientX","closeAllContextMenus","eventType","contextMenuContent","instance","subscriptions","executeEvent","closeAllEvent","closeLeafMenuEvent","destroyLeafMenu","subMenuEvent","onDestroy","closeEvent","getLastAttachedOverlay","_b","newLeaf","subMenuOverlay","isLeafMenu","contextMenu_component___assign","ContextMenuComponent","_contextMenuService","visibleMenuItems","links","menuEvent","onMenuEvent","setVisibleMenuItems","None","ContextMenuAttachDirective","contextMenuService","styles_ContextMenuComponent","colors","DemoComponent","Date","start","red","styles_DemoComponent","DemoComponentNgFactory","esm5_forms","ngb_calendar","datepicker_i18n","ngb_date_parser_formatter","ngb_date_adapter","datepicker_config","timepicker_config","angular_draggable_droppable","calendar_common_module","calendar_month_module","angular_resizable_element","calendar_week_module","calendar_day_module","calendar_module","ngx_contextmenu_ContextMenuModule","ContextMenuModule","forRoot","ngModule","useValue","entryComponents","datepicker_module","timepicker_module","demo_utils_module","router","d","DemoModuleNgFactory","path","710","isDate","712","observables","isScheduler_1","isScheduler","from_1","from","concatAll_1","concatAll","of_1","713","duration","scheduler","async_1","async","audit_1","audit","timer_1","timer","714","durationSelector","source","lift","AuditOperator","__extends","b","__","constructor","tryCatch_1","errorObject_1","OuterSubscriber_1","subscribeToResult_1","subscriber","AuditSubscriber","destination","hasValue","_next","throttled","tryCatch","errorObject","error","innerSubscription","subscribeToResult","closed","clearThrottle","notifyNext","outerValue","innerValue","outerIndex","innerIndex","notifyComplete","OuterSubscriber","715","dueTime","DebounceTimeOperator","dispatchNext","debouncedNext","Subscriber_1","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","schedule","_complete","Subscriber","716","combineLatest","project","pop","isArray_1","ArrayObservable_1","ArrayObservable","CombineLatestOperator","none","CombineLatestSubscriber","active","values","observable","len","toRespond","unused","innerSub","oldVal","_tryProject","result","err","717","predicate","thisArg","TypeError","FindValueOperator","yieldIndex","FindValueSubscriber","718","Subject_1","queue_1","Subscription_1","observeOn_1","ObjectUnsubscribedError_1","SubjectSubscription_1","ReplaySubject","bufferSize","windowTime","Number","POSITIVE_INFINITY","_events","_bufferSize","_windowTime","now","_getNow","ReplayEvent","_trimBufferThenGetEvents","_subscribe","ObjectUnsubscribedError","hasError","isStopped","observers","SubjectSubscription","ObserveOnSubscriber","thrownError","queue","eventsCount","spliceCount","time","719","zip","zipStatic","ZipOperator","iterator_1","ZipSubscriber","iterators","StaticArrayIterator","iterator","StaticIterator","ZipBufferIterator","stillUnsubscribed","notifyInactive","checkIterators","shouldComplete","hasCompleted","done","nextResult","array","buffer","isComplete","shift","723","TimerObservable_1","TimerObservable","724","isNumeric_1","Observable_1","isDate_1","period","isNumeric","initialDelay","dispatch","state","action","725","auditTime_1","buffer_1","bufferCount_1","bufferCount","bufferTime_1","bufferTime","bufferToggle_1","bufferToggle","bufferWhen_1","bufferWhen","catchError_1","catchError","combineAll_1","combineAll","combineLatest_1","concat_1","concatMap_1","concatMap","concatMapTo_1","concatMapTo","count_1","count","debounce_1","debounce","debounceTime_1","defaultIfEmpty_1","defaultIfEmpty","delay_1","delay","delayWhen_1","delayWhen","dematerialize_1","dematerialize","distinct_1","distinct","distinctUntilChanged_1","distinctUntilChanged","distinctUntilKeyChanged_1","distinctUntilKeyChanged","elementAt_1","elementAt","every_1","every","exhaust_1","exhaust","exhaustMap_1","exhaustMap","expand_1","expand","filter_1","finalize_1","finalize","find_1","findIndex_1","findIndex","first_1","first","groupBy_1","groupBy","ignoreElements_1","ignoreElements","isEmpty_1","isEmpty","last_1","last","map_1","mapTo_1","mapTo","materialize_1","materialize","max_1","merge_1","mergeAll_1","mergeAll","mergeMap_1","mergeMap","mergeMap_2","flatMap","mergeMapTo_1","mergeMapTo","mergeScan_1","mergeScan","min_1","min","multicast_1","multicast","observeOn","onErrorResumeNext_1","onErrorResumeNext","pairwise_1","pairwise","partition_1","partition","pluck_1","pluck","publish_1","publish","publishBehavior_1","publishBehavior","publishLast_1","publishLast","publishReplay_1","publishReplay","race_1","race","reduce_1","repeat_1","repeat","repeatWhen_1","repeatWhen","retry_1","retry","retryWhen_1","retryWhen","refCount_1","refCount","sample_1","sample","sampleTime_1","sampleTime","scan_1","scan","sequenceEqual_1","sequenceEqual","share_1","share","shareReplay_1","shareReplay","single_1","single","skip_1","skip","skipLast_1","skipLast","skipUntil_1","skipUntil","skipWhile_1","skipWhile","startWith_1","startWith","switchAll_1","switchAll","switchMap_1","switchMap","switchMapTo_1","switchMapTo","take_1","takeLast_1","takeLast","takeUntil_1","takeUntil","takeWhile_1","takeWhile","tap_1","throttle_1","throttleTime_1","timeInterval_1","timeInterval","timeout_1","timeout","timeoutWith_1","timeoutWith","timestamp_1","timestamp","toArray_1","window_1","windowCount_1","windowCount","windowTime_1","windowToggle_1","windowToggle","windowWhen_1","windowWhen","withLatestFrom_1","withLatestFrom","zip_1","zipAll_1","zipAll","726","closingNotifier","BufferOperator","BufferSubscriber","727","startBufferEvery","BufferCountOperator","subscriberClass","BufferSkipCountSubscriber","BufferCountSubscriber","buffers","728","bufferTimeSpan","bufferCreationInterval","maxBufferSize","BufferTimeOperator","dispatchBufferTimeSpanOnly","prevContext","closeContext","openContext","closeAction","dispatchBufferCreation","dispatchBufferClose","arg","BufferTimeSubscriber","Context","contexts","timespanOnly","timeSpanOnlyState","closeState","creationState","filledBufferContext","onBufferFull","_error","_unsubscribe","729","openings","closingSelector","BufferToggleOperator","BufferToggleSubscriber","closeBuffer","openBuffer","trySubscribe","730","BufferWhenOperator","BufferWhenSubscriber","subscribing","closingSubscription","731","732","concat_2","concatStatic","733","innerObservable","resultSelector","734","CountOperator","CountSubscriber","_tryPredicate","735","DebounceOperator","DebounceSubscriber","durationSubscription","_tryNext","emitValue","736","absoluteDelay","delayFor","DelayOperator","Notification_1","DelaySubscriber","errored","notification","observe","_schedule","scheduleNotification","DelayMessage","Notification","createNext","createComplete","737","delayDurationSelector","subscriptionDelay","SubscriptionDelayObservable","DelayWhenOperator","DelayWhenSubscriber","completed","delayNotifierSubscriptions","removeSubscription","tryComplete","notifyError","delayNotifier","tryDelay","subscriptionIdx","notifierSubscription","SubscriptionDelaySubscriber","sourceSubscribed","subscribeToSource","738","DeMaterializeOperator","DeMaterializeSubscriber","739","keySelector","flushes","DistinctOperator","Set_1","DistinctSubscriber","Set","_useKeySelector","_finalizeNext","740","minimalSetImpl","MinimalSet","_values","root_1","741","compare","742","defaultValue","ElementAtOperator","ArgumentOutOfRangeError_1","ArgumentOutOfRangeError","ElementAtSubscriber","743","SwitchFirstOperator","SwitchFirstSubscriber","hasSubscription","744","SwitchFirstMapOperator","SwitchFirstMapSubscriber","tryNext","trySelectResult","745","concurrent","ExpandOperator","ExpandSubscriber","subscribeToProjection","746","callback","FinallyOperator","FinallySubscriber","747","748","elementSelector","subjectSelector","GroupByOperator","Map_1","FastMap_1","GroupBySubscriber","groups","attemptedToUnsubscribe","_group","FastMap","group","groupedObservable","GroupedObservable","GroupDurationSubscriber","removeGroup","groupSubject","refCountSubscription","InnerRefCountSubscription","749","MapPolyfill_1","MapPolyfill","750","size","_keys","cb","751","752","IgnoreElementsOperator","noop_1","IgnoreElementsSubscriber","753","IsEmptyOperator","IsEmptySubscriber","754","MapToOperator","MapToSubscriber","755","MaterializeOperator","MaterializeSubscriber","createError","756","comparer","757","merge_2","mergeStatic","758","MergeMapToOperator","ish","MergeMapToSubscriber","_innerSub","759","accumulator","seed","MergeScanOperator","MergeScanSubscriber","acc","760","761","nextSources","OnErrorResumeNextOperator","onErrorResumeNextStatic","FromObservable_1","FromObservable","OnErrorResumeNextSubscriber","subscribeToNextSource","762","not_1","not","763","pred","notPred","764","properties","plucker","props","currentProp","765","766","BehaviorSubject_1","BehaviorSubject","767","AsyncSubject_1","AsyncSubject","768","hasNext","769","selectorOrScheduler","ReplaySubject_1","770","QueueAction_1","QueueScheduler_1","QueueScheduler","QueueAction","771","AsyncAction_1","work","flush","_execute","requestAsyncId","AsyncAction","772","AsyncScheduler_1","AsyncScheduler","773","774","RaceOperator","RaceSubscriber","hasFirst","775","EmptyObservable_1","EmptyObservable","RepeatOperator","RepeatSubscriber","_unsubscribeAndRecycle","776","notifier","RepeatWhenOperator","RepeatWhenSubscriber","sourceIsBeingSubscribedTo","retries","retriesSubscription","subscribeToRetries","notifications","777","RetryOperator","RetrySubscriber","778","RetryWhenOperator","RetryWhenSubscriber","errors","779","SampleOperator","sampleSubscriber","SampleSubscriber","780","SampleTimeOperator","dispatchNotification","SampleTimeSubscriber","781","compareTo","comparor","SequenceEqualOperator","SequenceEqualSubscriber","_oneComplete","SequenceEqualCompareToSubscriber","checkValues","_c","a","areEqual","nextB","782","shareReplayOperator","783","SingleOperator","EmptyError_1","SingleSubscriber","seenValue","applySingleValue","singleValue","EmptyError","784","SkipOperator","total","SkipSubscriber","785","SkipLastOperator","_skipCount","SkipLastSubscriber","_count","_ring","skipCount","currentIndex","ring","oldValue","786","SkipUntilOperator","SkipUntilSubscriber","isInnerStopped","787","SkipWhileOperator","SkipWhileSubscriber","skipping","tryCallPredicate","Boolean","788","ScalarObservable_1","ScalarObservable","789","identity_1","identity","790","SwitchMapToOperator","SwitchMapToSubscriber","inner","tryResultSelector","791","TakeWhileOperator","TakeWhileSubscriber","nextOrComplete","predicateResult","792","defaultThrottleConfig","ThrottleTimeOperator","leading","trailing","ThrottleTimeSubscriber","_hasTrailingValue","_trailingValue","793","TimeIntervalOperator","TimeInterval","interval","TimeIntervalSubscriber","lastTime","span","794","due","absoluteTimeout","waitFor","TimeoutOperator","TimeoutError_1","TimeoutError","errorInstance","TimeoutSubscriber","scheduleTimeout","dispatchTimeout","795","name","stack","796","withObservable","TimeoutWithOperator","TimeoutWithSubscriber","797","Timestamp","798","toArrayReducer","arr","799","windowBoundaries","WindowOperator","windowSubscriber","WindowSubscriber","sourceSubscription","openWindow","prevWindow","newWindow","800","windowSize","startWindowEvery","WindowCountOperator","WindowCountSubscriber","windows","c","801","windowTimeSpan","windowCreationInterval","maxWindowSize","WindowTimeOperator","dispatchWindowTimeSpanOnly","closeWindow","dispatchWindowCreation","timeSpanState","dispatchWindowClose","WindowTimeSubscriber","CountedSubject","_numberOfNextedValues","numberOfNextedValues","window_2","802","WindowToggleOperator","WindowToggleSubscriber","openSubscription","803","unsubscribeClosingNotification","closingNotification","804","WithLatestFromOperator","WithLatestFromSubscriber","found","805"],"mappings":"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","file":"1-74d469d659b90d80f1e3.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 668:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/esm5/core.js\nvar core = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ts\nvar DemoModule = /** @class */ (function () {\n    function DemoModule() {\n    }\n    return DemoModule;\n}());\n\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ngfactory.js\nvar calendar_tooltip_directive_ngfactory = __webpack_require__(294);\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/esm5/common.js\nvar common = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/platform.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar platform_es5_Platform = /** @class */ (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser &&\n            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of `<input>` that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar platform_es5_PlatformModule = /** @class */ (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    providers: [platform_es5_Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=platform.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subject.js\nvar Subject = __webpack_require__(29);\nvar Subject_default = /*#__PURE__*/__webpack_require__.n(Subject);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Observable.js\nvar Observable = __webpack_require__(11);\nvar Observable_default = /*#__PURE__*/__webpack_require__.n(Observable);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/of.js\nvar of = __webpack_require__(302);\nvar of_default = /*#__PURE__*/__webpack_require__.n(of);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/fromEvent.js\nvar fromEvent = __webpack_require__(313);\nvar fromEvent_default = /*#__PURE__*/__webpack_require__.n(fromEvent);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/auditTime.js\nvar auditTime = __webpack_require__(713);\nvar auditTime_default = /*#__PURE__*/__webpack_require__.n(auditTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/filter.js\nvar filter = __webpack_require__(94);\nvar filter_default = /*#__PURE__*/__webpack_require__.n(filter);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/observable/merge.js\nvar merge = __webpack_require__(131);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar scrolling_es5_ScrollDispatcher = /** @class */ (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject[\"Subject\"]();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable[\"Observable\"].create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(Object(auditTime[\"auditTime\"])(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (!_this._scrolledCount) {\n                    _this._removeGlobalListener();\n                }\n            };\n        }) : Object(of[\"of\"])();\n    };\n    /**\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._removeGlobalListener();\n        this.scrollContainers.forEach(function (_, container) { return _this.deregister(container); });\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(Object(filter[\"filter\"])(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return Object(fromEvent[\"fromEvent\"])(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    /**\n     * Cleans up the global scroll listener.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._removeGlobalListener = /**\n     * Cleans up the global scroll listener.\n     * @return {?}\n     */\n    function () {\n        if (this._globalSubscription) {\n            this._globalSubscription.unsubscribe();\n            this._globalSubscription = null;\n        }\n    };\n    ScrollDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new scrolling_es5_ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ScrollDispatcher,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar scrolling_es5_CdkScrollable = /** @class */ (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._elementScrolled = new Subject[\"Subject\"]();\n        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar scrolling_es5_ViewportRuler = /** @class */ (function () {\n    function ViewportRuler(platform, ngZone) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return Object(merge[\"merge\"])(Object(fromEvent[\"fromEvent\"])(window, 'resize'), Object(fromEvent[\"fromEvent\"])(window, 'orientationchange'));\n        }) : Object(of[\"of\"])();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        return { width: this._viewportSize.width, height: this._viewportSize.height };\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(Object(auditTime[\"auditTime\"])(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    ViewportRuler.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n        { type: core[\"J\" /* NgZone */], },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new scrolling_es5_ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: scrolling_es5_ViewportRuler,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */]],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar scrolling_es5_ScrollDispatchModule = /** @class */ (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [platform_es5_PlatformModule],\n                    exports: [scrolling_es5_CdkScrollable],\n                    declarations: [scrolling_es5_CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=scrolling.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/bidi.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new core[\"y\" /* InjectionToken */]('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar bidi_es5_Directionality = /** @class */ (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar bidi_es5_Dir = /** @class */ (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new core[\"s\" /* EventEmitter */]();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    Dir.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.change.complete();\n    };\n    Dir.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: bidi_es5_Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: core[\"L\" /* Output */], args: ['dirChange',] },],\n        \"dir\": [{ type: core[\"A\" /* Input */] },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar bidi_es5_BidiModule = /** @class */ (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [bidi_es5_Dir],\n                    declarations: [bidi_es5_Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: common[\"d\" /* DOCUMENT */] },\n                        bidi_es5_Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=bidi.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(45);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/portal.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface that can be used to generically type a class.\n * @record\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n */\nvar Portal = /** @class */ (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar portal_es5_ComponentPortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar portal_es5_TemplatePortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        _this.context = context;\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = /** @class */ (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof portal_es5_ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof portal_es5_TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar portal_es5_DomPortalOutlet = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(DomPortalOutlet, _super);\n    function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this.outletElement = outletElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this.outletElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this.outletElement.parentNode != null) {\n            this.outletElement.parentNode.removeChild(this.outletElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar portal_es5_CdkPortal = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    return CdkPortal;\n}(portal_es5_TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nvar portal_es5_CdkPortalOutlet = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Whether the portal component is initialized.\n         */\n        _this._isInitialized = false;\n        _this.attached = new core[\"s\" /* EventEmitter */]();\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._attachedPortal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._attachedPortal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"attachedRef\", {\n        /** Component or view reference that is attached to the portal. */\n        get: /**\n         * Component or view reference that is attached to the portal.\n         * @return {?}\n         */\n        function () {\n            return this._attachedRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._attachedPortal = null;\n        this._attachedRef = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._attachedPortal = portal;\n        this._attachedRef = ref;\n        this.attached.emit(ref);\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._attachedPortal = portal;\n        this._attachedRef = viewRef;\n        this.attached.emit(viewRef);\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: core[\"A\" /* Input */], args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: core[\"A\" /* Input */], args: ['cdkPortalHost',] },],\n        \"attached\": [{ type: core[\"L\" /* Output */], args: ['attached',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar portal_es5_PortalModule = /** @class */ (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    exports: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                    declarations: [portal_es5_CdkPortal, portal_es5_CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = /** @class */ (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=portal.es5.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/take.js\nvar take = __webpack_require__(132);\nvar take_default = /*#__PURE__*/__webpack_require__.n(take);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/Subscription.js\nvar Subscription = __webpack_require__(44);\nvar Subscription_default = /*#__PURE__*/__webpack_require__.n(Subscription);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/coercion.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * \\@docs-private\n * @param {?} value\n * @return {?}\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(/** @type {?} */ (value))) && !isNaN(Number(value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=coercion.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 57;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=keycodes.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/overlay.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = /** @class */ (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = /** @class */ (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config)\n                .filter(function (key) { return typeof config[key] !== 'undefined'; })\n                .forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = /** @class */ (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = /** @class */ (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar overlay_es5_ConnectedOverlayPositionChange = /** @class */ (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the CloseScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = /** @class */ (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /**\n         * Detaches the overlay ref and disables the scroll strategy.\n         */\n        this._detach = function () {\n            _this.disable();\n            if (_this._overlayRef.hasAttached()) {\n                _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached overlay on scroll. */\n    /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._scrollSubscription) {\n            return;\n        }\n        var /** @type {?} */ stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(function () {\n                var /** @type {?} */ scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - _this._initialScrollPosition) > /** @type {?} */ ((/** @type {?} */ ((_this._config)).threshold))) {\n                    _this._detach();\n                }\n                else {\n                    _this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = /** @class */ (function () {\n    function BlockScrollStrategy(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = this._document.documentElement;\n            var /** @type {?} */ body = this._document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        var /** @type {?} */ html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = this._document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = /** @class */ (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (_this._config && _this._config.autoClose) {\n                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        _this.disable();\n                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                    }\n                }\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar overlay_es5_ScrollStrategyOptions = /** @class */ (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = function (config) {\n            return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config);\n        };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n        this._document = document;\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: scrolling_es5_ScrollDispatcher, },\n        { type: scrolling_es5_ViewportRuler, },\n        { type: core[\"J\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar overlay_es5_OverlayRef = /** @class */ (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher, _document) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._backdropElement = null;\n        this._backdropClick = new Subject[\"Subject\"]();\n        this._attachments = new Subject[\"Subject\"]();\n        this._detachments = new Subject[\"Subject\"]();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject[\"Subject\"]();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OverlayRef.prototype, \"backdropElement\", {\n        /** The overlay's backdrop HTML element. */\n        get: /**\n         * The overlay's backdrop HTML element.\n         * @return {?}\n         */\n        function () {\n            return this._backdropElement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(Object(take[\"take\"])(1)).subscribe(function () {\n            // The overlay could've been detached before the zone has stabilized.\n            if (_this.hasAttached()) {\n                _this.updatePosition();\n            }\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    function (sizeConfig) {\n        this._config = Object(tslib_es6[\"a\" /* __assign */])({}, this._config, sizeConfig);\n        this._updateElementSize();\n    };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    function (dir) {\n        this._config = Object(tslib_es6[\"a\" /* __assign */])({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function (event) { return _this._backdropClick.next(event); });\n        // Add class to fade-in the backdrop after one frame.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                requestAnimationFrame(function () {\n                    if (_this._backdropElement) {\n                        _this._backdropElement.classList.add(showingClass);\n                    }\n                });\n            });\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar overlay_es5_ConnectedPositionStrategy = /** @class */ (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription[\"Subscription\"].EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject[\"Subject\"]();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n        this._onPositionChange.complete();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the  old position, in order to\n        // prevent the overlay from jumping around.\n        if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n            this.recalculateLastPosition();\n            return;\n        }\n        this._applied = true;\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    function (isLocked) {\n        this._positionLocked = isLocked;\n        return this;\n    };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    function (positions) {\n        this._preferredPositions = positions.slice();\n        return this;\n    };\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param origin Reference to the new origin element.\n     */\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.setOrigin = /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin.nativeElement;\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new overlay_es5_ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = /** @class */ (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        /**\n         * A lazily-created wrapper for the overlay element that is used as a flex container.\n         */\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef.hasAttached()) {\n            return;\n        }\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = this._document.createElement('div'); /** @type {?} */\n            ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n            ((this._wrapper)).appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar overlay_es5_OverlayPositionBuilder = /** @class */ (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy(this._document);\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new overlay_es5_ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: scrolling_es5_ViewportRuler, },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar overlay_es5_OverlayKeyboardDispatcher = /** @class */ (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._unsubscribeFromKeydownEvents();\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._unsubscribeFromKeydownEvents();\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = Object(fromEvent[\"fromEvent\"])(this._document.body, 'keydown', true);\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(Object(filter[\"filter\"])(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to the correct overlay.\n            // Dispatch keydown event to the correct overlay.\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use the overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new overlay_es5_OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: overlay_es5_OverlayKeyboardDispatcher,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        common[\"d\" /* DOCUMENT */])\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar overlay_es5_OverlayContainer = /** @class */ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = this._document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new overlay_es5_OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: overlay_es5_OverlayContainer,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), overlay_es5_OverlayContainer],\n        /** @type {?} */ (common[\"d\" /* DOCUMENT */] // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar overlay_es5_Overlay = /** @class */ (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new overlay_es5_OverlayRef(portalOutlet, pane, new OverlayConfig(config), this._ngZone, this._keyboardDispatcher, this._document);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = this._document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new portal_es5_DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: overlay_es5_ScrollStrategyOptions, },\n        { type: overlay_es5_OverlayContainer, },\n        { type: core[\"m\" /* ComponentFactoryResolver */], },\n        { type: overlay_es5_OverlayPositionBuilder, },\n        { type: overlay_es5_OverlayKeyboardDispatcher, },\n        { type: core[\"g\" /* ApplicationRef */], },\n        { type: core[\"z\" /* Injector */], },\n        { type: core[\"J\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new core[\"y\" /* InjectionToken */]('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [overlay_es5_Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkOverlayOrigin = /** @class */ (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar overlay_es5_CdkConnectedOverlay = /** @class */ (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new core[\"s\" /* EventEmitter */]();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new core[\"s\" /* EventEmitter */]();\n        this._templatePortal = new portal_es5_TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (this._position) {\n            if (changes['positions'] || changes['_deprecatedPositions']) {\n                this._position.withPositions(this.positions);\n            }\n            if (changes['origin'] || changes['_deprecatedOrigin']) {\n                this._position.setOrigin(this.origin.elementRef);\n                if (this.open) {\n                    this._position.apply();\n                }\n            }\n        }\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ primaryPosition = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: primaryPosition.originX, originY: primaryPosition.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: primaryPosition.overlayX, overlayY: primaryPosition.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n        return strategy;\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay(); /** @type {?} */\n            ((this._overlayRef)).keydownEvents().subscribe(function (event) {\n                if (event.keyCode === ESCAPE) {\n                    _this._detachOverlay();\n                }\n            });\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.setDirection(this.dir);\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"_6\" /* ViewContainerRef */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: bidi_es5_Directionality, decorators: [{ type: core[\"K\" /* Optional */] },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: core[\"A\" /* Input */], args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"_deprecatedOrigin\": [{ type: core[\"A\" /* Input */], args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: core[\"A\" /* Input */], args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: core[\"A\" /* Input */], args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: core[\"A\" /* Input */], args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: core[\"A\" /* Input */], args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: core[\"A\" /* Input */], args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: core[\"A\" /* Input */], args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: core[\"A\" /* Input */], args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: core[\"A\" /* Input */], args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: core[\"A\" /* Input */], args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: core[\"A\" /* Input */], args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: core[\"A\" /* Input */], args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: core[\"L\" /* Output */] },],\n        \"positionChange\": [{ type: core[\"L\" /* Output */] },],\n        \"attach\": [{ type: core[\"L\" /* Output */] },],\n        \"detach\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    overlay_es5_Overlay,\n    overlay_es5_OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar overlay_es5_OverlayModule = /** @class */ (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [bidi_es5_BidiModule, portal_es5_PortalModule, scrolling_es5_ScrollDispatchModule],\n                    exports: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin, scrolling_es5_ScrollDispatchModule],\n                    declarations: [overlay_es5_CdkConnectedOverlay, overlay_es5_CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, overlay_es5_ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar overlay_es5_FullscreenOverlayContainer = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(overlay_es5_OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=overlay.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n\nvar CONTEXT_MENU_OPTIONS = new core[\"y\" /* InjectionToken */]('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/debounceTime.js\nvar debounceTime = __webpack_require__(715);\nvar debounceTime_default = /*#__PURE__*/__webpack_require__.n(debounceTime);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/map.js\nvar map = __webpack_require__(93);\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators/tap.js\nvar tap = __webpack_require__(311);\nvar tap_default = /*#__PURE__*/__webpack_require__.n(tap);\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/esm5/a11y.es5.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar a11y_es5_InteractivityChecker = /** @class */ (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server 😎\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: platform_es5_Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n * @param {?} window\n * @return {?}\n */\nfunction getFrameElement(window) {\n    try {\n        return /** @type {?} */ (window.frameElement);\n    }\n    catch (/** @type {?} */ e) {\n        return null;\n    }\n}\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an `<input type=\"hidden\">`.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar a11y_es5_FocusTrap = /** @class */ (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(Object(take[\"take\"])(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar a11y_es5_FocusTrapFactory = /** @class */ (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new a11y_es5_FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: a11y_es5_InteractivityChecker, },\n        { type: core[\"J\" /* NgZone */], },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n * \\@deletion-target 6.0.0\n */\nvar a11y_es5_FocusTrapDeprecatedDirective = /** @class */ (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: core[\"A\" /* Input */] },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar a11y_es5_CdkTrapFocus = /** @class */ (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: core[\"A\" /* Input */], args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: core[\"A\" /* Input */], args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar a11y_es5_AriaDescriber = /** @class */ (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (hostElement.nodeType !== this._document.ELEMENT_NODE || !message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (hostElement.nodeType !== this._document.ELEMENT_NODE || !message.trim()) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        if (!messagesContainer) {\n            this._createMessagesContainer();\n        } /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        messagesContainer = this._document.createElement('div');\n        messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n        messagesContainer.setAttribute('aria-hidden', 'true');\n        messagesContainer.style.display = 'none';\n        this._document.body.appendChild(messagesContainer);\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    AriaDescriber.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new a11y_es5_AriaDescriber(_document);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_AriaDescriber,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_AriaDescriber],\n        /** @type {?} */ (common[\"d\" /* DOCUMENT */])\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar a11y_es5_ListKeyManager = /** @class */ (function () {\n    function ListKeyManager(_items) {\n        var _this = this;\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"Subject\"]();\n        this._typeaheadSubscription = Subscription[\"Subscription\"].EMPTY;\n        this._vertical = true;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"Subject\"]();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject[\"Subject\"]();\n        _items.changes.subscribe(function (newItems) {\n            if (_this._activeItem) {\n                var /** @type {?} */ itemArray = newItems.toArray();\n                var /** @type {?} */ newIndex = itemArray.indexOf(_this._activeItem);\n                if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\n                    _this._activeItemIndex = newIndex;\n                }\n            }\n        });\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withVerticalOrientation = /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    function (enabled) {\n        if (enabled === void 0) { enabled = true; }\n        this._vertical = enabled;\n        return this;\n    };\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withHorizontalOrientation = /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    function (direction) {\n        this._horizontal = direction;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(tap[\"tap\"])(function (keyCode) { return _this._pressedLetters.push(keyCode); }), Object(debounceTime[\"debounceTime\"])(debounceInterval), Object(filter[\"filter\"])(function () { return _this._pressedLetters.length > 0; }), Object(map[\"map\"])(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        var /** @type {?} */ keyCode = event.keyCode;\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical) {\n                    this.setNextItemActive();\n                    break;\n                }\n            case UP_ARROW:\n                if (this._vertical) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setNextItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setNextItemActive();\n                    break;\n                }\n            default:\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\nvar a11y_es5_ActiveDescendantKeyManager = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\nvar a11y_es5_FocusKeyManager = /** @class */ (function (_super) {\n    Object(tslib_es6[\"b\" /* __extends */])(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._origin = 'program';\n        return _this;\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setFocusOrigin = /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin;\n        return this;\n    };\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    };\n    return FocusKeyManager;\n}(a11y_es5_ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new core[\"y\" /* InjectionToken */]('liveAnnouncerElement');\nvar a11y_es5_LiveAnnouncer = /** @class */ (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        this._document = _document;\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: core[\"w\" /* Inject */], args: [common[\"d\" /* DOCUMENT */],] },] },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new a11y_es5_LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_LiveAnnouncer,\n    deps: [\n        [new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_LiveAnnouncer],\n        [new core[\"K\" /* Optional */](), new core[\"w\" /* Inject */](LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        common[\"d\" /* DOCUMENT */],\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar a11y_es5_FocusMonitor = /** @class */ (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Map of elements being monitored to their info.\n         */\n        this._elementInfo = new Map();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * @param {?} element\n     * @param {?=} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    FocusMonitor.prototype.monitor = /**\n     * @param {?} element\n     * @param {?=} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof core[\"S\" /* Renderer2 */])) {\n            checkChildren = renderer;\n        }\n        checkChildren = !!checkChildren;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return Object(of[\"of\"])(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject[\"Subject\"]()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeoutId != null) {\n                clearTimeout(_this._touchTimeoutId);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; }, 0);\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(_this._windowFocusTimeoutId);\n            clearTimeout(_this._touchTimeoutId);\n            clearTimeout(_this._originTimeoutId);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: core[\"J\" /* NgZone */], },\n        { type: platform_es5_Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar a11y_es5_CdkMonitorFocus = /** @class */ (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new core[\"s\" /* EventEmitter */]();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: core[\"q\" /* ElementRef */], },\n        { type: a11y_es5_FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new a11y_es5_FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: a11y_es5_FocusMonitor,\n    deps: [[new core[\"K\" /* Optional */](), new core[\"Y\" /* SkipSelf */](), a11y_es5_FocusMonitor], core[\"J\" /* NgZone */], platform_es5_Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar a11y_es5_A11yModule = /** @class */ (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    imports: [common[\"c\" /* CommonModule */], platform_es5_PlatformModule],\n                    declarations: [a11y_es5_CdkTrapFocus, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    exports: [a11y_es5_CdkTrapFocus, a11y_es5_FocusTrapDeprecatedDirective, a11y_es5_CdkMonitorFocus],\n                    providers: [\n                        a11y_es5_InteractivityChecker,\n                        a11y_es5_FocusTrapFactory,\n                        a11y_es5_AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=a11y.es5.js.map\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar ARROW_LEFT_KEYCODE = 37;\nvar contextMenuContent_component_ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.openSubMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeLeafMenu = new core[\"s\" /* EventEmitter */]();\n        this.closeAllMenus = new core[\"s\" /* EventEmitter */]();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new core[\"P\" /* QueryList */]();\n        queryList.reset(this.menuItems);\n        this._keyManager = new a11y_es5_ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE, event: event });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit({ event: event });\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: core[\"R\" /* Renderer */], },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: core[\"A\" /* Input */] },],\n        \"item\": [{ type: core[\"A\" /* Input */] },],\n        \"event\": [{ type: core[\"A\" /* Input */] },],\n        \"parentContextMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"overlay\": [{ type: core[\"A\" /* Input */] },],\n        \"isLeaf\": [{ type: core[\"A\" /* Input */] },],\n        \"execute\": [{ type: core[\"L\" /* Output */] },],\n        \"openSubMenu\": [{ type: core[\"L\" /* Output */] },],\n        \"closeLeafMenu\": [{ type: core[\"L\" /* Output */] },],\n        \"closeAllMenus\": [{ type: core[\"L\" /* Output */] },],\n        \"menuElement\": [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n        \"menuItemElements\": [{ type: core[\"_5\" /* ViewChildren */], args: ['li',] },],\n        \"onKeyEvent\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowDown', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Enter', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: core[\"v\" /* HostListener */], args: ['window:keydown.Escape', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: core[\"v\" /* HostListener */], args: ['document:click', ['$event'],] }, { type: core[\"v\" /* HostListener */], args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\n\n//# sourceMappingURL=contextMenuContent.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = core[\"_21\" /* ɵcrt */]({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\n\nfunction View_ContextMenuContentComponent_3(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_18\" /* ɵand */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), core[\"_22\" /* ɵdid */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_39\" /* ɵpod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_18\" /* ɵand */](0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n            \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), core[\"_22\" /* ɵdid */](3, 540672, null, 0, common[\"s\" /* NgTemplateOutlet */], [core[\"_6\" /* ViewContainerRef */]], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), core[\"_39\" /* ɵpod */](4, { $implicit: 0 }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n          \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), core[\"_22\" /* ɵdid */](3, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n          \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), core[\"_22\" /* ɵdid */](6, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nfunction View_ContextMenuContentComponent_0(_l) { return core[\"_47\" /* ɵvid */](0, [core[\"_43\" /* ɵqud */](402653184, 1, { menuElement: 0 }), core[\"_43\" /* ɵqud */](671088640, 2, { menuItemElements: 1 }), (_l()(), core[\"_23\" /* ɵeld */](2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* ɵeld */](4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n        \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), core[\"_22\" /* ɵdid */](7, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nfunction View_ContextMenuContentComponent_Host_0(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (core[\"_35\" /* ɵnov */](_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (core[\"_35\" /* ɵnov */](_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (core[\"_35\" /* ɵnov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (core[\"_35\" /* ɵnov */](_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (core[\"_35\" /* ɵnov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (core[\"_35\" /* ɵnov */](_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (core[\"_35\" /* ɵnov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (core[\"_35\" /* ɵnov */](_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), core[\"_22\" /* ɵdid */](1, 4440064, null, 0, contextMenuContent_component_ContextMenuContentComponent, [core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS], core[\"R\" /* Renderer */]], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = core[\"_19\" /* ɵccf */](\"context-menu-content\", contextMenuContent_component_ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\n\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory.js + 4 modules\nvar datepicker_ngfactory = __webpack_require__(295);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-tooltip.directive.ts + 1 modules\nvar calendar_tooltip_directive = __webpack_require__(66);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/operators.js\nvar operators = __webpack_require__(725);\nvar operators_default = /*#__PURE__*/__webpack_require__.n(operators);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n\nvar contextMenu_item_directive_ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new core[\"s\" /* EventEmitter */]();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: core[\"_1\" /* TemplateRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"divider\": [{ type: core[\"A\" /* Input */] },],\n        \"enabled\": [{ type: core[\"A\" /* Input */] },],\n        \"passive\": [{ type: core[\"A\" /* Input */] },],\n        \"visible\": [{ type: core[\"A\" /* Input */] },],\n        \"execute\": [{ type: core[\"L\" /* Output */] },],\n    };\n    return ContextMenuItemDirective;\n}());\n\n//# sourceMappingURL=contextMenu.item.directive.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\nvar contextMenu_service___assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar contextMenu_service_ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject[\"Subject\"]();\n        this.triggerClose = new Subject[\"Subject\"]();\n        this.close = new Subject[\"Subject\"]();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            var mouseEvent_1 = event;\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: mouseEvent_1.clientY,\n                    height: 0,\n                    left: mouseEvent_1.clientX,\n                    right: mouseEvent_1.clientX,\n                    top: mouseEvent_1.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus({ eventType: 'cancel', event: event });\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: anchorElement || this.fakeElement }, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new portal_es5_ComponentPortal(contextMenuContent_component_ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription[\"Subscription\"]();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function (executeEvent) { return _this.closeAllContextMenus(contextMenu_service___assign({ eventType: 'execute' }, executeEvent)); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function (closeAllEvent) { return _this.closeAllContextMenus(contextMenu_service___assign({ eventType: 'cancel' }, closeAllEvent)); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function (closeEvent) {\n        if (this.overlays) {\n            this.close.next(closeEvent);\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, exceptRootMenu = _b.exceptRootMenu, event = _b.event;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > 1 && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            if (!exceptRootMenu && _this.overlays.length > 0 && overlay) {\n                _this.close.next({ eventType: 'cancel', event: event });\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: core[\"x\" /* Injectable */] },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: overlay_es5_Overlay, },\n        { type: overlay_es5_ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\n\n//# sourceMappingURL=contextMenu.service.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\nvar contextMenu_component___assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\n\n\n\n\n\n\nvar contextMenu_component_ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new core[\"s\" /* EventEmitter */]();\n        this.open = new core[\"s\" /* EventEmitter */]();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription[\"Subscription\"]();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) {\n            _this.onMenuEvent(menuEvent);\n        }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        var _this = this;\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(contextMenu_component___assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this._contextMenuService.close.asObservable().pipe(Object(operators[\"first\"])()).subscribe(function (closeEvent) { return _this.close.emit(closeEvent); });\n        this.open.emit(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: core[\"l\" /* Component */], args: [{\n                    encapsulation: core[\"_7\" /* ViewEncapsulation */].None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n        { type: core[\"j\" /* ChangeDetectorRef */], },\n        { type: core[\"q\" /* ElementRef */], },\n        { type: undefined, decorators: [{ type: core[\"K\" /* Optional */] }, { type: core[\"w\" /* Inject */], args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"autoFocus\": [{ type: core[\"A\" /* Input */] },],\n        \"useBootstrap4\": [{ type: core[\"A\" /* Input */] },],\n        \"disabled\": [{ type: core[\"A\" /* Input */] },],\n        \"close\": [{ type: core[\"L\" /* Output */] },],\n        \"open\": [{ type: core[\"L\" /* Output */] },],\n        \"menuItems\": [{ type: core[\"o\" /* ContentChildren */], args: [contextMenu_item_directive_ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: core[\"_4\" /* ViewChild */], args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\n\n//# sourceMappingURL=contextMenu.component.js.map\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n\n\n\nvar contextMenu_attach_directive_ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: core[\"p\" /* Directive */], args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: contextMenu_service_ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: core[\"A\" /* Input */] },],\n        \"contextMenu\": [{ type: core[\"A\" /* Input */] },],\n        \"onContextMenu\": [{ type: core[\"v\" /* HostListener */], args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\n\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ngfactory.js + 6 modules\nvar calendar_month_view_component_ngfactory = __webpack_require__(297);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month-view.component.ts\nvar calendar_month_view_component = __webpack_require__(88);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-utils.provider.ts\nvar calendar_utils_provider = __webpack_require__(41);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ngfactory.js + 4 modules\nvar calendar_week_view_component_ngfactory = __webpack_require__(299);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week-view.component.ts\nvar calendar_week_view_component = __webpack_require__(90);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ngfactory.js + 6 modules\nvar calendar_day_view_component_ngfactory = __webpack_require__(298);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day-view.component.ts\nvar calendar_day_view_component = __webpack_require__(89);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date.pipe.ts\nvar calendar_date_pipe = __webpack_require__(63);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-date-formatter.provider.ts\nvar calendar_date_formatter_provider = __webpack_require__(34);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title.pipe.ts\nvar calendar_event_title_pipe = __webpack_require__(96);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-event-title-formatter.provider.ts\nvar calendar_event_title_formatter_provider = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ngfactory.js\nvar calendar_header_component_ngfactory = __webpack_require__(707);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/calendar-header.component.ts\nvar calendar_header_component = __webpack_require__(706);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = core[\"_21\" /* ɵcrt */]({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\n\nfunction View_ContextMenuComponent_0(_l) { return core[\"_47\" /* ɵvid */](0, [core[\"_43\" /* ɵqud */](402653184, 1, { menuElement: 0 }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\" \"]))], null, null); }\nfunction View_ContextMenuComponent_Host_0(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* ɵdid */](1, 180224, null, 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* ɵqud */](603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = core[\"_19\" /* ɵccf */](\"context-menu\", contextMenu_component_ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\n\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/colors.ts\nvar colors = __webpack_require__(708);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ts\n\n\n\nvar component_DemoComponent = /** @class */ (function () {\n    function DemoComponent() {\n        this.view = 'month';\n        this.viewDate = new Date();\n        this.events = [];\n        this.refresh = new Subject[\"Subject\"]();\n    }\n    DemoComponent.prototype.addEvent = function (date) {\n        this.events.push({\n            start: date,\n            title: 'New event',\n            color: colors[\"a\" /* colors */].red\n        });\n        this.refresh.next();\n    };\n    return DemoComponent;\n}());\n\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/component.ngfactory.js\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = core[\"_21\" /* ɵcrt */]({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\n\nfunction View_DemoComponent_1(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (core[\"_35\" /* ɵnov */](_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* ɵdid */](1, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* ɵdid */](2, 147456, null, 0, calendar_tooltip_directive[\"a\" /* CalendarTooltipDirective */], [core[\"q\" /* ElementRef */], core[\"z\" /* Injector */], core[\"S\" /* Renderer2 */], core[\"m\" /* ComponentFactoryResolver */], core[\"_6\" /* ViewContainerRef */], common[\"d\" /* DOCUMENT */]], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), core[\"_40\" /* ɵppd */](3, 3), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* ɵand */](0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = core[\"_46\" /* ɵunv */](_v, 2, 0, _ck(_v, 3, 0, core[\"_35\" /* ɵnov */](_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n  \"])), (_l()(), core[\"_23\" /* ɵeld */](1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* ɵdid */](2, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* ɵeld */](4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_3)), core[\"_22\" /* ɵdid */](7, 16384, null, 0, common[\"m\" /* NgIf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */]], { ngIf: [0, \"ngIf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* ɵeld */](9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](10, null, [\"\", \"\"])), core[\"_40\" /* ɵppd */](11, 3), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* ɵeld */](14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_4)), core[\"_22\" /* ɵdid */](17, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = core[\"_35\" /* ɵnov */](_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = core[\"_46\" /* ɵunv */](_v, 10, 0, _ck(_v, 11, 0, core[\"_35\" /* ɵnov */](_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* ɵdid */](1, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* ɵeld */](3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](4, null, [\"\", \"\"])), core[\"_40\" /* ɵppd */](5, 3), (_l()(), core[\"_23\" /* ɵeld */](6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n      \"])), (_l()(), core[\"_23\" /* ɵeld */](8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](9, null, [\"\", \"\"])), core[\"_40\" /* ɵppd */](10, 3), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = core[\"_35\" /* ɵnov */](_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = core[\"_46\" /* ɵunv */](_v, 4, 0, _ck(_v, 5, 0, core[\"_35\" /* ɵnov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = core[\"_46\" /* ɵunv */](_v, 9, 0, _ck(_v, 10, 0, core[\"_35\" /* ɵnov */](_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* ɵeld */](1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_6)), core[\"_22\" /* ɵdid */](4, 802816, null, 0, common[\"l\" /* NgForOf */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], core[\"B\" /* IterableDiffers */]], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_23\" /* ɵeld */](1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (core[\"_35\" /* ɵnov */](_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), core[\"_22\" /* ɵdid */](2, 278528, null, 0, common[\"k\" /* NgClass */], [core[\"B\" /* IterableDiffers */], core[\"C\" /* KeyValueDiffers */], core[\"q\" /* ElementRef */], core[\"S\" /* Renderer2 */]], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), core[\"_22\" /* ɵdid */](3, 16384, null, 0, contextMenu_attach_directive_ContextMenuAttachDirective, [contextMenu_service_ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n    \"])), (_l()(), core[\"_23\" /* ɵeld */](5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), core[\"_45\" /* ɵted */](6, null, [\"\\n      \", \"\\n    \"])), core[\"_40\" /* ɵppd */](7, 3), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = core[\"_35\" /* ɵnov */](_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = core[\"_46\" /* ɵunv */](_v, 6, 0, _ck(_v, 7, 0, core[\"_35\" /* ɵnov */](_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, calendar_month_view_component_ngfactory[\"b\" /* View_CalendarMonthViewComponent_0 */], calendar_month_view_component_ngfactory[\"a\" /* RenderType_CalendarMonthViewComponent */])), core[\"_22\" /* ɵdid */](1, 770048, null, 0, calendar_month_view_component[\"a\" /* CalendarMonthViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_35\" /* ɵnov */](_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, calendar_week_view_component_ngfactory[\"b\" /* View_CalendarWeekViewComponent_0 */], calendar_week_view_component_ngfactory[\"a\" /* RenderType_CalendarWeekViewComponent */])), core[\"_22\" /* ɵdid */](1, 770048, null, 0, calendar_week_view_component[\"a\" /* CalendarWeekViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_35\" /* ɵnov */](_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, calendar_day_view_component_ngfactory[\"b\" /* View_CalendarDayViewComponent_0 */], calendar_day_view_component_ngfactory[\"a\" /* RenderType_CalendarDayViewComponent */])), core[\"_22\" /* ɵdid */](1, 770048, null, 0, calendar_day_view_component[\"a\" /* CalendarDayViewComponent */], [core[\"j\" /* ChangeDetectorRef */], calendar_utils_provider[\"a\" /* CalendarUtils */], core[\"D\" /* LOCALE_ID */]], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = core[\"_35\" /* ɵnov */](_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_0(_l) { return core[\"_47\" /* ɵvid */](2, [core[\"_38\" /* ɵpid */](0, calendar_date_pipe[\"a\" /* CalendarDatePipe */], [calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], core[\"D\" /* LOCALE_ID */]]), core[\"_38\" /* ɵpid */](0, calendar_event_title_pipe[\"a\" /* CalendarEventTitlePipe */], [calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */]]), (_l()(), core[\"_23\" /* ɵeld */](2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, calendar_header_component_ngfactory[\"b\" /* View_CalendarHeaderComponent_0 */], calendar_header_component_ngfactory[\"a\" /* RenderType_CalendarHeaderComponent */])), core[\"_22\" /* ɵdid */](3, 49152, null, 0, calendar_header_component[\"a\" /* CalendarHeaderComponent */], [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* ɵeld */](6, 0, null, null, 6, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), core[\"_22\" /* ɵdid */](7, 180224, [[\"basicMenu\", 4]], 1, contextMenu_component_ContextMenuComponent, [contextMenu_service_ContextMenuService, core[\"j\" /* ChangeDetectorRef */], core[\"q\" /* ElementRef */], [2, CONTEXT_MENU_OPTIONS]], null, null), core[\"_43\" /* ɵqud */](603979776, 1, { menuItems: 1 }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* ɵand */](0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), core[\"_22\" /* ɵdid */](11, 16384, [[1, 4]], 0, contextMenu_item_directive_ContextMenuItemDirective, [core[\"_1\" /* TemplateRef */], core[\"q\" /* ElementRef */]], null, { execute: \"execute\" }), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"])), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* ɵand */](0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* ɵand */](0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_18\" /* ɵand */](0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\\n\"])), (_l()(), core[\"_23\" /* ɵeld */](20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), core[\"_22\" /* ɵdid */](21, 16384, null, 0, common[\"p\" /* NgSwitch */], [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_8)), core[\"_22\" /* ɵdid */](24, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_9)), core[\"_22\" /* ɵdid */](27, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n  \"])), (_l()(), core[\"_18\" /* ɵand */](16777216, null, null, 1, null, View_DemoComponent_10)), core[\"_22\" /* ɵdid */](30, 278528, null, 0, common[\"q\" /* NgSwitchCase */], [core[\"_6\" /* ViewContainerRef */], core[\"_1\" /* TemplateRef */], common[\"p\" /* NgSwitch */]], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), core[\"_45\" /* ɵted */](-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nfunction View_DemoComponent_Host_0(_l) { return core[\"_47\" /* ɵvid */](0, [(_l()(), core[\"_23\" /* ɵeld */](0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), core[\"_22\" /* ɵdid */](1, 49152, null, 0, component_DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = core[\"_19\" /* ɵccf */](\"mwl-demo-component\", component_DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\n\n//# sourceMappingURL=component.ngfactory.js.map\n// EXTERNAL MODULE: ./node_modules/@angular/forms/esm5/forms.js\nvar esm5_forms = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar.js\nvar ngb_calendar = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n.js\nvar datepicker_i18n = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter.js\nvar ngb_date_parser_formatter = __webpack_require__(62);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-adapter.js\nvar ngb_date_adapter = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config.js\nvar datepicker_config = __webpack_require__(61);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config.js\nvar timepicker_config = __webpack_require__(52);\n\n// EXTERNAL MODULE: ./node_modules/angular-draggable-droppable/esm5/angular-draggable-droppable.js\nvar angular_draggable_droppable = __webpack_require__(28);\n\n// EXTERNAL MODULE: ./src/modules/common/calendar-common.module.ts + 2 modules\nvar calendar_common_module = __webpack_require__(126);\n\n// EXTERNAL MODULE: ./src/modules/month/calendar-month.module.ts\nvar calendar_month_module = __webpack_require__(183);\n\n// EXTERNAL MODULE: ./node_modules/angular-resizable-element/esm5/angular-resizable-element.js\nvar angular_resizable_element = __webpack_require__(125);\n\n// EXTERNAL MODULE: ./src/modules/week/calendar-week.module.ts\nvar calendar_week_module = __webpack_require__(184);\n\n// EXTERNAL MODULE: ./src/modules/day/calendar-day.module.ts\nvar calendar_day_module = __webpack_require__(185);\n\n// EXTERNAL MODULE: ./src/modules/calendar.module.ts\nvar calendar_module = __webpack_require__(293);\n\n// CONCATENATED MODULE: ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n\n\n\n\n\n\n\n\n\nvar ngx_contextmenu_ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                contextMenu_service_ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: core[\"E\" /* NgModule */], args: [{\n                    declarations: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenuContent_component_ContextMenuContentComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        contextMenuContent_component_ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        contextMenu_attach_directive_ContextMenuAttachDirective,\n                        contextMenu_component_ContextMenuComponent,\n                        contextMenu_item_directive_ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        common[\"c\" /* CommonModule */],\n                        overlay_es5_OverlayModule,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\n\n//# sourceMappingURL=ngx-contextmenu.js.map\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module.js + 3 modules\nvar datepicker_module = __webpack_require__(127);\n\n// EXTERNAL MODULE: ./node_modules/@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module.js\nvar timepicker_module = __webpack_require__(128);\n\n// EXTERNAL MODULE: ./demos/demo-modules/demo-utils/module.ts\nvar demo_utils_module = __webpack_require__(296);\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/esm5/router.js\nvar router = __webpack_require__(87);\n\n// CONCATENATED MODULE: ./demos/demo-modules/context-menu/module.ngfactory.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DemoModuleNgFactory\", function() { return DemoModuleNgFactory; });\n/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DemoModuleNgFactory = core[\"_20\" /* ɵcmf */](DemoModule, [], function (_l) { return core[\"_31\" /* ɵmod */]([core[\"_32\" /* ɵmpd */](512, core[\"m\" /* ComponentFactoryResolver */], core[\"_16\" /* ɵCodegenComponentFactoryResolver */], [[8, [calendar_tooltip_directive_ngfactory[\"a\" /* CalendarTooltipWindowComponentNgFactory */], ContextMenuContentComponentNgFactory, datepicker_ngfactory[\"a\" /* NgbDatepickerNgFactory */], DemoComponentNgFactory]], [3, core[\"m\" /* ComponentFactoryResolver */]], core[\"H\" /* NgModuleRef */]]), core[\"_32\" /* ɵmpd */](4608, common[\"o\" /* NgLocalization */], common[\"n\" /* NgLocaleLocalization */], [core[\"D\" /* LOCALE_ID */], [2, common[\"y\" /* ɵa */]]]), core[\"_32\" /* ɵmpd */](6144, DIR_DOCUMENT, null, [common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](4608, bidi_es5_Directionality, bidi_es5_Directionality, [[2, DIR_DOCUMENT]]), core[\"_32\" /* ɵmpd */](4608, platform_es5_Platform, platform_es5_Platform, []), core[\"_32\" /* ɵmpd */](5120, scrolling_es5_ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, scrolling_es5_ScrollDispatcher], core[\"J\" /* NgZone */], platform_es5_Platform]), core[\"_32\" /* ɵmpd */](5120, scrolling_es5_ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, [[3, scrolling_es5_ViewportRuler], platform_es5_Platform, core[\"J\" /* NgZone */]]), core[\"_32\" /* ɵmpd */](4608, overlay_es5_ScrollStrategyOptions, overlay_es5_ScrollStrategyOptions, [scrolling_es5_ScrollDispatcher, scrolling_es5_ViewportRuler, core[\"J\" /* NgZone */], common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](5120, overlay_es5_OverlayContainer, OVERLAY_CONTAINER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayContainer], common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](4608, overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayPositionBuilder, [scrolling_es5_ViewportRuler, common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](5120, overlay_es5_OverlayKeyboardDispatcher, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY, [[3, overlay_es5_OverlayKeyboardDispatcher], common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](4608, overlay_es5_Overlay, overlay_es5_Overlay, [overlay_es5_ScrollStrategyOptions, overlay_es5_OverlayContainer, core[\"m\" /* ComponentFactoryResolver */], overlay_es5_OverlayPositionBuilder, overlay_es5_OverlayKeyboardDispatcher, core[\"g\" /* ApplicationRef */], core[\"z\" /* Injector */], core[\"J\" /* NgZone */], common[\"d\" /* DOCUMENT */]]), core[\"_32\" /* ɵmpd */](5120, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY, [overlay_es5_Overlay]), core[\"_32\" /* ɵmpd */](4608, esm5_forms[\"o\" /* ɵi */], esm5_forms[\"o\" /* ɵi */], []), core[\"_32\" /* ɵmpd */](4608, ngb_calendar[\"a\" /* NgbCalendar */], ngb_calendar[\"b\" /* NgbCalendarGregorian */], []), core[\"_32\" /* ɵmpd */](4608, datepicker_i18n[\"a\" /* NgbDatepickerI18n */], datepicker_i18n[\"b\" /* NgbDatepickerI18nDefault */], []), core[\"_32\" /* ɵmpd */](4608, ngb_date_parser_formatter[\"b\" /* NgbDateParserFormatter */], ngb_date_parser_formatter[\"a\" /* NgbDateISOParserFormatter */], []), core[\"_32\" /* ɵmpd */](4608, ngb_date_adapter[\"a\" /* NgbDateAdapter */], ngb_date_adapter[\"b\" /* NgbDateStructAdapter */], []), core[\"_32\" /* ɵmpd */](4608, datepicker_config[\"a\" /* NgbDatepickerConfig */], datepicker_config[\"a\" /* NgbDatepickerConfig */], []), core[\"_32\" /* ɵmpd */](4608, timepicker_config[\"a\" /* NgbTimepickerConfig */], timepicker_config[\"a\" /* NgbTimepickerConfig */], []), core[\"_32\" /* ɵmpd */](4608, angular_draggable_droppable[\"b\" /* DraggableHelper */], angular_draggable_droppable[\"b\" /* DraggableHelper */], []), core[\"_32\" /* ɵmpd */](4608, calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], calendar_event_title_formatter_provider[\"a\" /* CalendarEventTitleFormatter */], []), core[\"_32\" /* ɵmpd */](4608, calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], calendar_date_formatter_provider[\"a\" /* CalendarDateFormatter */], []), core[\"_32\" /* ɵmpd */](4608, calendar_utils_provider[\"a\" /* CalendarUtils */], calendar_utils_provider[\"a\" /* CalendarUtils */], []), core[\"_32\" /* ɵmpd */](4608, contextMenu_service_ContextMenuService, contextMenu_service_ContextMenuService, [overlay_es5_Overlay, overlay_es5_ScrollStrategyOptions]), core[\"_32\" /* ɵmpd */](512, common[\"c\" /* CommonModule */], common[\"c\" /* CommonModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_common_module[\"a\" /* CalendarCommonModule */], calendar_common_module[\"a\" /* CalendarCommonModule */], []), core[\"_32\" /* ɵmpd */](512, angular_draggable_droppable[\"a\" /* DragAndDropModule */], angular_draggable_droppable[\"a\" /* DragAndDropModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_month_module[\"a\" /* CalendarMonthModule */], calendar_month_module[\"a\" /* CalendarMonthModule */], []), core[\"_32\" /* ɵmpd */](512, angular_resizable_element[\"b\" /* ResizableModule */], angular_resizable_element[\"b\" /* ResizableModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_week_module[\"a\" /* CalendarWeekModule */], calendar_week_module[\"a\" /* CalendarWeekModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_day_module[\"a\" /* CalendarDayModule */], calendar_day_module[\"a\" /* CalendarDayModule */], []), core[\"_32\" /* ɵmpd */](512, calendar_module[\"c\" /* CalendarModule */], calendar_module[\"c\" /* CalendarModule */], []), core[\"_32\" /* ɵmpd */](512, bidi_es5_BidiModule, bidi_es5_BidiModule, []), core[\"_32\" /* ɵmpd */](512, portal_es5_PortalModule, portal_es5_PortalModule, []), core[\"_32\" /* ɵmpd */](512, platform_es5_PlatformModule, platform_es5_PlatformModule, []), core[\"_32\" /* ɵmpd */](512, scrolling_es5_ScrollDispatchModule, scrolling_es5_ScrollDispatchModule, []), core[\"_32\" /* ɵmpd */](512, overlay_es5_OverlayModule, overlay_es5_OverlayModule, []), core[\"_32\" /* ɵmpd */](512, ngx_contextmenu_ContextMenuModule, ngx_contextmenu_ContextMenuModule, []), core[\"_32\" /* ɵmpd */](512, esm5_forms[\"m\" /* ɵba */], esm5_forms[\"m\" /* ɵba */], []), core[\"_32\" /* ɵmpd */](512, esm5_forms[\"d\" /* FormsModule */], esm5_forms[\"d\" /* FormsModule */], []), core[\"_32\" /* ɵmpd */](512, datepicker_module[\"a\" /* NgbDatepickerModule */], datepicker_module[\"a\" /* NgbDatepickerModule */], []), core[\"_32\" /* ɵmpd */](512, timepicker_module[\"a\" /* NgbTimepickerModule */], timepicker_module[\"a\" /* NgbTimepickerModule */], []), core[\"_32\" /* ɵmpd */](512, demo_utils_module[\"a\" /* DemoUtilsModule */], demo_utils_module[\"a\" /* DemoUtilsModule */], []), core[\"_32\" /* ɵmpd */](512, router[\"o\" /* RouterModule */], router[\"o\" /* RouterModule */], [[2, router[\"t\" /* ɵa */]], [2, router[\"m\" /* Router */]]]), core[\"_32\" /* ɵmpd */](512, DemoModule, DemoModule, []), core[\"_32\" /* ɵmpd */](256, CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), core[\"_32\" /* ɵmpd */](1024, router[\"k\" /* ROUTES */], function () { return [[{ path: \"\", component: component_DemoComponent }]]; }, [])]); });\n\n//# sourceMappingURL=module.ngfactory.js.map\n\n/***/ }),\n\n/***/ 710:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n/***/ }),\n\n/***/ 712:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isScheduler_1 = __webpack_require__(187);\nvar of_1 = __webpack_require__(302);\nvar from_1 = __webpack_require__(324);\nvar concatAll_1 = __webpack_require__(316);\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 713:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(300);\nvar audit_1 = __webpack_require__(714);\nvar timer_1 = __webpack_require__(723);\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n/***/ }),\n\n/***/ 714:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n/***/ }),\n\n/***/ 715:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar async_1 = __webpack_require__(300);\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n/***/ }),\n\n/***/ 716:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(130);\nvar isArray_1 = __webpack_require__(92);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\nvar none = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };\n}\nexports.combineLatest = combineLatest;\nvar CombineLatestOperator = (function () {\n    function CombineLatestOperator(project) {\n        this.project = project;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n    };\n    return CombineLatestOperator;\n}());\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, project) {\n        _super.call(this, destination);\n        this.project = project;\n        this.active = 0;\n        this.values = [];\n        this.observables = [];\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(none);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === none ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.project) {\n                this._tryProject(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryProject = function (values) {\n        var result;\n        try {\n            result = this.project.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n//# sourceMappingURL=combineLatest.js.map\n\n/***/ }),\n\n/***/ 717:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nfunction find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };\n}\nexports.find = find;\nvar FindValueOperator = (function () {\n    function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    FindValueOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    };\n    return FindValueOperator;\n}());\nexports.FindValueOperator = FindValueOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FindValueSubscriber = (function (_super) {\n    __extends(FindValueSubscriber, _super);\n    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    FindValueSubscriber.prototype.notifyComplete = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    FindValueSubscriber.prototype._next = function (value) {\n        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n        var index = this.index++;\n        try {\n            var result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    FindValueSubscriber.prototype._complete = function () {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    };\n    return FindValueSubscriber;\n}(Subscriber_1.Subscriber));\nexports.FindValueSubscriber = FindValueSubscriber;\n//# sourceMappingURL=find.js.map\n\n/***/ }),\n\n/***/ 718:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar queue_1 = __webpack_require__(770);\nvar Subscription_1 = __webpack_require__(44);\nvar observeOn_1 = __webpack_require__(314);\nvar ObjectUnsubscribedError_1 = __webpack_require__(191);\nvar SubjectSubscription_1 = __webpack_require__(320);\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n/***/ }),\n\n/***/ 719:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = __webpack_require__(130);\nvar isArray_1 = __webpack_require__(92);\nvar Subscriber_1 = __webpack_require__(9);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\nvar iterator_1 = __webpack_require__(135);\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zip() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function zipOperatorFunction(source) {\n        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.zip = zip;\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nfunction zipStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = observables[observables.length - 1];\n    if (typeof project === 'function') {\n        observables.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\nexports.zipStatic = zipStatic;\nvar ZipOperator = (function () {\n    function ZipOperator(project) {\n        this.project = project;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.project));\n    };\n    return ZipOperator;\n}());\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, project, values) {\n        if (values === void 0) { values = Object.create(null); }\n        _super.call(this, destination);\n        this.iterators = [];\n        this.active = 0;\n        this.project = (typeof project === 'function') ? project : null;\n        this.values = values;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray_1.isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator_1.iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                this.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.project) {\n            this._tryProject(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ZipSubscriber = ZipSubscriber;\nvar StaticIterator = (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        _super.call(this, destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n\n/***/ }),\n\n/***/ 723:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TimerObservable_1 = __webpack_require__(724);\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n/***/ }),\n\n/***/ 724:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = __webpack_require__(305);\nvar Observable_1 = __webpack_require__(11);\nvar async_1 = __webpack_require__(300);\nvar isScheduler_1 = __webpack_require__(187);\nvar isDate_1 = __webpack_require__(710);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n/***/ }),\n\n/***/ 725:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar audit_1 = __webpack_require__(714);\nexports.audit = audit_1.audit;\nvar auditTime_1 = __webpack_require__(713);\nexports.auditTime = auditTime_1.auditTime;\nvar buffer_1 = __webpack_require__(726);\nexports.buffer = buffer_1.buffer;\nvar bufferCount_1 = __webpack_require__(727);\nexports.bufferCount = bufferCount_1.bufferCount;\nvar bufferTime_1 = __webpack_require__(728);\nexports.bufferTime = bufferTime_1.bufferTime;\nvar bufferToggle_1 = __webpack_require__(729);\nexports.bufferToggle = bufferToggle_1.bufferToggle;\nvar bufferWhen_1 = __webpack_require__(730);\nexports.bufferWhen = bufferWhen_1.bufferWhen;\nvar catchError_1 = __webpack_require__(326);\nexports.catchError = catchError_1.catchError;\nvar combineAll_1 = __webpack_require__(731);\nexports.combineAll = combineAll_1.combineAll;\nvar combineLatest_1 = __webpack_require__(716);\nexports.combineLatest = combineLatest_1.combineLatest;\nvar concat_1 = __webpack_require__(732);\nexports.concat = concat_1.concat;\nvar concatAll_1 = __webpack_require__(316);\nexports.concatAll = concatAll_1.concatAll;\nvar concatMap_1 = __webpack_require__(310);\nexports.concatMap = concatMap_1.concatMap;\nvar concatMapTo_1 = __webpack_require__(733);\nexports.concatMapTo = concatMapTo_1.concatMapTo;\nvar count_1 = __webpack_require__(734);\nexports.count = count_1.count;\nvar debounce_1 = __webpack_require__(735);\nexports.debounce = debounce_1.debounce;\nvar debounceTime_1 = __webpack_require__(715);\nexports.debounceTime = debounceTime_1.debounceTime;\nvar defaultIfEmpty_1 = __webpack_require__(331);\nexports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\nvar delay_1 = __webpack_require__(736);\nexports.delay = delay_1.delay;\nvar delayWhen_1 = __webpack_require__(737);\nexports.delayWhen = delayWhen_1.delayWhen;\nvar dematerialize_1 = __webpack_require__(738);\nexports.dematerialize = dematerialize_1.dematerialize;\nvar distinct_1 = __webpack_require__(739);\nexports.distinct = distinct_1.distinct;\nvar distinctUntilChanged_1 = __webpack_require__(304);\nexports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\nvar distinctUntilKeyChanged_1 = __webpack_require__(741);\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\nvar elementAt_1 = __webpack_require__(742);\nexports.elementAt = elementAt_1.elementAt;\nvar every_1 = __webpack_require__(328);\nexports.every = every_1.every;\nvar exhaust_1 = __webpack_require__(743);\nexports.exhaust = exhaust_1.exhaust;\nvar exhaustMap_1 = __webpack_require__(744);\nexports.exhaustMap = exhaustMap_1.exhaustMap;\nvar expand_1 = __webpack_require__(745);\nexports.expand = expand_1.expand;\nvar filter_1 = __webpack_require__(94);\nexports.filter = filter_1.filter;\nvar finalize_1 = __webpack_require__(746);\nexports.finalize = finalize_1.finalize;\nvar find_1 = __webpack_require__(717);\nexports.find = find_1.find;\nvar findIndex_1 = __webpack_require__(747);\nexports.findIndex = findIndex_1.findIndex;\nvar first_1 = __webpack_require__(327);\nexports.first = first_1.first;\nvar groupBy_1 = __webpack_require__(748);\nexports.groupBy = groupBy_1.groupBy;\nvar ignoreElements_1 = __webpack_require__(752);\nexports.ignoreElements = ignoreElements_1.ignoreElements;\nvar isEmpty_1 = __webpack_require__(753);\nexports.isEmpty = isEmpty_1.isEmpty;\nvar last_1 = __webpack_require__(329);\nexports.last = last_1.last;\nvar map_1 = __webpack_require__(93);\nexports.map = map_1.map;\nvar mapTo_1 = __webpack_require__(754);\nexports.mapTo = mapTo_1.mapTo;\nvar materialize_1 = __webpack_require__(755);\nexports.materialize = materialize_1.materialize;\nvar max_1 = __webpack_require__(756);\nexports.max = max_1.max;\nvar merge_1 = __webpack_require__(757);\nexports.merge = merge_1.merge;\nvar mergeAll_1 = __webpack_require__(134);\nexports.mergeAll = mergeAll_1.mergeAll;\nvar mergeMap_1 = __webpack_require__(65);\nexports.mergeMap = mergeMap_1.mergeMap;\nvar mergeMap_2 = __webpack_require__(65);\nexports.flatMap = mergeMap_2.mergeMap;\nvar mergeMapTo_1 = __webpack_require__(758);\nexports.mergeMapTo = mergeMapTo_1.mergeMapTo;\nvar mergeScan_1 = __webpack_require__(759);\nexports.mergeScan = mergeScan_1.mergeScan;\nvar min_1 = __webpack_require__(760);\nexports.min = min_1.min;\nvar multicast_1 = __webpack_require__(301);\nexports.multicast = multicast_1.multicast;\nvar observeOn_1 = __webpack_require__(314);\nexports.observeOn = observeOn_1.observeOn;\nvar onErrorResumeNext_1 = __webpack_require__(761);\nexports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\nvar pairwise_1 = __webpack_require__(197);\nexports.pairwise = pairwise_1.pairwise;\nvar partition_1 = __webpack_require__(762);\nexports.partition = partition_1.partition;\nvar pluck_1 = __webpack_require__(764);\nexports.pluck = pluck_1.pluck;\nvar publish_1 = __webpack_require__(765);\nexports.publish = publish_1.publish;\nvar publishBehavior_1 = __webpack_require__(766);\nexports.publishBehavior = publishBehavior_1.publishBehavior;\nvar publishLast_1 = __webpack_require__(767);\nexports.publishLast = publishLast_1.publishLast;\nvar publishReplay_1 = __webpack_require__(769);\nexports.publishReplay = publishReplay_1.publishReplay;\nvar race_1 = __webpack_require__(773);\nexports.race = race_1.race;\nvar reduce_1 = __webpack_require__(303);\nexports.reduce = reduce_1.reduce;\nvar repeat_1 = __webpack_require__(775);\nexports.repeat = repeat_1.repeat;\nvar repeatWhen_1 = __webpack_require__(776);\nexports.repeatWhen = repeatWhen_1.repeatWhen;\nvar retry_1 = __webpack_require__(777);\nexports.retry = retry_1.retry;\nvar retryWhen_1 = __webpack_require__(778);\nexports.retryWhen = retryWhen_1.retryWhen;\nvar refCount_1 = __webpack_require__(192);\nexports.refCount = refCount_1.refCount;\nvar sample_1 = __webpack_require__(779);\nexports.sample = sample_1.sample;\nvar sampleTime_1 = __webpack_require__(780);\nexports.sampleTime = sampleTime_1.sampleTime;\nvar scan_1 = __webpack_require__(330);\nexports.scan = scan_1.scan;\nvar sequenceEqual_1 = __webpack_require__(781);\nexports.sequenceEqual = sequenceEqual_1.sequenceEqual;\nvar share_1 = __webpack_require__(136);\nexports.share = share_1.share;\nvar shareReplay_1 = __webpack_require__(782);\nexports.shareReplay = shareReplay_1.shareReplay;\nvar single_1 = __webpack_require__(783);\nexports.single = single_1.single;\nvar skip_1 = __webpack_require__(784);\nexports.skip = skip_1.skip;\nvar skipLast_1 = __webpack_require__(785);\nexports.skipLast = skipLast_1.skipLast;\nvar skipUntil_1 = __webpack_require__(786);\nexports.skipUntil = skipUntil_1.skipUntil;\nvar skipWhile_1 = __webpack_require__(787);\nexports.skipWhile = skipWhile_1.skipWhile;\nvar startWith_1 = __webpack_require__(788);\nexports.startWith = startWith_1.startWith;\n/**\n * TODO(https://github.com/ReactiveX/rxjs/issues/2900): Add back subscribeOn once it can be\n * treeshaken. Currently if this export is added back, it\n * forces apps to bring in asap scheduler along with\n * Immediate, root, and other supporting code.\n */\n// export { subscribeOn } from './operators/subscribeOn';\nvar switchAll_1 = __webpack_require__(789);\nexports.switchAll = switchAll_1.switchAll;\nvar switchMap_1 = __webpack_require__(312);\nexports.switchMap = switchMap_1.switchMap;\nvar switchMapTo_1 = __webpack_require__(790);\nexports.switchMapTo = switchMapTo_1.switchMapTo;\nvar take_1 = __webpack_require__(132);\nexports.take = take_1.take;\nvar takeLast_1 = __webpack_require__(196);\nexports.takeLast = takeLast_1.takeLast;\nvar takeUntil_1 = __webpack_require__(195);\nexports.takeUntil = takeUntil_1.takeUntil;\nvar takeWhile_1 = __webpack_require__(791);\nexports.takeWhile = takeWhile_1.takeWhile;\nvar tap_1 = __webpack_require__(311);\nexports.tap = tap_1.tap;\nvar throttle_1 = __webpack_require__(306);\nexports.throttle = throttle_1.throttle;\nvar throttleTime_1 = __webpack_require__(792);\nexports.throttleTime = throttleTime_1.throttleTime;\nvar timeInterval_1 = __webpack_require__(793);\nexports.timeInterval = timeInterval_1.timeInterval;\nvar timeout_1 = __webpack_require__(794);\nexports.timeout = timeout_1.timeout;\nvar timeoutWith_1 = __webpack_require__(796);\nexports.timeoutWith = timeoutWith_1.timeoutWith;\nvar timestamp_1 = __webpack_require__(797);\nexports.timestamp = timestamp_1.timestamp;\nvar toArray_1 = __webpack_require__(798);\nexports.toArray = toArray_1.toArray;\nvar window_1 = __webpack_require__(799);\nexports.window = window_1.window;\nvar windowCount_1 = __webpack_require__(800);\nexports.windowCount = windowCount_1.windowCount;\nvar windowTime_1 = __webpack_require__(801);\nexports.windowTime = windowTime_1.windowTime;\nvar windowToggle_1 = __webpack_require__(802);\nexports.windowToggle = windowToggle_1.windowToggle;\nvar windowWhen_1 = __webpack_require__(803);\nexports.windowWhen = windowWhen_1.windowWhen;\nvar withLatestFrom_1 = __webpack_require__(804);\nexports.withLatestFrom = withLatestFrom_1.withLatestFrom;\nvar zip_1 = __webpack_require__(719);\nexports.zip = zip_1.zip;\nvar zipAll_1 = __webpack_require__(805);\nexports.zipAll = zipAll_1.zipAll;\n//# sourceMappingURL=operators.js.map\n\n/***/ }),\n\n/***/ 726:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return function bufferOperatorFunction(source) {\n        return source.lift(new BufferOperator(closingNotifier));\n    };\n}\nexports.buffer = buffer;\nvar BufferOperator = (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSubscriber = (function (_super) {\n    __extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        _super.call(this, destination);\n        this.buffer = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=buffer.js.map\n\n/***/ }),\n\n/***/ 727:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSkipCountSubscriber = (function (_super) {\n    __extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n/***/ }),\n\n/***/ 728:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(300);\nvar Subscriber_1 = __webpack_require__(9);\nvar isScheduler_1 = __webpack_require__(187);\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferTimeSubscriber = (function (_super) {\n    __extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        _super.call(this, destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        var context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context = contexts[i];\n            var buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n\n/***/ }),\n\n/***/ 729:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(44);\nvar subscribeToResult_1 = __webpack_require__(53);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nfunction bufferToggle(openings, closingSelector) {\n    return function bufferToggleOperatorFunction(source) {\n        return source.lift(new BufferToggleOperator(openings, closingSelector));\n    };\n}\nexports.bufferToggle = bufferToggle;\nvar BufferToggleOperator = (function () {\n    function BufferToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    BufferToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return BufferToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferToggleSubscriber = (function (_super) {\n    __extends(BufferToggleSubscriber, _super);\n    function BufferToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, openings));\n    }\n    BufferToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        for (var i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    };\n    BufferToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._error.call(this, err);\n    };\n    BufferToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._complete.call(this);\n    };\n    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    };\n    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.closeBuffer(innerSub.context);\n    };\n    BufferToggleSubscriber.prototype.openBuffer = function (value) {\n        try {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n        var contexts = this.contexts;\n        if (contexts && context) {\n            var buffer = context.buffer, subscription = context.subscription;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    };\n    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n        var contexts = this.contexts;\n        var buffer = [];\n        var subscription = new Subscription_1.Subscription();\n        var context = { buffer: buffer, subscription: subscription };\n        contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    };\n    return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferToggle.js.map\n\n/***/ }),\n\n/***/ 730:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(44);\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nfunction bufferWhen(closingSelector) {\n    return function (source) {\n        return source.lift(new BufferWhenOperator(closingSelector));\n    };\n}\nexports.bufferWhen = bufferWhen;\nvar BufferWhenOperator = (function () {\n    function BufferWhenOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    };\n    return BufferWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferWhenSubscriber = (function (_super) {\n    __extends(BufferWhenSubscriber, _super);\n    function BufferWhenSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    BufferWhenSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferWhenSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferWhenSubscriber.prototype._unsubscribe = function () {\n        this.buffer = null;\n        this.subscribing = false;\n    };\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    };\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    };\n    BufferWhenSubscriber.prototype.openBuffer = function () {\n        var closingSubscription = this.closingSubscription;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        var buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            closingSubscription = new Subscription_1.Subscription();\n            this.closingSubscription = closingSubscription;\n            this.add(closingSubscription);\n            this.subscribing = true;\n            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            this.subscribing = false;\n        }\n    };\n    return BufferWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferWhen.js.map\n\n/***/ }),\n\n/***/ 731:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar combineLatest_1 = __webpack_require__(716);\nfunction combineAll(project) {\n    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };\n}\nexports.combineAll = combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n/***/ }),\n\n/***/ 732:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concat_1 = __webpack_require__(712);\nvar concat_2 = __webpack_require__(712);\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n/***/ }),\n\n/***/ 733:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar concatMap_1 = __webpack_require__(310);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nfunction concatMapTo(innerObservable, resultSelector) {\n    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);\n}\nexports.concatMapTo = concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n/***/ }),\n\n/***/ 734:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nfunction count(predicate) {\n    return function (source) { return source.lift(new CountOperator(predicate, source)); };\n}\nexports.count = count;\nvar CountOperator = (function () {\n    function CountOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    CountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    };\n    return CountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CountSubscriber = (function (_super) {\n    __extends(CountSubscriber, _super);\n    function CountSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.count = 0;\n        this.index = 0;\n    }\n    CountSubscriber.prototype._next = function (value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._tryPredicate = function (value) {\n        var result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._complete = function () {\n        this.destination.next(this.count);\n        this.destination.complete();\n    };\n    return CountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=count.js.map\n\n/***/ }),\n\n/***/ 735:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nfunction debounce(durationSelector) {\n    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };\n}\nexports.debounce = debounce;\nvar DebounceOperator = (function () {\n    function DebounceOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    DebounceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    };\n    return DebounceOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceSubscriber = (function (_super) {\n    __extends(DebounceSubscriber, _super);\n    function DebounceSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n        this.durationSubscription = null;\n    }\n    DebounceSubscriber.prototype._next = function (value) {\n        try {\n            var result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DebounceSubscriber.prototype._complete = function () {\n        this.emitValue();\n        this.destination.complete();\n    };\n    DebounceSubscriber.prototype._tryNext = function (value, duration) {\n        var subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = subscribeToResult_1.subscribeToResult(this, duration);\n        if (!subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    };\n    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            var value = this.value;\n            var subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = null;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = null;\n            this.hasValue = false;\n            _super.prototype._next.call(this, value);\n        }\n    };\n    return DebounceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=debounce.js.map\n\n/***/ }),\n\n/***/ 736:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(300);\nvar isDate_1 = __webpack_require__(710);\nvar Subscriber_1 = __webpack_require__(9);\nvar Notification_1 = __webpack_require__(315);\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n/***/ }),\n\n/***/ 737:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar Observable_1 = __webpack_require__(11);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return function (source) {\n            return new SubscriptionDelayObservable(source, subscriptionDelay)\n                .lift(new DelayWhenOperator(delayDurationSelector));\n        };\n    }\n    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };\n}\nexports.delayWhen = delayWhen;\nvar DelayWhenOperator = (function () {\n    function DelayWhenOperator(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    };\n    return DelayWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelayWhenSubscriber = (function (_super) {\n    __extends(DelayWhenSubscriber, _super);\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\n        _super.call(this, destination);\n        this.delayDurationSelector = delayDurationSelector;\n        this.completed = false;\n        this.delayNotifierSubscriptions = [];\n        this.values = [];\n    }\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        var value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype._next = function (value) {\n        try {\n            var delayNotifier = this.delayDurationSelector(value);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DelayWhenSubscriber.prototype._complete = function () {\n        this.completed = true;\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n        subscription.unsubscribe();\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        var value = null;\n        if (subscriptionIdx !== -1) {\n            value = this.values[subscriptionIdx];\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n            this.values.splice(subscriptionIdx, 1);\n        }\n        return value;\n    };\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n        if (notifierSubscription && !notifierSubscription.closed) {\n            this.add(notifierSubscription);\n            this.delayNotifierSubscriptions.push(notifierSubscription);\n        }\n        this.values.push(value);\n    };\n    DelayWhenSubscriber.prototype.tryComplete = function () {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    };\n    return DelayWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelayObservable = (function (_super) {\n    __extends(SubscriptionDelayObservable, _super);\n    function SubscriptionDelayObservable(source, subscriptionDelay) {\n        _super.call(this);\n        this.source = source;\n        this.subscriptionDelay = subscriptionDelay;\n    }\n    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    };\n    return SubscriptionDelayObservable;\n}(Observable_1.Observable));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelaySubscriber = (function (_super) {\n    __extends(SubscriptionDelaySubscriber, _super);\n    function SubscriptionDelaySubscriber(parent, source) {\n        _super.call(this);\n        this.parent = parent;\n        this.source = source;\n        this.sourceSubscribed = false;\n    }\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    };\n    SubscriptionDelaySubscriber.prototype._complete = function () {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    };\n    return SubscriptionDelaySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=delayWhen.js.map\n\n/***/ }),\n\n/***/ 738:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return function dematerializeOperatorFunction(source) {\n        return source.lift(new DeMaterializeOperator());\n    };\n}\nexports.dematerialize = dematerialize;\nvar DeMaterializeOperator = (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DeMaterializeSubscriber = (function (_super) {\n    __extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n\n/***/ }),\n\n/***/ 739:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\nvar Set_1 = __webpack_require__(740);\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(keySelector, flushes) {\n    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };\n}\nexports.distinct = distinct;\nvar DistinctOperator = (function () {\n    function DistinctOperator(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    };\n    return DistinctOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctSubscriber = (function (_super) {\n    __extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, keySelector, flushes) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.values = new Set_1.Set();\n        if (flushes) {\n            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n        }\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.clear();\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    };\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\n        var key;\n        var destination = this.destination;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    };\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n        var values = this.values;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.DistinctSubscriber = DistinctSubscriber;\n//# sourceMappingURL=distinct.js.map\n\n/***/ }),\n\n/***/ 740:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(36);\nfunction minimalSetImpl() {\n    // THIS IS NOT a full impl of Set, this is just the minimum\n    // bits of functionality we need for this library.\n    return (function () {\n        function MinimalSet() {\n            this._values = [];\n        }\n        MinimalSet.prototype.add = function (value) {\n            if (!this.has(value)) {\n                this._values.push(value);\n            }\n        };\n        MinimalSet.prototype.has = function (value) {\n            return this._values.indexOf(value) !== -1;\n        };\n        Object.defineProperty(MinimalSet.prototype, \"size\", {\n            get: function () {\n                return this._values.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MinimalSet.prototype.clear = function () {\n            this._values.length = 0;\n        };\n        return MinimalSet;\n    }());\n}\nexports.minimalSetImpl = minimalSetImpl;\nexports.Set = root_1.root.Set || minimalSetImpl();\n//# sourceMappingURL=Set.js.map\n\n/***/ }),\n\n/***/ 741:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar distinctUntilChanged_1 = __webpack_require__(304);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nfunction distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n/***/ }),\n\n/***/ 742:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(188);\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nfunction elementAt(index, defaultValue) {\n    return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };\n}\nexports.elementAt = elementAt;\nvar ElementAtOperator = (function () {\n    function ElementAtOperator(index, defaultValue) {\n        this.index = index;\n        this.defaultValue = defaultValue;\n        if (index < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    ElementAtOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n    };\n    return ElementAtOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ElementAtSubscriber = (function (_super) {\n    __extends(ElementAtSubscriber, _super);\n    function ElementAtSubscriber(destination, index, defaultValue) {\n        _super.call(this, destination);\n        this.index = index;\n        this.defaultValue = defaultValue;\n    }\n    ElementAtSubscriber.prototype._next = function (x) {\n        if (this.index-- === 0) {\n            this.destination.next(x);\n            this.destination.complete();\n        }\n    };\n    ElementAtSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index >= 0) {\n            if (typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n            }\n            else {\n                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n            }\n        }\n        destination.complete();\n    };\n    return ElementAtSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=elementAt.js.map\n\n/***/ }),\n\n/***/ 743:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nfunction exhaust() {\n    return function (source) { return source.lift(new SwitchFirstOperator()); };\n}\nexports.exhaust = exhaust;\nvar SwitchFirstOperator = (function () {\n    function SwitchFirstOperator() {\n    }\n    SwitchFirstOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstSubscriber(subscriber));\n    };\n    return SwitchFirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstSubscriber = (function (_super) {\n    __extends(SwitchFirstSubscriber, _super);\n    function SwitchFirstSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasCompleted = false;\n        this.hasSubscription = false;\n    }\n    SwitchFirstSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, value));\n        }\n    };\n    SwitchFirstSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaust.js.map\n\n/***/ }),\n\n/***/ 744:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n/***/ }),\n\n/***/ 745:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };\n}\nexports.expand = expand;\nvar ExpandOperator = (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ExpandSubscriber = (function (_super) {\n    __extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        _super.call(this, destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            var result = tryCatch_1.tryCatch(this.project)(value, index);\n            if (result === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                var state = { subscriber: this, result: result, value: value, index: index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.ExpandSubscriber = ExpandSubscriber;\n//# sourceMappingURL=expand.js.map\n\n/***/ }),\n\n/***/ 746:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar Subscription_1 = __webpack_require__(44);\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction finalize(callback) {\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\n}\nexports.finalize = finalize;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finalize.js.map\n\n/***/ }),\n\n/***/ 747:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar find_1 = __webpack_require__(717);\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nfunction findIndex(predicate, thisArg) {\n    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };\n}\nexports.findIndex = findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n/***/ }),\n\n/***/ 748:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar Subscription_1 = __webpack_require__(44);\nvar Observable_1 = __webpack_require__(11);\nvar Subject_1 = __webpack_require__(29);\nvar Map_1 = __webpack_require__(749);\nvar FastMap_1 = __webpack_require__(751);\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return function (source) {\n        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n    };\n}\nexports.groupBy = groupBy;\nvar GroupByOperator = (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        _super.call(this, group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = (function (_super) {\n    __extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        _super.call(this);\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription_1.Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable_1.Observable));\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        _super.call(this);\n        this.parent = parent;\n        parent.count++;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription_1.Subscription));\n//# sourceMappingURL=groupBy.js.map\n\n/***/ }),\n\n/***/ 749:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar root_1 = __webpack_require__(36);\nvar MapPolyfill_1 = __webpack_require__(750);\nexports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n//# sourceMappingURL=Map.js.map\n\n/***/ }),\n\n/***/ 750:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.size = 0;\n        this._values = [];\n        this._keys = [];\n    }\n    MapPolyfill.prototype.get = function (key) {\n        var i = this._keys.indexOf(key);\n        return i === -1 ? undefined : this._values[i];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            this._keys.push(key);\n            this._values.push(value);\n            this.size++;\n        }\n        else {\n            this._values[i] = value;\n        }\n        return this;\n    };\n    MapPolyfill.prototype.delete = function (key) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            return false;\n        }\n        this._values.splice(i, 1);\n        this._keys.splice(i, 1);\n        this.size--;\n        return true;\n    };\n    MapPolyfill.prototype.clear = function () {\n        this._keys.length = 0;\n        this._values.length = 0;\n        this.size = 0;\n    };\n    MapPolyfill.prototype.forEach = function (cb, thisArg) {\n        for (var i = 0; i < this.size; i++) {\n            cb.call(thisArg, this._values[i], this._keys[i]);\n        }\n    };\n    return MapPolyfill;\n}());\nexports.MapPolyfill = MapPolyfill;\n//# sourceMappingURL=MapPolyfill.js.map\n\n/***/ }),\n\n/***/ 751:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar FastMap = (function () {\n    function FastMap() {\n        this.values = {};\n    }\n    FastMap.prototype.delete = function (key) {\n        this.values[key] = null;\n        return true;\n    };\n    FastMap.prototype.set = function (key, value) {\n        this.values[key] = value;\n        return this;\n    };\n    FastMap.prototype.get = function (key) {\n        return this.values[key];\n    };\n    FastMap.prototype.forEach = function (cb, thisArg) {\n        var values = this.values;\n        for (var key in values) {\n            if (values.hasOwnProperty(key) && values[key] !== null) {\n                cb.call(thisArg, values[key], key);\n            }\n        }\n    };\n    FastMap.prototype.clear = function () {\n        this.values = {};\n    };\n    return FastMap;\n}());\nexports.FastMap = FastMap;\n//# sourceMappingURL=FastMap.js.map\n\n/***/ }),\n\n/***/ 752:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar noop_1 = __webpack_require__(318);\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return function ignoreElementsOperatorFunction(source) {\n        return source.lift(new IgnoreElementsOperator());\n    };\n}\nexports.ignoreElements = ignoreElements;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n/***/ }),\n\n/***/ 753:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nfunction isEmpty() {\n    return function (source) { return source.lift(new IsEmptyOperator()); };\n}\nexports.isEmpty = isEmpty;\nvar IsEmptyOperator = (function () {\n    function IsEmptyOperator() {\n    }\n    IsEmptyOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new IsEmptySubscriber(observer));\n    };\n    return IsEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IsEmptySubscriber = (function (_super) {\n    __extends(IsEmptySubscriber, _super);\n    function IsEmptySubscriber(destination) {\n        _super.call(this, destination);\n    }\n    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n        var destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    };\n    IsEmptySubscriber.prototype._next = function (value) {\n        this.notifyComplete(false);\n    };\n    IsEmptySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return IsEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=isEmpty.js.map\n\n/***/ }),\n\n/***/ 754:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return function (source) { return source.lift(new MapToOperator(value)); };\n}\nexports.mapTo = mapTo;\nvar MapToOperator = (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapToSubscriber = (function (_super) {\n    __extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        _super.call(this, destination);\n        this.value = value;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=mapTo.js.map\n\n/***/ }),\n\n/***/ 755:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar Notification_1 = __webpack_require__(315);\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1…, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return function materializeOperatorFunction(source) {\n        return source.lift(new MaterializeOperator());\n    };\n}\nexports.materialize = materialize;\nvar MaterializeOperator = (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MaterializeSubscriber = (function (_super) {\n    __extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification_1.Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=materialize.js.map\n\n/***/ }),\n\n/***/ 756:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(303);\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nfunction max(comparer) {\n    var max = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n        : function (x, y) { return x > y ? x : y; };\n    return reduce_1.reduce(max);\n}\nexports.max = max;\n//# sourceMappingURL=max.js.map\n\n/***/ }),\n\n/***/ 757:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar merge_1 = __webpack_require__(131);\nvar merge_2 = __webpack_require__(131);\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n/***/ }),\n\n/***/ 758:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };\n}\nexports.mergeMapTo = mergeMapTo;\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nvar MergeMapToOperator = (function () {\n    function MergeMapToOperator(ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapToOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n    };\n    return MergeMapToOperator;\n}());\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapToSubscriber = (function (_super) {\n    __extends(MergeMapToSubscriber, _super);\n    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapToSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var resultSelector = this.resultSelector;\n            var index = this.index++;\n            var ish = this.ish;\n            var destination = this.destination;\n            this.active++;\n            this._innerSub(ish, destination, resultSelector, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapToSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    MergeMapToSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n//# sourceMappingURL=mergeMapTo.js.map\n\n/***/ }),\n\n/***/ 759:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\nvar subscribeToResult_1 = __webpack_require__(53);\nvar OuterSubscriber_1 = __webpack_require__(54);\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nfunction mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };\n}\nexports.mergeScan = mergeScan;\nvar MergeScanOperator = (function () {\n    function MergeScanOperator(accumulator, seed, concurrent) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    MergeScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n    };\n    return MergeScanOperator;\n}());\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeScanSubscriber = (function (_super) {\n    __extends(MergeScanSubscriber, _super);\n    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.acc = acc;\n        this.concurrent = concurrent;\n        this.hasValue = false;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeScanSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var index = this.index++;\n            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n            var destination = this.destination;\n            if (ish === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.active++;\n                this._innerSub(ish, value, index);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeScanSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var destination = this.destination;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    };\n    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeScanSubscriber = MergeScanSubscriber;\n//# sourceMappingURL=mergeScan.js.map\n\n/***/ }),\n\n/***/ 760:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(303);\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nfunction min(comparer) {\n    var min = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n        : function (x, y) { return x < y ? x : y; };\n    return reduce_1.reduce(min);\n}\nexports.min = min;\n//# sourceMappingURL=min.js.map\n\n/***/ }),\n\n/***/ 761:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar FromObservable_1 = __webpack_require__(325);\nvar isArray_1 = __webpack_require__(92);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\nfunction onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n/* tslint:enable:max-line-length */\nfunction onErrorResumeNextStatic() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    var source = null;\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNextStatic = onErrorResumeNextStatic;\nvar OnErrorResumeNextOperator = (function () {\n    function OnErrorResumeNextOperator(nextSources) {\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    };\n    return OnErrorResumeNextOperator;\n}());\nvar OnErrorResumeNextSubscriber = (function (_super) {\n    __extends(OnErrorResumeNextSubscriber, _super);\n    function OnErrorResumeNextSubscriber(destination, nextSources) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._error = function (err) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._complete = function () {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n        var next = this.nextSources.shift();\n        if (next) {\n            this.add(subscribeToResult_1.subscribeToResult(this, next));\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return OnErrorResumeNextSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n/***/ }),\n\n/***/ 762:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar not_1 = __webpack_require__(763);\nvar filter_1 = __webpack_require__(94);\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nfunction partition(predicate, thisArg) {\n    return function (source) { return [\n        filter_1.filter(predicate, thisArg)(source),\n        filter_1.filter(not_1.not(predicate, thisArg))(source)\n    ]; };\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n/***/ }),\n\n/***/ 763:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nfunction not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\nexports.not = not;\n//# sourceMappingURL=not.js.map\n\n/***/ }),\n\n/***/ 764:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar map_1 = __webpack_require__(93);\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i - 0] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return function (source) { return map_1.map(plucker(properties, length))(source); };\n}\nexports.pluck = pluck;\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n\n/***/ }),\n\n/***/ 765:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Subject_1 = __webpack_require__(29);\nvar multicast_1 = __webpack_require__(301);\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ?\n        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast(new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n/***/ }),\n\n/***/ 766:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar BehaviorSubject_1 = __webpack_require__(198);\nvar multicast_1 = __webpack_require__(301);\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n/***/ }),\n\n/***/ 767:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar AsyncSubject_1 = __webpack_require__(768);\nvar multicast_1 = __webpack_require__(301);\nfunction publishLast() {\n    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };\n}\nexports.publishLast = publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n/***/ }),\n\n/***/ 768:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar Subscription_1 = __webpack_require__(44);\n/**\n * @class AsyncSubject<T>\n */\nvar AsyncSubject = (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        _super.apply(this, arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject_1.Subject));\nexports.AsyncSubject = AsyncSubject;\n//# sourceMappingURL=AsyncSubject.js.map\n\n/***/ }),\n\n/***/ 769:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ReplaySubject_1 = __webpack_require__(718);\nvar multicast_1 = __webpack_require__(301);\n/* tslint:enable:max-line-length */\nfunction publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n        scheduler = selectorOrScheduler;\n    }\n    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };\n}\nexports.publishReplay = publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n/***/ }),\n\n/***/ 770:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar QueueAction_1 = __webpack_require__(771);\nvar QueueScheduler_1 = __webpack_require__(772);\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n/***/ }),\n\n/***/ 771:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = __webpack_require__(321);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n/***/ }),\n\n/***/ 772:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = __webpack_require__(322);\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n/***/ }),\n\n/***/ 773:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar isArray_1 = __webpack_require__(92);\nvar race_1 = __webpack_require__(774);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function raceOperatorFunction(source) {\n        // if the only argument is an array, it was most likely called with\n        // `pair([obs1, obs2, ...])`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.race = race;\n//# sourceMappingURL=race.js.map\n\n/***/ }),\n\n/***/ 774:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = __webpack_require__(92);\nvar ArrayObservable_1 = __webpack_require__(130);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `race([obs1, obs2, ...])`\n    if (observables.length === 1) {\n        if (isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n}\nexports.race = race;\nvar RaceOperator = (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexports.RaceOperator = RaceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RaceSubscriber = (function (_super) {\n    __extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasFirst = false;\n        this.observables = [];\n        this.subscriptions = [];\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.RaceSubscriber = RaceSubscriber;\n//# sourceMappingURL=race.js.map\n\n/***/ }),\n\n/***/ 775:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar EmptyObservable_1 = __webpack_require__(64);\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (count < 0) {\n            return source.lift(new RepeatOperator(-1, source));\n        }\n        else {\n            return source.lift(new RepeatOperator(count - 1, source));\n        }\n    };\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n/***/ }),\n\n/***/ 776:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nfunction repeatWhen(notifier) {\n    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };\n}\nexports.repeatWhen = repeatWhen;\nvar RepeatWhenOperator = (function () {\n    function RepeatWhenOperator(notifier) {\n        this.notifier = notifier;\n    }\n    RepeatWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    };\n    return RepeatWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatWhenSubscriber = (function (_super) {\n    __extends(RepeatWhenSubscriber, _super);\n    function RepeatWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n        this.sourceIsBeingSubscribedTo = true;\n    }\n    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    };\n    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return _super.prototype.complete.call(this);\n        }\n    };\n    RepeatWhenSubscriber.prototype.complete = function () {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            else if (this.retriesSubscription.closed) {\n                return _super.prototype.complete.call(this);\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next();\n        }\n    };\n    RepeatWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.notifications = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        _super.prototype._unsubscribeAndRecycle.call(this);\n        this.notifications = notifications;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        return this;\n    };\n    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n        this.notifications = new Subject_1.Subject();\n        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n        if (retries === errorObject_1.errorObject) {\n            return _super.prototype.complete.call(this);\n        }\n        this.retries = retries;\n        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n    };\n    return RepeatWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=repeatWhen.js.map\n\n/***/ }),\n\n/***/ 777:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nfunction retry(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) { return source.lift(new RetryOperator(count, source)); };\n}\nexports.retry = retry;\nvar RetryOperator = (function () {\n    function RetryOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RetryOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    };\n    return RetryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetrySubscriber = (function (_super) {\n    __extends(RetrySubscriber, _super);\n    function RetrySubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RetrySubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.error.call(this, err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RetrySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=retry.js.map\n\n/***/ }),\n\n/***/ 778:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };\n}\nexports.retryWhen = retryWhen;\nvar RetryWhenOperator = (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetryWhenSubscriber = (function (_super) {\n    __extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.errors = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this._unsubscribeAndRecycle();\n        this.errors = errors;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n\n/***/ }),\n\n/***/ 779:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nfunction sample(notifier) {\n    return function (source) { return source.lift(new SampleOperator(notifier)); };\n}\nexports.sample = sample;\nvar SampleOperator = (function () {\n    function SampleOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SampleOperator.prototype.call = function (subscriber, source) {\n        var sampleSubscriber = new SampleSubscriber(subscriber);\n        var subscription = source.subscribe(sampleSubscriber);\n        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n        return subscription;\n    };\n    return SampleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleSubscriber = (function (_super) {\n    __extends(SampleSubscriber, _super);\n    function SampleSubscriber() {\n        _super.apply(this, arguments);\n        this.hasValue = false;\n    }\n    SampleSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n    };\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    };\n    return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=sample.js.map\n\n/***/ }),\n\n/***/ 780:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar async_1 = __webpack_require__(300);\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };\n}\nexports.sampleTime = sampleTime;\nvar SampleTimeOperator = (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleTimeSubscriber = (function (_super) {\n    __extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        _super.call(this, destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n\n/***/ }),\n\n/***/ 781:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nfunction sequenceEqual(compareTo, comparor) {\n    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };\n}\nexports.sequenceEqual = sequenceEqual;\nvar SequenceEqualOperator = (function () {\n    function SequenceEqualOperator(compareTo, comparor) {\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n    }\n    SequenceEqualOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    };\n    return SequenceEqualOperator;\n}());\nexports.SequenceEqualOperator = SequenceEqualOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SequenceEqualSubscriber = (function (_super) {\n    __extends(SequenceEqualSubscriber, _super);\n    function SequenceEqualSubscriber(destination, compareTo, comparor) {\n        _super.call(this, destination);\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    SequenceEqualSubscriber.prototype._next = function (value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype._complete = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    };\n    SequenceEqualSubscriber.prototype.checkValues = function () {\n        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n        while (_a.length > 0 && _b.length > 0) {\n            var a = _a.shift();\n            var b = _b.shift();\n            var areEqual = false;\n            if (comparor) {\n                areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                if (areEqual === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                areEqual = a === b;\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    };\n    SequenceEqualSubscriber.prototype.emit = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    SequenceEqualSubscriber.prototype.nextB = function (value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    };\n    return SequenceEqualSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SequenceEqualSubscriber = SequenceEqualSubscriber;\nvar SequenceEqualCompareToSubscriber = (function (_super) {\n    __extends(SequenceEqualCompareToSubscriber, _super);\n    function SequenceEqualCompareToSubscriber(destination, parent) {\n        _super.call(this, destination);\n        this.parent = parent;\n    }\n    SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n        this.parent.nextB(value);\n    };\n    SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n        this.parent.error(err);\n    };\n    SequenceEqualCompareToSubscriber.prototype._complete = function () {\n        this.parent._complete();\n    };\n    return SequenceEqualCompareToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=sequenceEqual.js.map\n\n/***/ }),\n\n/***/ 782:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ReplaySubject_1 = __webpack_require__(718);\n/**\n * @method shareReplay\n * @owner Observable\n */\nfunction shareReplay(bufferSize, windowTime, scheduler) {\n    return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };\n}\nexports.shareReplay = shareReplay;\nfunction shareReplayOperator(bufferSize, windowTime, scheduler) {\n    var subject;\n    var refCount = 0;\n    var subscription;\n    var hasError = false;\n    var isComplete = false;\n    return function shareReplayOperation(source) {\n        refCount++;\n        if (!subject || hasError) {\n            hasError = false;\n            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n            subscription = source.subscribe({\n                next: function (value) { subject.next(value); },\n                error: function (err) {\n                    hasError = true;\n                    subject.error(err);\n                },\n                complete: function () {\n                    isComplete = true;\n                    subject.complete();\n                },\n            });\n        }\n        var innerSub = subject.subscribe(this);\n        return function () {\n            refCount--;\n            innerSub.unsubscribe();\n            if (subscription && refCount === 0 && isComplete) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n}\n;\n//# sourceMappingURL=shareReplay.js.map\n\n/***/ }),\n\n/***/ 783:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar EmptyError_1 = __webpack_require__(138);\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nfunction single(predicate) {\n    return function (source) { return source.lift(new SingleOperator(predicate, source)); };\n}\nexports.single = single;\nvar SingleOperator = (function () {\n    function SingleOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    SingleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    };\n    return SingleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SingleSubscriber = (function (_super) {\n    __extends(SingleSubscriber, _super);\n    function SingleSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    SingleSubscriber.prototype.applySingleValue = function (value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    };\n    SingleSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    };\n    SingleSubscriber.prototype.tryNext = function (value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    SingleSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return SingleSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=single.js.map\n\n/***/ }),\n\n/***/ 784:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return function (source) { return source.lift(new SkipOperator(count)); };\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n/***/ }),\n\n/***/ 785:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar ArgumentOutOfRangeError_1 = __webpack_require__(188);\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nfunction skipLast(count) {\n    return function (source) { return source.lift(new SkipLastOperator(count)); };\n}\nexports.skipLast = skipLast;\nvar SkipLastOperator = (function () {\n    function SkipLastOperator(_skipCount) {\n        this._skipCount = _skipCount;\n        if (this._skipCount < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    SkipLastOperator.prototype.call = function (subscriber, source) {\n        if (this._skipCount === 0) {\n            // If we don't want to skip any values then just subscribe\n            // to Subscriber without any further logic.\n            return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n        }\n        else {\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n        }\n    };\n    return SkipLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipLastSubscriber = (function (_super) {\n    __extends(SkipLastSubscriber, _super);\n    function SkipLastSubscriber(destination, _skipCount) {\n        _super.call(this, destination);\n        this._skipCount = _skipCount;\n        this._count = 0;\n        this._ring = new Array(_skipCount);\n    }\n    SkipLastSubscriber.prototype._next = function (value) {\n        var skipCount = this._skipCount;\n        var count = this._count++;\n        if (count < skipCount) {\n            this._ring[count] = value;\n        }\n        else {\n            var currentIndex = count % skipCount;\n            var ring = this._ring;\n            var oldValue = ring[currentIndex];\n            ring[currentIndex] = value;\n            this.destination.next(oldValue);\n        }\n    };\n    return SkipLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipLast.js.map\n\n/***/ }),\n\n/***/ 786:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };\n}\nexports.skipUntil = skipUntil;\nvar SkipUntilOperator = (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipUntilSubscriber = (function (_super) {\n    __extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.isInnerStopped = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype._complete = function () {\n        if (this.isInnerStopped) {\n            _super.prototype._complete.call(this);\n        }\n        else {\n            this.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n        this.isInnerStopped = true;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n\n/***/ }),\n\n/***/ 787:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };\n}\nexports.skipWhile = skipWhile;\nvar SkipWhileOperator = (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipWhileSubscriber = (function (_super) {\n    __extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n\n/***/ }),\n\n/***/ 788:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar ArrayObservable_1 = __webpack_require__(130);\nvar ScalarObservable_1 = __webpack_require__(190);\nvar EmptyObservable_1 = __webpack_require__(64);\nvar concat_1 = __webpack_require__(712);\nvar isScheduler_1 = __webpack_require__(187);\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len === 1) {\n            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n        }\n        else if (len > 1) {\n            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n        }\n        else {\n            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n        }\n    };\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n/***/ }),\n\n/***/ 789:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar switchMap_1 = __webpack_require__(312);\nvar identity_1 = __webpack_require__(319);\nfunction switchAll() {\n    return switchMap_1.switchMap(identity_1.identity);\n}\nexports.switchAll = switchAll;\n//# sourceMappingURL=switchAll.js.map\n\n/***/ }),\n\n/***/ 790:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };\n}\nexports.switchMapTo = switchMapTo;\nvar SwitchMapToOperator = (function () {\n    function SwitchMapToOperator(observable, resultSelector) {\n        this.observable = observable;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n    };\n    return SwitchMapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapToSubscriber = (function (_super) {\n    __extends(SwitchMapToSubscriber, _super);\n    function SwitchMapToSubscriber(destination, inner, resultSelector) {\n        _super.call(this, destination);\n        this.inner = inner;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapToSubscriber.prototype._next = function (value) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n    };\n    SwitchMapToSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMapTo.js.map\n\n/***/ }),\n\n/***/ 791:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nfunction takeWhile(predicate) {\n    return function (source) { return source.lift(new TakeWhileOperator(predicate)); };\n}\nexports.takeWhile = takeWhile;\nvar TakeWhileOperator = (function () {\n    function TakeWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    TakeWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n    };\n    return TakeWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeWhileSubscriber = (function (_super) {\n    __extends(TakeWhileSubscriber, _super);\n    function TakeWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.index = 0;\n    }\n    TakeWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        var result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    };\n    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n        var destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            destination.complete();\n        }\n    };\n    return TakeWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeWhile.js.map\n\n/***/ }),\n\n/***/ 792:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar async_1 = __webpack_require__(300);\nvar throttle_1 = __webpack_require__(306);\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n}\nexports.throttleTime = throttleTime;\nvar ThrottleTimeOperator = (function () {\n    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    };\n    return ThrottleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleTimeSubscriber = (function (_super) {\n    __extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n        this._hasTrailingValue = false;\n        this._trailingValue = null;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=throttleTime.js.map\n\n/***/ }),\n\n/***/ 793:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar async_1 = __webpack_require__(300);\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };\n}\nexports.timeInterval = timeInterval;\nvar TimeInterval = (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexports.TimeInterval = TimeInterval;\n;\nvar TimeIntervalOperator = (function () {\n    function TimeIntervalOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimeIntervalOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n    };\n    return TimeIntervalOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeIntervalSubscriber = (function (_super) {\n    __extends(TimeIntervalSubscriber, _super);\n    function TimeIntervalSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.lastTime = 0;\n        this.lastTime = scheduler.now();\n    }\n    TimeIntervalSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        var span = now - this.lastTime;\n        this.lastTime = now;\n        this.destination.next(new TimeInterval(value, span));\n    };\n    return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeInterval.js.map\n\n/***/ }),\n\n/***/ 794:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(300);\nvar isDate_1 = __webpack_require__(710);\nvar Subscriber_1 = __webpack_require__(9);\nvar TimeoutError_1 = __webpack_require__(795);\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n/***/ }),\n\n/***/ 795:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var err = _super.call(this, 'Timeout has occurred');\n        this.name = err.name = 'TimeoutError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return TimeoutError;\n}(Error));\nexports.TimeoutError = TimeoutError;\n//# sourceMappingURL=TimeoutError.js.map\n\n/***/ }),\n\n/***/ 796:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = __webpack_require__(300);\nvar isDate_1 = __webpack_require__(710);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nfunction timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) {\n        var absoluteTimeout = isDate_1.isDate(due);\n        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n    };\n}\nexports.timeoutWith = timeoutWith;\nvar TimeoutWithOperator = (function () {\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    };\n    return TimeoutWithOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutWithSubscriber = (function (_super) {\n    __extends(TimeoutWithSubscriber, _super);\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n        var withObservable = subscriber.withObservable;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n    };\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutWithSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutWithSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.withObservable = null;\n    };\n    return TimeoutWithSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=timeoutWith.js.map\n\n/***/ }),\n\n/***/ 797:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar async_1 = __webpack_require__(300);\nvar map_1 = __webpack_require__(93);\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nfunction timestamp(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });\n    // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n}\nexports.timestamp = timestamp;\nvar Timestamp = (function () {\n    function Timestamp(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    return Timestamp;\n}());\nexports.Timestamp = Timestamp;\n;\n//# sourceMappingURL=timestamp.js.map\n\n/***/ }),\n\n/***/ 798:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar reduce_1 = __webpack_require__(303);\nfunction toArrayReducer(arr, item, index) {\n    arr.push(item);\n    return arr;\n}\nfunction toArray() {\n    return reduce_1.reduce(toArrayReducer, []);\n}\nexports.toArray = toArray;\n//# sourceMappingURL=toArray.js.map\n\n/***/ }),\n\n/***/ 799:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nfunction window(windowBoundaries) {\n    return function windowOperatorFunction(source) {\n        return source.lift(new WindowOperator(windowBoundaries));\n    };\n}\nexports.window = window;\nvar WindowOperator = (function () {\n    function WindowOperator(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        var windowSubscriber = new WindowSubscriber(subscriber);\n        var sourceSubscription = source.subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n        }\n        return sourceSubscription;\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination) {\n        _super.call(this, destination);\n        this.window = new Subject_1.Subject();\n        destination.next(this.window);\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow();\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this._complete();\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n    };\n    WindowSubscriber.prototype._unsubscribe = function () {\n        this.window = null;\n    };\n    WindowSubscriber.prototype.openWindow = function () {\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var destination = this.destination;\n        var newWindow = this.window = new Subject_1.Subject();\n        destination.next(newWindow);\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=window.js.map\n\n/***/ }),\n\n/***/ 800:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(9);\nvar Subject_1 = __webpack_require__(29);\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    return function windowCountOperatorFunction(source) {\n        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n    };\n}\nexports.windowCount = windowCount;\nvar WindowCountOperator = (function () {\n    function WindowCountOperator(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    WindowCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    };\n    return WindowCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowCountSubscriber = (function (_super) {\n    __extends(WindowCountSubscriber, _super);\n    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n        this.windows = [new Subject_1.Subject()];\n        this.count = 0;\n        destination.next(this.windows[0]);\n    }\n    WindowCountSubscriber.prototype._next = function (value) {\n        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        var destination = this.destination;\n        var windowSize = this.windowSize;\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        var c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            var window_1 = new Subject_1.Subject();\n            windows.push(window_1);\n            destination.next(window_1);\n        }\n    };\n    WindowCountSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    };\n    WindowCountSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowCountSubscriber.prototype._unsubscribe = function () {\n        this.count = 0;\n        this.windows = null;\n    };\n    return WindowCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=windowCount.js.map\n\n/***/ }),\n\n/***/ 801:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar async_1 = __webpack_require__(300);\nvar Subscriber_1 = __webpack_require__(9);\nvar isNumeric_1 = __webpack_require__(305);\nvar isScheduler_1 = __webpack_require__(187);\nfunction windowTime(windowTimeSpan) {\n    var scheduler = async_1.async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler_1.isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler_1.isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric_1.isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler_1.isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric_1.isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nexports.windowTime = windowTime;\nvar WindowTimeOperator = (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = (function (_super) {\n    __extends(CountedSubject, _super);\n    function CountedSubject() {\n        _super.apply(this, arguments);\n        this._numberOfNextedValues = 0;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject_1.Subject));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowTimeSubscriber = (function (_super) {\n    __extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        var window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n\n/***/ }),\n\n/***/ 802:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar Subscription_1 = __webpack_require__(44);\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };\n}\nexports.windowToggle = windowToggle;\nvar WindowToggleOperator = (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowToggleSubscriber = (function (_super) {\n    __extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n            if (closingNotifier === errorObject_1.errorObject) {\n                return this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var window_1 = new Subject_1.Subject();\n                var subscription = new Subscription_1.Subscription();\n                var context = { window: window_1, subscription: subscription };\n                this.contexts.push(context);\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                if (innerSubscription.closed) {\n                    this.closeWindow(this.contexts.length - 1);\n                }\n                else {\n                    innerSubscription.context = context;\n                    subscription.add(innerSubscription);\n                }\n                this.destination.next(window_1);\n            }\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map\n\n/***/ }),\n\n/***/ 803:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = __webpack_require__(29);\nvar tryCatch_1 = __webpack_require__(129);\nvar errorObject_1 = __webpack_require__(91);\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nfunction windowWhen(closingSelector) {\n    return function windowWhenOperatorFunction(source) {\n        return source.lift(new WindowOperator(closingSelector));\n    };\n}\nexports.windowWhen = windowWhen;\nvar WindowOperator = (function () {\n    function WindowOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.closingSelector = closingSelector;\n        this.openWindow();\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    };\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\n        if (innerSub === void 0) { innerSub = null; }\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var window = this.window = new Subject_1.Subject();\n        this.destination.next(window);\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            var err = errorObject_1.errorObject.e;\n            this.destination.error(err);\n            this.window.error(err);\n        }\n        else {\n            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n        }\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowWhen.js.map\n\n/***/ }),\n\n/***/ 804:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(54);\nvar subscribeToResult_1 = __webpack_require__(53);\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var project;\n        if (typeof args[args.length - 1] === 'function') {\n            project = args.pop();\n        }\n        var observables = args;\n        return source.lift(new WithLatestFromOperator(observables, project));\n    };\n}\nexports.withLatestFrom = withLatestFrom;\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n/***/ }),\n\n/***/ 805:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar zip_1 = __webpack_require__(719);\nfunction zipAll(project) {\n    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };\n}\nexports.zipAll = zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 1-74d469d659b90d80f1e3.js","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Injectable, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nvar hasV8BreakIterator = (typeof (Intl) !== 'undefined' && (/** @type {?} */ (Intl)).v8BreakIterator);\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nvar Platform = /** @class */ (function () {\n    function Platform() {\n        /**\n         * Whether the Angular application is being rendered in the browser.\n         */\n        this.isBrowser = typeof document === 'object' && !!document;\n        /**\n         * Whether the current browser is Microsoft Edge.\n         */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Microsoft Trident.\n         */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        /**\n         * Whether the current rendering engine is Blink.\n         */\n        this.BLINK = this.isBrowser &&\n            (!!((/** @type {?} */ (window)).chrome || hasV8BreakIterator) && !!CSS && !this.EDGE && !this.TRIDENT);\n        /**\n         * Whether the current rendering engine is WebKit.\n         */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n        /**\n         * Whether the current platform is Apple iOS.\n         */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n            !(/** @type {?} */ (window)).MSStream;\n        /**\n         * Whether the current browser is Firefox.\n         */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /**\n         * Whether the current platform is Android.\n         */\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        /**\n         * Whether the current browser is Safari.\n         */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n    Platform.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Platform.ctorParameters = function () { return []; };\n    return Platform;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Cached result of whether the user's browser supports passive event listeners.\n */\nvar supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n * @return {?}\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', /** @type {?} */ ((null)), Object.defineProperty({}, 'passive', {\n                get: function () { return supportsPassiveEvents = true; }\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Cached result Set of input types support by the current browser.\n */\nvar supportedInputTypes;\n/**\n * Types of `<input>` that *might* be supported.\n */\nvar candidateInputTypes = [\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/**\n * @return {?} The input types supported by this browser.\n */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    var /** @type {?} */ featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar PlatformModule = /** @class */ (function () {\n    function PlatformModule() {\n    }\n    PlatformModule.decorators = [\n        { type: NgModule, args: [{\n                    providers: [Platform]\n                },] },\n    ];\n    /** @nocollapse */\n    PlatformModule.ctorParameters = function () { return []; };\n    return PlatformModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Platform, supportsPassiveEventListeners, getSupportedInputTypes, PlatformModule };\n//# sourceMappingURL=platform.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/platform.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, Injectable, NgModule, NgZone, Optional, SkipSelf } from '@angular/core';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\nimport { of } from 'rxjs/observable/of';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { auditTime } from 'rxjs/operators/auditTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { merge } from 'rxjs/observable/merge';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the scrolling events by default.\n */\nvar DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nvar ScrollDispatcher = /** @class */ (function () {\n    function ScrollDispatcher(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * Subject for notifying that a registered scrollable reference element has been scrolled.\n         */\n        this._scrolled = new Subject();\n        /**\n         * Keeps track of the global `scroll` and `resize` subscriptions.\n         */\n        this._globalSubscription = null;\n        /**\n         * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.\n         */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.register = /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param {?} scrollable Scrollable instance to be registered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var _this = this;\n        var /** @type {?} */ scrollSubscription = scrollable.elementScrolled()\n            .subscribe(function () { return _this._scrolled.next(scrollable); });\n        this.scrollContainers.set(scrollable, scrollSubscription);\n    };\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.deregister = /**\n     * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param {?} scrollable Scrollable instance to be deregistered.\n     * @return {?}\n     */\n    function (scrollable) {\n        var /** @type {?} */ scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    };\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.scrolled = /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     * @param {?=} auditTimeInMs\n     * @return {?}\n     */\n    function (auditTimeInMs) {\n        var _this = this;\n        if (auditTimeInMs === void 0) { auditTimeInMs = DEFAULT_SCROLL_TIME; }\n        return this._platform.isBrowser ? Observable.create(function (observer) {\n            if (!_this._globalSubscription) {\n                _this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            var /** @type {?} */ subscription = auditTimeInMs > 0 ?\n                _this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n                _this._scrolled.subscribe(observer);\n            _this._scrolledCount++;\n            return function () {\n                subscription.unsubscribe();\n                _this._scrolledCount--;\n                if (!_this._scrolledCount) {\n                    _this._removeGlobalListener();\n                }\n            };\n        }) : of();\n    };\n    /**\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._removeGlobalListener();\n        this.scrollContainers.forEach(function (_, container) { return _this.deregister(container); });\n    };\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.ancestorScrolled = /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param {?} elementRef Element whose ancestors to listen for.\n     * @param {?=} auditTimeInMs Time to throttle the scroll events.\n     * @return {?}\n     */\n    function (elementRef, auditTimeInMs) {\n        var /** @type {?} */ ancestors = this.getAncestorScrollContainers(elementRef);\n        return this.scrolled(auditTimeInMs).pipe(filter(function (target) {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    };\n    /** Returns all registered Scrollables that contain the provided element. */\n    /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype.getAncestorScrollContainers = /**\n     * Returns all registered Scrollables that contain the provided element.\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (elementRef) {\n        var _this = this;\n        var /** @type {?} */ scrollingContainers = [];\n        this.scrollContainers.forEach(function (_subscription, scrollable) {\n            if (_this._scrollableContainsElement(scrollable, elementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    };\n    /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._scrollableContainsElement = /**\n     * Returns true if the element is contained within the provided Scrollable.\n     * @param {?} scrollable\n     * @param {?} elementRef\n     * @return {?}\n     */\n    function (scrollable, elementRef) {\n        var /** @type {?} */ element = elementRef.nativeElement;\n        var /** @type {?} */ scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while (element = element.parentElement);\n        return false;\n    };\n    /**\n     * Sets up the global scroll listeners.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._addGlobalListener = /**\n     * Sets up the global scroll listeners.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._globalSubscription = this._ngZone.runOutsideAngular(function () {\n            return fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });\n        });\n    };\n    /**\n     * Cleans up the global scroll listener.\n     * @return {?}\n     */\n    ScrollDispatcher.prototype._removeGlobalListener = /**\n     * Cleans up the global scroll listener.\n     * @return {?}\n     */\n    function () {\n        if (this._globalSubscription) {\n            this._globalSubscription.unsubscribe();\n            this._globalSubscription = null;\n        }\n    };\n    ScrollDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollDispatcher.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return ScrollDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new ScrollDispatcher(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar SCROLL_DISPATCHER_PROVIDER = {\n    // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n    provide: ScrollDispatcher,\n    deps: [[new Optional(), new SkipSelf(), ScrollDispatcher], NgZone, Platform],\n    useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nvar CdkScrollable = /** @class */ (function () {\n    function CdkScrollable(_elementRef, _scroll, _ngZone) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._scroll = _scroll;\n        this._ngZone = _ngZone;\n        this._elementScrolled = new Subject();\n        this._scrollListener = function (event) { return _this._elementScrolled.next(event); };\n    }\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._ngZone.runOutsideAngular(function () {\n            _this.getElementRef().nativeElement.addEventListener('scroll', _this._scrollListener);\n        });\n        this._scroll.register(this);\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._scroll.deregister(this);\n        if (this._scrollListener) {\n            this.getElementRef().nativeElement.removeEventListener('scroll', this._scrollListener);\n        }\n    };\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     */\n    /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    CdkScrollable.prototype.elementScrolled = /**\n     * Returns observable that emits when a scroll event is fired on the host element.\n     * @return {?}\n     */\n    function () {\n        return this._elementScrolled.asObservable();\n    };\n    /**\n     * @return {?}\n     */\n    CdkScrollable.prototype.getElementRef = /**\n     * @return {?}\n     */\n    function () {\n        return this._elementRef;\n    };\n    CdkScrollable.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkScrollable.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: ScrollDispatcher, },\n        { type: NgZone, },\n    ]; };\n    return CdkScrollable;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Time in ms to throttle the resize events by default.\n */\nvar DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * \\@docs-private\n */\nvar ViewportRuler = /** @class */ (function () {\n    function ViewportRuler(platform, ngZone) {\n        var _this = this;\n        this._change = platform.isBrowser ? ngZone.runOutsideAngular(function () {\n            return merge(fromEvent(window, 'resize'), fromEvent(window, 'orientationchange'));\n        }) : of();\n        this._invalidateCache = this.change().subscribe(function () { return _this._updateViewportSize(); });\n    }\n    /**\n     * @return {?}\n     */\n    ViewportRuler.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._invalidateCache.unsubscribe();\n    };\n    /** Returns the viewport's width and height. */\n    /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportSize = /**\n     * Returns the viewport's width and height.\n     * @return {?}\n     */\n    function () {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        return { width: this._viewportSize.width, height: this._viewportSize.height };\n    };\n    /** Gets a ClientRect for the viewport's bounds. */\n    /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportRect = /**\n     * Gets a ClientRect for the viewport's bounds.\n     * @return {?}\n     */\n    function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var /** @type {?} */ scrollPosition = this.getViewportScrollPosition();\n        var _a = this.getViewportSize(), width = _a.width, height = _a.height;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /** Gets the (top, left) scroll position of the viewport. */\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @return {?}\n     */\n    function () {\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var /** @type {?} */ documentRect = document.documentElement.getBoundingClientRect();\n        var /** @type {?} */ top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n            document.documentElement.scrollTop || 0;\n        var /** @type {?} */ left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n            document.documentElement.scrollLeft || 0;\n        return { top: top, left: left };\n    };\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param throttle Time in milliseconds to throttle the stream.\n     */\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    ViewportRuler.prototype.change = /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * @param {?=} throttleTime\n     * @return {?}\n     */\n    function (throttleTime) {\n        if (throttleTime === void 0) { throttleTime = DEFAULT_RESIZE_TIME; }\n        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n    };\n    /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    ViewportRuler.prototype._updateViewportSize = /**\n     * Updates the cached viewport size.\n     * @return {?}\n     */\n    function () {\n        this._viewportSize = { width: window.innerWidth, height: window.innerHeight };\n    };\n    ViewportRuler.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ViewportRuler.ctorParameters = function () { return [\n        { type: Platform, },\n        { type: NgZone, },\n    ]; };\n    return ViewportRuler;\n}());\n/**\n * \\@docs-private\n * @param {?} parentRuler\n * @param {?} platform\n * @param {?} ngZone\n * @return {?}\n */\nfunction VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {\n    return parentRuler || new ViewportRuler(platform, ngZone);\n}\n/**\n * \\@docs-private\n */\nvar VIEWPORT_RULER_PROVIDER = {\n    // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.\n    provide: ViewportRuler,\n    deps: [[new Optional(), new SkipSelf(), ViewportRuler], Platform, NgZone],\n    useFactory: VIEWPORT_RULER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar ScrollDispatchModule = /** @class */ (function () {\n    function ScrollDispatchModule() {\n    }\n    ScrollDispatchModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [PlatformModule],\n                    exports: [CdkScrollable],\n                    declarations: [CdkScrollable],\n                    providers: [SCROLL_DISPATCHER_PROVIDER],\n                },] },\n    ];\n    /** @nocollapse */\n    ScrollDispatchModule.ctorParameters = function () { return []; };\n    return ScrollDispatchModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DEFAULT_SCROLL_TIME, ScrollDispatcher, SCROLL_DISPATCHER_PROVIDER_FACTORY, SCROLL_DISPATCHER_PROVIDER, CdkScrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIEWPORT_RULER_PROVIDER_FACTORY, VIEWPORT_RULER_PROVIDER, ScrollDispatchModule };\n//# sourceMappingURL=scrolling.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/scrolling.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { ComponentFactoryResolver, Directive, EventEmitter, Input, NgModule, Output, TemplateRef, ViewContainerRef } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-private\n * @return {?}\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface that can be used to generically type a class.\n * @record\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n */\nvar Portal = /** @class */ (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.attach = /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        if (host == null) {\n            throwNullPortalOutletError();\n        }\n        if (host.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return /** @type {?} */ (host.attach(this));\n    };\n    /** Detach this portal from its host */\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    Portal.prototype.detach = /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ host = this._attachedHost;\n        if (host == null) {\n            throwNoPortalAttachedError();\n        }\n        else {\n            this._attachedHost = null;\n            host.detach();\n        }\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: /**\n         * Whether this portal is attached to a host.\n         * @return {?}\n         */\n        function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    Portal.prototype.setAttachedHost = /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar ComponentPortal = /** @class */ (function (_super) {\n    __extends(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        var _this = _super.call(this) || this;\n        _this.component = component;\n        _this.viewContainerRef = viewContainerRef;\n        _this.injector = injector;\n        return _this;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar TemplatePortal = /** @class */ (function (_super) {\n    __extends(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef, context) {\n        var _this = _super.call(this) || this;\n        _this.templateRef = template;\n        _this.viewContainerRef = viewContainerRef;\n        _this.context = context;\n        return _this;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    TemplatePortal.prototype.attach = /**\n     * Attach the the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    function (host, context) {\n        if (context === void 0) { context = this.context; }\n        this.context = context;\n        return _super.prototype.attach.call(this, host);\n    };\n    /**\n     * @return {?}\n     */\n    TemplatePortal.prototype.detach = /**\n     * @return {?}\n     */\n    function () {\n        this.context = undefined;\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * A `PortalOutlet` is an space that can contain a single `Portal`.\n * @record\n */\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\nvar BasePortalOutlet = /** @class */ (function () {\n    function BasePortalOutlet() {\n        /**\n         * Whether this host has already been permanently disposed.\n         */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.hasAttached = /**\n     * Whether this host has an attached portal.\n     * @return {?}\n     */\n    function () {\n        return !!this._attachedPortal;\n    };\n    /** Attaches a portal. */\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.attach = /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n    function (portal) {\n        if (!portal) {\n            throwNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throwPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throwPortalOutletAlreadyDisposedError();\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throwUnknownPortalTypeError();\n    };\n    /** Detaches a previously attached portal. */\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.detach = /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n    function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    };\n    /** Permanently dispose of this portal host. */\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.dispose = /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n    function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    BasePortalOutlet.prototype.setDisposeFn = /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        this._disposeFn = fn;\n    };\n    /**\n     * @return {?}\n     */\n    BasePortalOutlet.prototype._invokeDisposeFn = /**\n     * @return {?}\n     */\n    function () {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    return BasePortalOutlet;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nvar DomPortalOutlet = /** @class */ (function (_super) {\n    __extends(DomPortalOutlet, _super);\n    function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n        var _this = _super.call(this) || this;\n        _this.outletElement = outletElement;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._appRef = _appRef;\n        _this._defaultInjector = _defaultInjector;\n        return _this;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    DomPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @template T\n     * @param {?} portal Portal to be attached\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n            this.setDisposeFn(function () { return componentRef.destroy(); });\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(function () {\n                _this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        return componentRef;\n    };\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    DomPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ viewContainer = portal.viewContainerRef;\n        var /** @type {?} */ viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        viewRef.detectChanges();\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(function (rootNode) { return _this.outletElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var /** @type {?} */ index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    };\n    /**\n     * Clears out a portal from the DOM.\n     */\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    DomPortalOutlet.prototype.dispose = /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        if (this.outletElement.parentNode != null) {\n            this.outletElement.parentNode.removeChild(this.outletElement);\n        }\n    };\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    DomPortalOutlet.prototype._getComponentRootNode = /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @param {?} componentRef\n     * @return {?}\n     */\n    function (componentRef) {\n        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);\n    };\n    return DomPortalOutlet;\n}(BasePortalOutlet));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\nvar CdkPortal = /** @class */ (function (_super) {\n    __extends(CdkPortal, _super);\n    function CdkPortal(templateRef, viewContainerRef) {\n        return _super.call(this, templateRef, viewContainerRef) || this;\n    }\n    CdkPortal.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-portal], [cdkPortal], [portal]',\n                    exportAs: 'cdkPortal',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortal.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n    ]; };\n    return CdkPortal;\n}(TemplatePortal));\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\nvar CdkPortalOutlet = /** @class */ (function (_super) {\n    __extends(CdkPortalOutlet, _super);\n    function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n        var _this = _super.call(this) || this;\n        _this._componentFactoryResolver = _componentFactoryResolver;\n        _this._viewContainerRef = _viewContainerRef;\n        /**\n         * Whether the portal component is initialized.\n         */\n        _this._isInitialized = false;\n        _this.attached = new EventEmitter();\n        return _this;\n    }\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortal\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"_deprecatedPortalHost\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.portal; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) { this.portal = v; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"portal\", {\n        /** Portal associated with the Portal outlet. */\n        get: /**\n         * Portal associated with the Portal outlet.\n         * @return {?}\n         */\n        function () {\n            return this._attachedPortal;\n        },\n        set: /**\n         * @param {?} portal\n         * @return {?}\n         */\n        function (portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                _super.prototype.detach.call(this);\n            }\n            if (portal) {\n                _super.prototype.attach.call(this, portal);\n            }\n            this._attachedPortal = portal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkPortalOutlet.prototype, \"attachedRef\", {\n        /** Component or view reference that is attached to the portal. */\n        get: /**\n         * Component or view reference that is attached to the portal.\n         * @return {?}\n         */\n        function () {\n            return this._attachedRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    CdkPortalOutlet.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        _super.prototype.dispose.call(this);\n        this._attachedPortal = null;\n        this._attachedRef = null;\n    };\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @param portal Portal to be attached to the portal outlet.\n     * @returns Reference to the created component.\n     */\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    CdkPortalOutlet.prototype.attachComponentPortal = /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n    function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalOutlet.\n        var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });\n        this._attachedPortal = portal;\n        this._attachedRef = ref;\n        this.attached.emit(ref);\n        return ref;\n    };\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    CdkPortalOutlet.prototype.attachTemplatePortal = /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n    function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        var /** @type {?} */ viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n        _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });\n        this._attachedPortal = portal;\n        this._attachedRef = viewRef;\n        this.attached.emit(viewRef);\n        return viewRef;\n    };\n    CdkPortalOutlet.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',\n                    exportAs: 'cdkPortalOutlet, cdkPortalHost',\n                    inputs: ['portal: cdkPortalOutlet']\n                },] },\n    ];\n    /** @nocollapse */\n    CdkPortalOutlet.ctorParameters = function () { return [\n        { type: ComponentFactoryResolver, },\n        { type: ViewContainerRef, },\n    ]; };\n    CdkPortalOutlet.propDecorators = {\n        \"_deprecatedPortal\": [{ type: Input, args: ['portalHost',] },],\n        \"_deprecatedPortalHost\": [{ type: Input, args: ['cdkPortalHost',] },],\n        \"attached\": [{ type: Output, args: ['attached',] },],\n    };\n    return CdkPortalOutlet;\n}(BasePortalOutlet));\nvar PortalModule = /** @class */ (function () {\n    function PortalModule() {\n    }\n    PortalModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [CdkPortal, CdkPortalOutlet],\n                    declarations: [CdkPortal, CdkPortalOutlet],\n                },] },\n    ];\n    /** @nocollapse */\n    PortalModule.ctorParameters = function () { return []; };\n    return PortalModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\nvar PortalInjector = /** @class */ (function () {\n    function PortalInjector(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    PortalInjector.prototype.get = /**\n     * @param {?} token\n     * @param {?=} notFoundValue\n     * @return {?}\n     */\n    function (token, notFoundValue) {\n        var /** @type {?} */ value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return PortalInjector;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DomPortalOutlet as DomPortalHost, CdkPortalOutlet as PortalHostDirective, CdkPortal as TemplatePortalDirective, BasePortalOutlet as BasePortalHost, Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, DomPortalOutlet, CdkPortal, CdkPortalOutlet, PortalModule, PortalInjector };\n//# sourceMappingURL=portal.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/portal.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Coerces a data-bound value (typically a string) to a boolean.\n * @param {?} value\n * @return {?}\n */\nfunction coerceBooleanProperty(value) {\n    return value != null && \"\" + value !== 'false';\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @param {?} value\n * @param {?=} fallbackValue\n * @return {?}\n */\nfunction coerceNumberProperty(value, fallbackValue) {\n    if (fallbackValue === void 0) { fallbackValue = 0; }\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * \\@docs-private\n * @param {?} value\n * @return {?}\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(/** @type {?} */ (value))) && !isNaN(Number(value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { coerceBooleanProperty, coerceNumberProperty, _isNumberValue, coerceArray };\n//# sourceMappingURL=coercion.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/coercion.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationRef, ComponentFactoryResolver, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, SkipSelf, TemplateRef, ViewContainerRef } from '@angular/core';\nimport { CdkScrollable, ScrollDispatchModule, ScrollDispatcher, VIEWPORT_RULER_PROVIDER, ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport { BidiModule, Directionality } from '@angular/cdk/bidi';\nimport { DomPortalOutlet, PortalModule, TemplatePortal } from '@angular/cdk/portal';\nimport { __assign, __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { take } from 'rxjs/operators/take';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { filter } from 'rxjs/operators/filter';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Scroll strategy that doesn't do anything.\n */\nvar NoopScrollStrategy = /** @class */ (function () {\n    function NoopScrollStrategy() {\n    }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.enable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.disable = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    /** Does nothing, as this scroll strategy is a no-op. */\n    /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    NoopScrollStrategy.prototype.attach = /**\n     * Does nothing, as this scroll strategy is a no-op.\n     * @return {?}\n     */\n    function () { };\n    return NoopScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Initial configuration used when creating an overlay.\n */\nvar OverlayConfig = /** @class */ (function () {\n    function OverlayConfig(config) {\n        var _this = this;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /**\n         * Custom class to add to the overlay pane.\n         */\n        this.panelClass = '';\n        /**\n         * Whether the overlay has a backdrop.\n         */\n        this.hasBackdrop = false;\n        /**\n         * Custom class to add to the backdrop\n         */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * The direction of the text in the overlay panel.\n         */\n        this.direction = 'ltr';\n        if (config) {\n            Object.keys(config)\n                .filter(function (key) { return typeof config[key] !== 'undefined'; })\n                .forEach(function (key) { return _this[key] = config[key]; });\n        }\n    }\n    return OverlayConfig;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/** Horizontal dimension of a connection point on the perimeter of the origin or overlay element. */\n/**\n * A connection point on the origin element.\n * @record\n */\n\n/**\n * A connection point on the overlay element.\n * @record\n */\n\n/**\n * The points of the origin element and the overlay element to connect.\n */\nvar ConnectionPositionPair = /** @class */ (function () {\n    function ConnectionPositionPair(origin, overlay, offsetX, offsetY) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  \\@docs-private\n */\nvar ScrollingVisibility = /** @class */ (function () {\n    function ScrollingVisibility() {\n    }\n    return ScrollingVisibility;\n}());\n/**\n * The change event emitted by the strategy when a fallback position is used.\n */\nvar ConnectedOverlayPositionChange = /** @class */ (function () {\n    function ConnectedOverlayPositionChange(connectionPair, /** @docs-private */\n        scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n    /** @nocollapse */\n    ConnectedOverlayPositionChange.ctorParameters = function () { return [\n        { type: ConnectionPositionPair, },\n        { type: ScrollingVisibility, decorators: [{ type: Optional },] },\n    ]; };\n    return ConnectedOverlayPositionChange;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Describes a strategy that will be used by an overlay to handle scroll events while it is open.\n * @record\n */\n\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n * @return {?}\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(\"Scroll strategy has already been attached.\");\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Config options for the CloseScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nvar CloseScrollStrategy = /** @class */ (function () {\n    function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /**\n         * Detaches the overlay ref and disables the scroll strategy.\n         */\n        this._detach = function () {\n            _this.disable();\n            if (_this._overlayRef.hasAttached()) {\n                _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables the closing of the attached overlay on scroll. */\n    /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.enable = /**\n     * Enables the closing of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (this._scrollSubscription) {\n            return;\n        }\n        var /** @type {?} */ stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(function () {\n                var /** @type {?} */ scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - _this._initialScrollPosition) > /** @type {?} */ ((/** @type {?} */ ((_this._config)).threshold))) {\n                    _this._detach();\n                }\n                else {\n                    _this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    };\n    /** Disables the closing the attached overlay on scroll. */\n    /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    CloseScrollStrategy.prototype.disable = /**\n     * Disables the closing the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return CloseScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nvar BlockScrollStrategy = /** @class */ (function () {\n    function BlockScrollStrategy(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @return {?}\n     */\n    function () { };\n    /** Blocks page-level scroll while the attached overlay is open. */\n    /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.enable = /**\n     * Blocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._canBeEnabled()) {\n            var /** @type {?} */ root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = -this._previousScrollPosition.left + \"px\";\n            root.style.top = -this._previousScrollPosition.top + \"px\";\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    };\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype.disable = /**\n     * Unblocks page-level scroll while the attached overlay is open.\n     * @return {?}\n     */\n    function () {\n        if (this._isEnabled) {\n            var /** @type {?} */ html = this._document.documentElement;\n            var /** @type {?} */ body = this._document.body;\n            var /** @type {?} */ previousHtmlScrollBehavior = html.style['scrollBehavior'] || '';\n            var /** @type {?} */ previousBodyScrollBehavior = body.style['scrollBehavior'] || '';\n            this._isEnabled = false;\n            html.style.left = this._previousHTMLStyles.left;\n            html.style.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            html.style['scrollBehavior'] = body.style['scrollBehavior'] = 'auto';\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            html.style['scrollBehavior'] = previousHtmlScrollBehavior;\n            body.style['scrollBehavior'] = previousBodyScrollBehavior;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    BlockScrollStrategy.prototype._canBeEnabled = /**\n     * @return {?}\n     */\n    function () {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        var /** @type {?} */ html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        var /** @type {?} */ body = this._document.body;\n        var /** @type {?} */ viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    };\n    return BlockScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is scrolled out of view\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(function (containerBounds) {\n        var /** @type {?} */ outsideAbove = element.bottom < containerBounds.top;\n        var /** @type {?} */ outsideBelow = element.top > containerBounds.bottom;\n        var /** @type {?} */ outsideLeft = element.right < containerBounds.left;\n        var /** @type {?} */ outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * \\@docs-private\n * @param {?} element Dimensions of the element (from getBoundingClientRect)\n * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @return {?} Whether the element is clipped\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(function (scrollContainerRect) {\n        var /** @type {?} */ clippedAbove = element.top < scrollContainerRect.top;\n        var /** @type {?} */ clippedBelow = element.bottom > scrollContainerRect.bottom;\n        var /** @type {?} */ clippedLeft = element.left < scrollContainerRect.left;\n        var /** @type {?} */ clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Config options for the RepositionScrollStrategy.\n * @record\n */\n\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nvar RepositionScrollStrategy = /** @class */ (function () {\n    function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.attach = /**\n     * Attaches this scroll strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        if (this._overlayRef) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    };\n    /** Enables repositioning of the attached overlay on scroll. */\n    /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.enable = /**\n     * Enables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._scrollSubscription) {\n            var /** @type {?} */ throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {\n                _this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (_this._config && _this._config.autoClose) {\n                    var /** @type {?} */ overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();\n                    var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    var /** @type {?} */ parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        _this.disable();\n                        _this._ngZone.run(function () { return _this._overlayRef.detach(); });\n                    }\n                }\n            });\n        }\n    };\n    /** Disables repositioning of the attached overlay on scroll. */\n    /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    RepositionScrollStrategy.prototype.disable = /**\n     * Disables repositioning of the attached overlay on scroll.\n     * @return {?}\n     */\n    function () {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    };\n    return RepositionScrollStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Options for how an overlay will handle scrolling.\n *\n * Users can provide a custom value for `ScrollStrategyOptions` to replace the default\n * behaviors. This class primarily acts as a factory for ScrollStrategy instances.\n */\nvar ScrollStrategyOptions = /** @class */ (function () {\n    function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n        var _this = this;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        /**\n         * Do nothing on scroll.\n         */\n        this.noop = function () { return new NoopScrollStrategy(); };\n        /**\n         * Close the overlay as soon as the user scrolls.\n         * @param config Configuration to be used inside the scroll strategy.\n         */\n        this.close = function (config) {\n            return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config);\n        };\n        /**\n         * Block scrolling.\n         */\n        this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };\n        /**\n         * Update the overlay's position on scroll.\n         * @param config Configuration to be used inside the scroll strategy.\n         * Allows debouncing the reposition calls.\n         */\n        this.reposition = function (config) {\n            return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config);\n        };\n        this._document = document;\n    }\n    ScrollStrategyOptions.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ScrollStrategyOptions.ctorParameters = function () { return [\n        { type: ScrollDispatcher, },\n        { type: ViewportRuler, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return ScrollStrategyOptions;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = /** @class */ (function () {\n    function OverlayRef(_portalOutlet, _pane, _config, _ngZone, _keyboardDispatcher, _document) {\n        this._portalOutlet = _portalOutlet;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._backdropElement = null;\n        this._backdropClick = new Subject();\n        this._attachments = new Subject();\n        this._detachments = new Subject();\n        /**\n         * Stream of keydown events dispatched to this overlay.\n         */\n        this._keydownEvents = new Subject();\n        if (_config.scrollStrategy) {\n            _config.scrollStrategy.attach(this);\n        }\n    }\n    Object.defineProperty(OverlayRef.prototype, \"overlayElement\", {\n        /** The overlay's HTML element */\n        get: /**\n         * The overlay's HTML element\n         * @return {?}\n         */\n        function () {\n            return this._pane;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(OverlayRef.prototype, \"backdropElement\", {\n        /** The overlay's backdrop HTML element. */\n        get: /**\n         * The overlay's backdrop HTML element.\n         * @return {?}\n         */\n        function () {\n            return this._backdropElement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    OverlayRef.prototype.attach = /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param {?} portal Portal instance to which to attach the overlay.\n     * @return {?} The portal attachment result.\n     */\n    function (portal) {\n        var _this = this;\n        var /** @type {?} */ attachResult = this._portalOutlet.attach(portal);\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.attach(this);\n        }\n        // Update the pane element with the given configuration.\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {\n            // The overlay could've been detached before the zone has stabilized.\n            if (_this.hasAttached()) {\n                _this.updatePosition();\n            }\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            if (Array.isArray(this._config.panelClass)) {\n                this._config.panelClass.forEach(function (cls) { return _this._pane.classList.add(cls); });\n            }\n            else {\n                this._pane.classList.add(this._config.panelClass);\n            }\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        return attachResult;\n    };\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    OverlayRef.prototype.detach = /**\n     * Detaches an overlay from a portal.\n     * @return {?} The portal detachment result.\n     */\n    function () {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._config.positionStrategy && this._config.positionStrategy.detach) {\n            this._config.positionStrategy.detach();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        var /** @type {?} */ detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking\n        this._keyboardDispatcher.remove(this);\n        return detachmentResult;\n    };\n    /** Cleans up the overlay from the DOM. */\n    /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    OverlayRef.prototype.dispose = /**\n     * Cleans up the overlay from the DOM.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ isAttached = this.hasAttached();\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.dispose();\n        }\n        if (this._config.scrollStrategy) {\n            this._config.scrollStrategy.disable();\n        }\n        this.detachBackdrop();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    };\n    /** Whether the overlay has attached content. */\n    /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    OverlayRef.prototype.hasAttached = /**\n     * Whether the overlay has attached content.\n     * @return {?}\n     */\n    function () {\n        return this._portalOutlet.hasAttached();\n    };\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    OverlayRef.prototype.backdropClick = /**\n     * Gets an observable that emits when the backdrop has been clicked.\n     * @return {?}\n     */\n    function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been attached. */\n    /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    OverlayRef.prototype.attachments = /**\n     * Gets an observable that emits when the overlay has been attached.\n     * @return {?}\n     */\n    function () {\n        return this._attachments.asObservable();\n    };\n    /** Gets an observable that emits when the overlay has been detached. */\n    /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachments = /**\n     * Gets an observable that emits when the overlay has been detached.\n     * @return {?}\n     */\n    function () {\n        return this._detachments.asObservable();\n    };\n    /** Gets an observable of keydown events targeted to this overlay. */\n    /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.keydownEvents = /**\n     * Gets an observable of keydown events targeted to this overlay.\n     * @return {?}\n     */\n    function () {\n        return this._keydownEvents.asObservable();\n    };\n    /** Gets the the current overlay configuration, which is immutable. */\n    /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    OverlayRef.prototype.getConfig = /**\n     * Gets the the current overlay configuration, which is immutable.\n     * @return {?}\n     */\n    function () {\n        return this._config;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    OverlayRef.prototype.updatePosition = /**\n     * Updates the position of the overlay based on the position strategy.\n     * @return {?}\n     */\n    function () {\n        if (this._config.positionStrategy) {\n            this._config.positionStrategy.apply();\n        }\n    };\n    /** Update the size properties of the overlay. */\n    /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    OverlayRef.prototype.updateSize = /**\n     * Update the size properties of the overlay.\n     * @param {?} sizeConfig\n     * @return {?}\n     */\n    function (sizeConfig) {\n        this._config = __assign({}, this._config, sizeConfig);\n        this._updateElementSize();\n    };\n    /** Sets the LTR/RTL direction for the overlay. */\n    /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    OverlayRef.prototype.setDirection = /**\n     * Sets the LTR/RTL direction for the overlay.\n     * @param {?} dir\n     * @return {?}\n     */\n    function (dir) {\n        this._config = __assign({}, this._config, { direction: dir });\n        this._updateElementDirection();\n    };\n    /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementDirection = /**\n     * Updates the text direction of the overlay panel.\n     * @return {?}\n     */\n    function () {\n        this._pane.setAttribute('dir', /** @type {?} */ ((this._config.direction)));\n    };\n    /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateElementSize = /**\n     * Updates the size of the overlay element based on the overlay config.\n     * @return {?}\n     */\n    function () {\n        if (this._config.width || this._config.width === 0) {\n            this._pane.style.width = formatCssUnit(this._config.width);\n        }\n        if (this._config.height || this._config.height === 0) {\n            this._pane.style.height = formatCssUnit(this._config.height);\n        }\n        if (this._config.minWidth || this._config.minWidth === 0) {\n            this._pane.style.minWidth = formatCssUnit(this._config.minWidth);\n        }\n        if (this._config.minHeight || this._config.minHeight === 0) {\n            this._pane.style.minHeight = formatCssUnit(this._config.minHeight);\n        }\n        if (this._config.maxWidth || this._config.maxWidth === 0) {\n            this._pane.style.maxWidth = formatCssUnit(this._config.maxWidth);\n        }\n        if (this._config.maxHeight || this._config.maxHeight === 0) {\n            this._pane.style.maxHeight = formatCssUnit(this._config.maxHeight);\n        }\n    };\n    /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    OverlayRef.prototype._togglePointerEvents = /**\n     * Toggles the pointer events for the overlay pane element.\n     * @param {?} enablePointer\n     * @return {?}\n     */\n    function (enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';\n    };\n    /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype._attachBackdrop = /**\n     * Attaches a backdrop for this overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._backdropElement.classList.add(this._config.backdropClass);\n        } /** @type {?} */\n        ((\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._pane.parentElement)).insertBefore(this._backdropElement, this._pane);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function (event) { return _this._backdropClick.next(event); });\n        // Add class to fade-in the backdrop after one frame.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(function () {\n                requestAnimationFrame(function () {\n                    if (_this._backdropElement) {\n                        _this._backdropElement.classList.add(showingClass);\n                    }\n                });\n            });\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    };\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    OverlayRef.prototype._updateStackingOrder = /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     * @return {?}\n     */\n    function () {\n        if (this._pane.nextSibling) {\n            /** @type {?} */ ((this._pane.parentNode)).appendChild(this._pane);\n        }\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    OverlayRef.prototype.detachBackdrop = /**\n     * Detaches the backdrop (if any) associated with the overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            var /** @type {?} */ finishDetach_1 = function () {\n                // It may not be attached to anything in certain cases (e.g. unit tests).\n                if (backdropToDetach && backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            };\n            backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n            if (this._config.backdropClass) {\n                backdropToDetach.classList.remove(this._config.backdropClass);\n            }\n            backdropToDetach.addEventListener('transitionend', finishDetach_1);\n            // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n            // In this case we make it unclickable and we try to remove it after a delay.\n            backdropToDetach.style.pointerEvents = 'none';\n            // Run this outside the Angular zone because there's nothing that Angular cares about.\n            // If it were to run inside the Angular zone, every test that used Overlay would have to be\n            // either async or fakeAsync.\n            this._ngZone.runOutsideAngular(function () {\n                setTimeout(finishDetach_1, 500);\n            });\n        }\n    };\n    return OverlayRef;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction formatCssUnit(value) {\n    return typeof value === 'string' ? /** @type {?} */ (value) : value + \"px\";\n}\n/**\n * Size properties for an overlay.\n * @record\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar ConnectedPositionStrategy = /** @class */ (function () {\n    function ConnectedPositionStrategy(originPos, overlayPos, _connectedTo, _viewportRuler, _document) {\n        this._connectedTo = _connectedTo;\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        /**\n         * Layout direction of the position strategy.\n         */\n        this._dir = 'ltr';\n        /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         */\n        this._offsetX = 0;\n        /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         */\n        this._offsetY = 0;\n        /**\n         * The Scrollable containers used to check scrollable view properties on position change.\n         */\n        this.scrollables = [];\n        /**\n         * Subscription to viewport resize events.\n         */\n        this._resizeSubscription = Subscription.EMPTY;\n        /**\n         * Ordered list of preferred positions, from most to least desirable.\n         */\n        this._preferredPositions = [];\n        /**\n         * Whether the position strategy is applied currently.\n         */\n        this._applied = false;\n        /**\n         * Whether the overlay position is locked.\n         */\n        this._positionLocked = false;\n        this._onPositionChange = new Subject();\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(originPos, overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"_isRtl\", {\n        /** Whether the we're dealing with an RTL context */\n        get: /**\n         * Whether the we're dealing with an RTL context\n         * @return {?}\n         */\n        function () {\n            return this._dir === 'rtl';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"onPositionChange\", {\n        /** Emits an event when the connection point changes. */\n        get: /**\n         * Emits an event when the connection point changes.\n         * @return {?}\n         */\n        function () {\n            return this._onPositionChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        get: /**\n         * Ordered list of preferred positions, from most to least desirable.\n         * @return {?}\n         */\n        function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach this position strategy to an overlay. */\n    /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.attach = /**\n     * Attach this position strategy to an overlay.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var _this = this;\n        this._overlayRef = overlayRef;\n        this._pane = overlayRef.overlayElement;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(function () { return _this.apply(); });\n    };\n    /** Disposes all resources used by the position strategy. */\n    /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.dispose = /**\n     * Disposes all resources used by the position strategy.\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n        this._onPositionChange.complete();\n    };\n    /** @docs-private */\n    /**\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.detach = /**\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        this._applied = false;\n        this._resizeSubscription.unsubscribe();\n    };\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.apply = /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * \\@docs-private\n     * @return {?}\n     */\n    function () {\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the  old position, in order to\n        // prevent the overlay from jumping around.\n        if (this._applied && this._positionLocked && this._lastConnectedPosition) {\n            this.recalculateLastPosition();\n            return;\n        }\n        this._applied = true;\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var /** @type {?} */ element = this._pane;\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = element.getBoundingClientRect();\n        // We use the viewport size to determine whether a position would go off-screen.\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        // Fallback point if none of the fallbacks fit into the viewport.\n        var /** @type {?} */ fallbackPoint;\n        var /** @type {?} */ fallbackPosition;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, pos);\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (overlayPoint.fitsInViewport) {\n                this._setElementPosition(element, overlayRect, overlayPoint, pos);\n                // Save the last connected position in case the position needs to be re-calculated.\n                this._lastConnectedPosition = pos;\n                return;\n            }\n            else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\n                fallbackPoint = overlayPoint;\n                fallbackPosition = pos;\n            }\n        }\n        // If none of the preferred positions were in the viewport, take the one\n        // with the largest visible area.\n        this._setElementPosition(element, overlayRect, /** @type {?} */ ((fallbackPoint)), /** @type {?} */ ((fallbackPosition)));\n    };\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.recalculateLastPosition = /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     * @return {?}\n     */\n    function () {\n        // If the overlay has never been positioned before, do nothing.\n        if (!this._lastConnectedPosition) {\n            return;\n        }\n        var /** @type {?} */ originRect = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayRect = this._pane.getBoundingClientRect();\n        var /** @type {?} */ viewportSize = this._viewportRuler.getViewportSize();\n        var /** @type {?} */ lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\n        var /** @type {?} */ originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\n        var /** @type {?} */ overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportSize, lastPosition);\n        this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\n    };\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withScrollableContainers = /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     * @param {?} scrollables\n     * @return {?}\n     */\n    function (scrollables) {\n        this.scrollables = scrollables;\n    };\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withFallbackPosition = /**\n     * Adds a new preferred fallback position.\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @param {?=} offsetX\n     * @param {?=} offsetY\n     * @return {?}\n     */\n    function (originPos, overlayPos, offsetX, offsetY) {\n        var /** @type {?} */ position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        return this;\n    };\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withDirection = /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param {?} dir New layout direction.\n     * @return {?}\n     */\n    function (dir) {\n        this._dir = dir;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetX = /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param {?} offset New offset in the X axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetX = offset;\n        return this;\n    };\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withOffsetY = /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param {?} offset New offset in the Y axis.\n     * @return {?}\n     */\n    function (offset) {\n        this._offsetY = offset;\n        return this;\n    };\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withLockedPosition = /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param {?} isLocked Whether the overlay should locked in.\n     * @return {?}\n     */\n    function (isLocked) {\n        this._positionLocked = isLocked;\n        return this;\n    };\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.withPositions = /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param {?} positions Position pairs to be set on the strategy.\n     * @return {?}\n     */\n    function (positions) {\n        this._preferredPositions = positions.slice();\n        return this;\n    };\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param origin Reference to the new origin element.\n     */\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype.setOrigin = /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param {?} origin Reference to the new origin element.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin.nativeElement;\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getStartX = /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getEndX = /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param {?} rect\n     * @return {?}\n     */\n    function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param {?} originRect\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originRect, pos) {\n        var /** @type {?} */ originStartX = this._getStartX(originRect);\n        var /** @type {?} */ originEndX = this._getEndX(originRect);\n        var /** @type {?} */ x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var /** @type {?} */ y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected, as well as how much of the element\n     * would be inside the viewport at that position.\n     * @param {?} originPoint\n     * @param {?} overlayRect\n     * @param {?} viewportSize\n     * @param {?} pos\n     * @return {?}\n     */\n    function (originPoint, overlayRect, viewportSize, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var /** @type {?} */ overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl ? 0 : -overlayRect.width;\n        }\n        var /** @type {?} */ overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) offsets of the overlay based on the current position.\n        var /** @type {?} */ offsetX = typeof pos.offsetX === 'undefined' ? this._offsetX : pos.offsetX;\n        var /** @type {?} */ offsetY = typeof pos.offsetY === 'undefined' ? this._offsetY : pos.offsetY;\n        // The (x, y) coordinates of the overlay.\n        var /** @type {?} */ x = originPoint.x + overlayStartX + offsetX;\n        var /** @type {?} */ y = originPoint.y + overlayStartY + offsetY;\n        // How much the overlay would overflow at this position, on each side.\n        var /** @type {?} */ leftOverflow = 0 - x;\n        var /** @type {?} */ rightOverflow = (x + overlayRect.width) - viewportSize.width;\n        var /** @type {?} */ topOverflow = 0 - y;\n        var /** @type {?} */ bottomOverflow = (y + overlayRect.height) - viewportSize.height;\n        // Visible parts of the element on each axis.\n        var /** @type {?} */ visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\n        var /** @type {?} */ visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\n        // The area of the element that's within the viewport.\n        var /** @type {?} */ visibleArea = visibleWidth * visibleHeight;\n        var /** @type {?} */ fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\n        return { x: x, y: y, fitsInViewport: fitsInViewport, visibleArea: visibleArea };\n    };\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._getScrollVisibility = /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     * @param {?} overlay\n     * @return {?}\n     */\n    function (overlay) {\n        var /** @type {?} */ originBounds = this._origin.getBoundingClientRect();\n        var /** @type {?} */ overlayBounds = overlay.getBoundingClientRect();\n        var /** @type {?} */ scrollContainerBounds = this.scrollables.map(function (s) { return s.getElementRef().nativeElement.getBoundingClientRect(); });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param {?} element\n     * @param {?} overlayRect\n     * @param {?} overlayPoint\n     * @param {?} pos\n     * @return {?}\n     */\n    function (element, overlayRect, overlayPoint, pos) {\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\n        // or below the origin and the direction in which the element will expand.\n        var /** @type {?} */ verticalStyleProperty = pos.overlayY === 'bottom' ? 'bottom' : 'top';\n        // When using `bottom`, we adjust the y position such that it is the distance\n        // from the bottom of the viewport rather than the top.\n        var /** @type {?} */ y = verticalStyleProperty === 'top' ?\n            overlayPoint.y :\n            this._document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        var /** @type {?} */ horizontalStyleProperty;\n        if (this._dir === 'rtl') {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        var /** @type {?} */ x = horizontalStyleProperty === 'left' ?\n            overlayPoint.x :\n            this._document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        ['top', 'bottom', 'left', 'right'].forEach(function (p) { return element.style[p] = null; });\n        element.style[verticalStyleProperty] = y + \"px\";\n        element.style[horizontalStyleProperty] = x + \"px\";\n        // Notify that the position has been changed along with its change properties.\n        var /** @type {?} */ scrollableViewProperties = this._getScrollVisibility(element);\n        var /** @type {?} */ positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\n        this._onPositionChange.next(positionChange);\n    };\n    /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    ConnectedPositionStrategy.prototype._subtractOverflows = /**\n     * Subtracts the amount that an element is overflowing on an axis from it's length.\n     * @param {?} length\n     * @param {...?} overflows\n     * @return {?}\n     */\n    function (length) {\n        var overflows = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            overflows[_i - 1] = arguments[_i];\n        }\n        return overflows.reduce(function (currentValue, currentOverflow) {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nvar GlobalPositionStrategy = /** @class */ (function () {\n    function GlobalPositionStrategy(_document) {\n        this._document = _document;\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n        /**\n         * A lazily-created wrapper for the overlay element that is used as a flex container.\n         */\n        this._wrapper = null;\n    }\n    /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.attach = /**\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        this._overlayRef = overlayRef;\n    };\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.top = /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New top offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.left = /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New left offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    };\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.bottom = /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param {?=} value New bottom offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.right = /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param {?=} value New right offset.\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    };\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     */\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.width = /**\n     * Sets the overlay width and clears any previously set width.\n     * @param {?=} value New width for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._width = value;\n        // When the width is 100%, we should reset the `left` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.left('0px');\n        }\n        return this;\n    };\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     */\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.height = /**\n     * Sets the overlay height and clears any previously set height.\n     * @param {?=} value New height for the overlay\n     * @return {?}\n     */\n    function (value) {\n        if (value === void 0) { value = ''; }\n        this._height = value;\n        // When the height is 100%, we should reset the `top` and the offset,\n        // in order to ensure that the element is flush against the viewport edge.\n        if (value === '100%') {\n            this.top('0px');\n        }\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param {?=} offset Overlay offset from the horizontal center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.centerVertically = /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param {?=} offset Overlay offset from the vertical center.\n     * @return {?}\n     */\n    function (offset) {\n        if (offset === void 0) { offset = ''; }\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     *\n     * @returns Resolved when the styles have been applied.\n     */\n    /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    GlobalPositionStrategy.prototype.apply = /**\n     * Apply the position to the element.\n     * \\@docs-private\n     *\n     * @return {?} Resolved when the styles have been applied.\n     */\n    function () {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef.hasAttached()) {\n            return;\n        }\n        var /** @type {?} */ element = this._overlayRef.overlayElement;\n        if (!this._wrapper && element.parentNode) {\n            this._wrapper = this._document.createElement('div'); /** @type {?} */\n            ((this._wrapper)).classList.add('cdk-global-overlay-wrapper');\n            element.parentNode.insertBefore(/** @type {?} */ ((this._wrapper)), element); /** @type {?} */\n            ((this._wrapper)).appendChild(element);\n        }\n        var /** @type {?} */ styles = element.style;\n        var /** @type {?} */ parentStyles = (/** @type {?} */ (element.parentNode)).style;\n        styles.position = this._cssPosition;\n        styles.marginTop = this._topOffset;\n        styles.marginLeft = this._leftOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        styles.width = this._width;\n        styles.height = this._height;\n        parentStyles.justifyContent = this._justifyContent;\n        parentStyles.alignItems = this._alignItems;\n    };\n    /** Removes the wrapper element from the DOM. */\n    /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    GlobalPositionStrategy.prototype.dispose = /**\n     * Removes the wrapper element from the DOM.\n     * @return {?}\n     */\n    function () {\n        if (this._wrapper && this._wrapper.parentNode) {\n            this._wrapper.parentNode.removeChild(this._wrapper);\n            this._wrapper = null;\n        }\n    };\n    return GlobalPositionStrategy;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Builder for overlay position strategy.\n */\nvar OverlayPositionBuilder = /** @class */ (function () {\n    function OverlayPositionBuilder(_viewportRuler, _document) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n    }\n    /**\n     * Creates a global position strategy.\n     */\n    /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.global = /**\n     * Creates a global position strategy.\n     * @return {?}\n     */\n    function () {\n        return new GlobalPositionStrategy(this._document);\n    };\n    /**\n     * Creates a relative position strategy.\n     * @param elementRef\n     * @param originPos\n     * @param overlayPos\n     */\n    /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    OverlayPositionBuilder.prototype.connectedTo = /**\n     * Creates a relative position strategy.\n     * @param {?} elementRef\n     * @param {?} originPos\n     * @param {?} overlayPos\n     * @return {?}\n     */\n    function (elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);\n    };\n    OverlayPositionBuilder.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayPositionBuilder.ctorParameters = function () { return [\n        { type: ViewportRuler, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayPositionBuilder;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Service for dispatching keyboard events that land on the body to appropriate overlay ref,\n * if any. It maintains a list of attached overlays to determine best suited overlay based\n * on event target and order of overlay opens.\n */\nvar OverlayKeyboardDispatcher = /** @class */ (function () {\n    function OverlayKeyboardDispatcher(_document) {\n        this._document = _document;\n        /**\n         * Currently attached overlays in the order they were attached.\n         */\n        this._attachedOverlays = [];\n    }\n    /**\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._unsubscribeFromKeydownEvents();\n    };\n    /** Add a new overlay to the list of attached overlay refs. */\n    /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.add = /**\n     * Add a new overlay to the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        // Lazily start dispatcher once first overlay is added\n        if (!this._keydownEventSubscription) {\n            this._subscribeToKeydownEvents();\n        }\n        this._attachedOverlays.push(overlayRef);\n    };\n    /** Remove an overlay from the list of attached overlay refs. */\n    /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype.remove = /**\n     * Remove an overlay from the list of attached overlay refs.\n     * @param {?} overlayRef\n     * @return {?}\n     */\n    function (overlayRef) {\n        var /** @type {?} */ index = this._attachedOverlays.indexOf(overlayRef);\n        if (index > -1) {\n            this._attachedOverlays.splice(index, 1);\n        }\n        // Remove the global listener once there are no more overlays.\n        if (this._attachedOverlays.length === 0) {\n            this._unsubscribeFromKeydownEvents();\n        }\n    };\n    /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._subscribeToKeydownEvents = /**\n     * Subscribe to keydown events that land on the body and dispatch those\n     * events to the appropriate overlay.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ bodyKeydownEvents = fromEvent(this._document.body, 'keydown', true);\n        this._keydownEventSubscription = bodyKeydownEvents.pipe(filter(function () { return !!_this._attachedOverlays.length; })).subscribe(function (event) {\n            // Dispatch keydown event to the correct overlay.\n            // Dispatch keydown event to the correct overlay.\n            _this._selectOverlayFromEvent(event)._keydownEvents.next(event);\n        });\n    };\n    /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._unsubscribeFromKeydownEvents = /**\n     * Removes the global keydown subscription.\n     * @return {?}\n     */\n    function () {\n        if (this._keydownEventSubscription) {\n            this._keydownEventSubscription.unsubscribe();\n            this._keydownEventSubscription = null;\n        }\n    };\n    /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    OverlayKeyboardDispatcher.prototype._selectOverlayFromEvent = /**\n     * Select the appropriate overlay from a keydown event.\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // Check if any overlays contain the event\n        var /** @type {?} */ targetedOverlay = this._attachedOverlays.find(function (overlay) {\n            return overlay.overlayElement === event.target ||\n                overlay.overlayElement.contains(/** @type {?} */ (event.target));\n        });\n        // Use the overlay if it exists, otherwise choose the most recently attached one\n        return targetedOverlay || this._attachedOverlays[this._attachedOverlays.length - 1];\n    };\n    OverlayKeyboardDispatcher.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayKeyboardDispatcher.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayKeyboardDispatcher;\n}());\n/**\n * \\@docs-private\n * @param {?} dispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {\n    return dispatcher || new OverlayKeyboardDispatcher(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {\n    // If there is already an OverlayKeyboardDispatcher available, use that.\n    // Otherwise, provide a new one.\n    provide: OverlayKeyboardDispatcher,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayKeyboardDispatcher],\n        /** @type {?} */ (\n        // Coerce to `InjectionToken` so that the `deps` match the \"shape\"\n        // of the type expected by Angular\n        DOCUMENT)\n    ],\n    useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Container inside which all overlays will render.\n */\nvar OverlayContainer = /** @class */ (function () {\n    function OverlayContainer(_document) {\n        this._document = _document;\n    }\n    /**\n     * @return {?}\n     */\n    OverlayContainer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._containerElement && this._containerElement.parentNode) {\n            this._containerElement.parentNode.removeChild(this._containerElement);\n        }\n    };\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns the container element\n     */\n    /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = /**\n     * This method returns the overlay container element. It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @return {?} the container element\n     */\n    function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     */\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    OverlayContainer.prototype._createContainer = /**\n     * Create the overlay container element, which is simply a div\n     * with the 'cdk-overlay-container' class on the document body.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ container = this._document.createElement('div');\n        container.classList.add('cdk-overlay-container');\n        this._document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    OverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    OverlayContainer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return OverlayContainer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentContainer\n * @param {?} _document\n * @return {?}\n */\nfunction OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {\n    return parentContainer || new OverlayContainer(_document);\n}\n/**\n * \\@docs-private\n */\nvar OVERLAY_CONTAINER_PROVIDER = {\n    // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.\n    provide: OverlayContainer,\n    deps: [\n        [new Optional(), new SkipSelf(), OverlayContainer],\n        /** @type {?} */ (DOCUMENT // We need to use the InjectionToken somewhere to keep TS happy\n        ) // We need to use the InjectionToken somewhere to keep TS happy\n    ],\n    useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Next overlay unique ID.\n */\nvar nextUniqueId = 0;\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.\n */\nvar Overlay = /** @class */ (function () {\n    function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _appRef, _injector, _ngZone, _document) {\n        this.scrollStrategies = scrollStrategies;\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._appRef = _appRef;\n        this._injector = _injector;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates an overlay.\n     * @param config Configuration applied to the overlay.\n     * @returns Reference to the created overlay.\n     */\n    /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    Overlay.prototype.create = /**\n     * Creates an overlay.\n     * @param {?=} config Configuration applied to the overlay.\n     * @return {?} Reference to the created overlay.\n     */\n    function (config) {\n        var /** @type {?} */ pane = this._createPaneElement();\n        var /** @type {?} */ portalOutlet = this._createPortalOutlet(pane);\n        return new OverlayRef(portalOutlet, pane, new OverlayConfig(config), this._ngZone, this._keyboardDispatcher, this._document);\n    };\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @returns An overlay position builder.\n     */\n    /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    Overlay.prototype.position = /**\n     * Gets a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     * @return {?} An overlay position builder.\n     */\n    function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    Overlay.prototype._createPaneElement = /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @return {?} Newly-created pane element\n     */\n    function () {\n        var /** @type {?} */ pane = this._document.createElement('div');\n        pane.id = \"cdk-overlay-\" + nextUniqueId++;\n        pane.classList.add('cdk-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    Overlay.prototype._createPortalOutlet = /**\n     * Create a DomPortalOutlet into which the overlay content can be loaded.\n     * @param {?} pane The DOM element to turn into a portal outlet.\n     * @return {?} A portal outlet for the given DOM element.\n     */\n    function (pane) {\n        return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);\n    };\n    Overlay.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Overlay.ctorParameters = function () { return [\n        { type: ScrollStrategyOptions, },\n        { type: OverlayContainer, },\n        { type: ComponentFactoryResolver, },\n        { type: OverlayPositionBuilder, },\n        { type: OverlayKeyboardDispatcher, },\n        { type: ApplicationRef, },\n        { type: Injector, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return Overlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Default set of positions for the overlay. Follows the behavior of a dropdown.\n */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),\n    new ConnectionPositionPair({ originX: 'end', originY: 'bottom' }, { overlayX: 'end', overlayY: 'top' }),\n];\n/**\n * Injection token that determines the scroll handling while the connected overlay is open.\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken('cdk-connected-overlay-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition(); };\n}\n/**\n * \\@docs-private\n */\nvar CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar CdkOverlayOrigin = /** @class */ (function () {\n    function CdkOverlayOrigin(elementRef) {\n        this.elementRef = elementRef;\n    }\n    CdkOverlayOrigin.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',\n                    exportAs: 'cdkOverlayOrigin',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkOverlayOrigin.ctorParameters = function () { return [\n        { type: ElementRef, },\n    ]; };\n    return CdkOverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar CdkConnectedOverlay = /** @class */ (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, _scrollStrategy, _dir) {\n        this._overlay = _overlay;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._hasBackdrop = false;\n        this._backdropSubscription = Subscription.EMPTY;\n        this._offsetX = 0;\n        this._offsetY = 0;\n        /**\n         * Strategy to be used when handling scroll events while the overlay is open.\n         */\n        this.scrollStrategy = this._scrollStrategy();\n        /**\n         * Whether the overlay is open.\n         */\n        this.open = false;\n        /**\n         * Event emitted when the backdrop is clicked.\n         */\n        this.backdropClick = new EventEmitter();\n        /**\n         * Event emitted when the position has changed.\n         */\n        this.positionChange = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been attached.\n         */\n        this.attach = new EventEmitter();\n        /**\n         * Event emitted when the overlay has been detached.\n         */\n        this.detach = new EventEmitter();\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetX\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the x-axis\n         * @return {?}\n         */\n        function () { return this._offsetX; },\n        set: /**\n         * @param {?} offsetX\n         * @return {?}\n         */\n        function (offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._position.withOffsetX(offsetX);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"offsetY\", {\n        get: /**\n         * The offset in pixels for the overlay connection point on the y-axis\n         * @return {?}\n         */\n        function () { return this._offsetY; },\n        set: /**\n         * @param {?} offsetY\n         * @return {?}\n         */\n        function (offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._position.withOffsetY(offsetY);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"hasBackdrop\", {\n        get: /**\n         * Whether or not the overlay should attach a backdrop.\n         * @return {?}\n         */\n        function () { return this._hasBackdrop; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._hasBackdrop = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOrigin\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.origin; },\n        set: /**\n         * @param {?} _origin\n         * @return {?}\n         */\n        function (_origin) { this.origin = _origin; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedPositions\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.positions; },\n        set: /**\n         * @param {?} _positions\n         * @return {?}\n         */\n        function (_positions) { this.positions = _positions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetX\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.offsetX; },\n        set: /**\n         * @param {?} _offsetX\n         * @return {?}\n         */\n        function (_offsetX) { this.offsetX = _offsetX; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOffsetY\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.offsetY; },\n        set: /**\n         * @param {?} _offsetY\n         * @return {?}\n         */\n        function (_offsetY) { this.offsetY = _offsetY; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.width; },\n        set: /**\n         * @param {?} _width\n         * @return {?}\n         */\n        function (_width) { this.width = _width; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.height; },\n        set: /**\n         * @param {?} _height\n         * @return {?}\n         */\n        function (_height) { this.height = _height; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinWidth\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.minWidth; },\n        set: /**\n         * @param {?} _minWidth\n         * @return {?}\n         */\n        function (_minWidth) { this.minWidth = _minWidth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedMinHeight\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.minHeight; },\n        set: /**\n         * @param {?} _minHeight\n         * @return {?}\n         */\n        function (_minHeight) { this.minHeight = _minHeight; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedBackdropClass\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.backdropClass; },\n        set: /**\n         * @param {?} _backdropClass\n         * @return {?}\n         */\n        function (_backdropClass) { this.backdropClass = _backdropClass; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedScrollStrategy\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.scrollStrategy; },\n        set: /**\n         * @param {?} _scrollStrategy\n         * @return {?}\n         */\n        function (_scrollStrategy) {\n            this.scrollStrategy = _scrollStrategy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedOpen\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.open; },\n        set: /**\n         * @param {?} _open\n         * @return {?}\n         */\n        function (_open) { this.open = _open; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"_deprecatedHasBackdrop\", {\n        get: /**\n         * @deprecated\n         * \\@deletion-target 6.0.0\n         * @return {?}\n         */\n        function () { return this.hasBackdrop; },\n        set: /**\n         * @param {?} _hasBackdrop\n         * @return {?}\n         */\n        function (_hasBackdrop) { this.hasBackdrop = _hasBackdrop; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"overlayRef\", {\n        /** The associated overlay reference. */\n        get: /**\n         * The associated overlay reference.\n         * @return {?}\n         */\n        function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkConnectedOverlay.prototype, \"dir\", {\n        /** The element's layout direction. */\n        get: /**\n         * The element's layout direction.\n         * @return {?}\n         */\n        function () {\n            return this._dir ? this._dir.value : 'ltr';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._destroyOverlay();\n    };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n    function (changes) {\n        if (this._position) {\n            if (changes['positions'] || changes['_deprecatedPositions']) {\n                this._position.withPositions(this.positions);\n            }\n            if (changes['origin'] || changes['_deprecatedOrigin']) {\n                this._position.setOrigin(this.origin.elementRef);\n                if (this.open) {\n                    this._position.apply();\n                }\n            }\n        }\n        if (changes['open'] || changes['_deprecatedOpen']) {\n            this.open ? this._attachOverlay() : this._detachOverlay();\n        }\n    };\n    /**\n     * Creates an overlay\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createOverlay = /**\n     * Creates an overlay\n     * @return {?}\n     */\n    function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        this._overlayRef = this._overlay.create(this._buildConfig());\n    };\n    /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._buildConfig = /**\n     * Builds the overlay config based on the directive's inputs\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ positionStrategy = this._position = this._createPositionStrategy();\n        var /** @type {?} */ overlayConfig = new OverlayConfig({\n            positionStrategy: positionStrategy,\n            scrollStrategy: this.scrollStrategy,\n            hasBackdrop: this.hasBackdrop\n        });\n        if (this.width || this.width === 0) {\n            overlayConfig.width = this.width;\n        }\n        if (this.height || this.height === 0) {\n            overlayConfig.height = this.height;\n        }\n        if (this.minWidth || this.minWidth === 0) {\n            overlayConfig.minWidth = this.minWidth;\n        }\n        if (this.minHeight || this.minHeight === 0) {\n            overlayConfig.minHeight = this.minHeight;\n        }\n        if (this.backdropClass) {\n            overlayConfig.backdropClass = this.backdropClass;\n        }\n        return overlayConfig;\n    };\n    /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._createPositionStrategy = /**\n     * Returns the position strategy of the overlay to be set on the overlay config\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        var /** @type {?} */ primaryPosition = this.positions[0];\n        var /** @type {?} */ originPoint = { originX: primaryPosition.originX, originY: primaryPosition.originY };\n        var /** @type {?} */ overlayPoint = { overlayX: primaryPosition.overlayX, overlayY: primaryPosition.overlayY };\n        var /** @type {?} */ strategy = this._overlay.position()\n            .connectedTo(this.origin.elementRef, originPoint, overlayPoint)\n            .withOffsetX(this.offsetX)\n            .withOffsetY(this.offsetY);\n        for (var /** @type {?} */ i = 1; i < this.positions.length; i++) {\n            strategy.withFallbackPosition({ originX: this.positions[i].originX, originY: this.positions[i].originY }, { overlayX: this.positions[i].overlayX, overlayY: this.positions[i].overlayY });\n        }\n        strategy.onPositionChange.subscribe(function (pos) { return _this.positionChange.emit(pos); });\n        return strategy;\n    };\n    /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._attachOverlay = /**\n     * Attaches the overlay and subscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._overlayRef) {\n            this._createOverlay(); /** @type {?} */\n            ((this._overlayRef)).keydownEvents().subscribe(function (event) {\n                if (event.keyCode === ESCAPE) {\n                    _this._detachOverlay();\n                }\n            });\n        }\n        this._position.withDirection(this.dir);\n        this._overlayRef.setDirection(this.dir);\n        if (!this._overlayRef.hasAttached()) {\n            this._overlayRef.attach(this._templatePortal);\n            this.attach.emit();\n        }\n        if (this.hasBackdrop) {\n            this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function () {\n                _this.backdropClick.emit();\n            });\n        }\n    };\n    /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._detachOverlay = /**\n     * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this.detach.emit();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    CdkConnectedOverlay.prototype._destroyOverlay = /**\n     * Destroys the overlay created by this directive.\n     * @return {?}\n     */\n    function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n        }\n        this._backdropSubscription.unsubscribe();\n    };\n    CdkConnectedOverlay.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',\n                    exportAs: 'cdkConnectedOverlay'\n                },] },\n    ];\n    /** @nocollapse */\n    CdkConnectedOverlay.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: TemplateRef, },\n        { type: ViewContainerRef, },\n        { type: undefined, decorators: [{ type: Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] },] },\n        { type: Directionality, decorators: [{ type: Optional },] },\n    ]; };\n    CdkConnectedOverlay.propDecorators = {\n        \"origin\": [{ type: Input, args: ['cdkConnectedOverlayOrigin',] },],\n        \"positions\": [{ type: Input, args: ['cdkConnectedOverlayPositions',] },],\n        \"offsetX\": [{ type: Input, args: ['cdkConnectedOverlayOffsetX',] },],\n        \"offsetY\": [{ type: Input, args: ['cdkConnectedOverlayOffsetY',] },],\n        \"width\": [{ type: Input, args: ['cdkConnectedOverlayWidth',] },],\n        \"height\": [{ type: Input, args: ['cdkConnectedOverlayHeight',] },],\n        \"minWidth\": [{ type: Input, args: ['cdkConnectedOverlayMinWidth',] },],\n        \"minHeight\": [{ type: Input, args: ['cdkConnectedOverlayMinHeight',] },],\n        \"backdropClass\": [{ type: Input, args: ['cdkConnectedOverlayBackdropClass',] },],\n        \"scrollStrategy\": [{ type: Input, args: ['cdkConnectedOverlayScrollStrategy',] },],\n        \"open\": [{ type: Input, args: ['cdkConnectedOverlayOpen',] },],\n        \"hasBackdrop\": [{ type: Input, args: ['cdkConnectedOverlayHasBackdrop',] },],\n        \"_deprecatedOrigin\": [{ type: Input, args: ['origin',] },],\n        \"_deprecatedPositions\": [{ type: Input, args: ['positions',] },],\n        \"_deprecatedOffsetX\": [{ type: Input, args: ['offsetX',] },],\n        \"_deprecatedOffsetY\": [{ type: Input, args: ['offsetY',] },],\n        \"_deprecatedWidth\": [{ type: Input, args: ['width',] },],\n        \"_deprecatedHeight\": [{ type: Input, args: ['height',] },],\n        \"_deprecatedMinWidth\": [{ type: Input, args: ['minWidth',] },],\n        \"_deprecatedMinHeight\": [{ type: Input, args: ['minHeight',] },],\n        \"_deprecatedBackdropClass\": [{ type: Input, args: ['backdropClass',] },],\n        \"_deprecatedScrollStrategy\": [{ type: Input, args: ['scrollStrategy',] },],\n        \"_deprecatedOpen\": [{ type: Input, args: ['open',] },],\n        \"_deprecatedHasBackdrop\": [{ type: Input, args: ['hasBackdrop',] },],\n        \"backdropClick\": [{ type: Output },],\n        \"positionChange\": [{ type: Output },],\n        \"attach\": [{ type: Output },],\n        \"detach\": [{ type: Output },],\n    };\n    return CdkConnectedOverlay;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar OVERLAY_PROVIDERS = [\n    Overlay,\n    OverlayPositionBuilder,\n    OVERLAY_KEYBOARD_DISPATCHER_PROVIDER,\n    VIEWPORT_RULER_PROVIDER,\n    OVERLAY_CONTAINER_PROVIDER,\n    CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n];\nvar OverlayModule = /** @class */ (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [BidiModule, PortalModule, ScrollDispatchModule],\n                    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollDispatchModule],\n                    declarations: [CdkConnectedOverlay, CdkOverlayOrigin],\n                    providers: [OVERLAY_PROVIDERS, ScrollStrategyOptions],\n                },] },\n    ];\n    /** @nocollapse */\n    OverlayModule.ctorParameters = function () { return []; };\n    return OverlayModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Alternative to OverlayContainer that supports correct displaying of overlay elements in\n * Fullscreen mode\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen\n *\n * Should be provided in the root component.\n */\nvar FullscreenOverlayContainer = /** @class */ (function (_super) {\n    __extends(FullscreenOverlayContainer, _super);\n    function FullscreenOverlayContainer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._createContainer = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        _super.prototype._createContainer.call(this);\n        this._adjustParentForFullscreenChange();\n        this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });\n    };\n    /**\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**\n     * @return {?}\n     */\n    function () {\n        if (!this._containerElement) {\n            return;\n        }\n        var /** @type {?} */ fullscreenElement = this.getFullscreenElement();\n        var /** @type {?} */ parent = fullscreenElement || document.body;\n        parent.appendChild(this._containerElement);\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (document.fullscreenEnabled) {\n            document.addEventListener('fullscreenchange', fn);\n        }\n        else if (document.webkitFullscreenEnabled) {\n            document.addEventListener('webkitfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).mozFullScreenEnabled) {\n            document.addEventListener('mozfullscreenchange', fn);\n        }\n        else if ((/** @type {?} */ (document)).msFullscreenEnabled) {\n            document.addEventListener('MSFullscreenChange', fn);\n        }\n    };\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     */\n    /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    FullscreenOverlayContainer.prototype.getFullscreenElement = /**\n     * When the page is put into fullscreen mode, a specific element is specified.\n     * Only that element and its children are visible when in fullscreen mode.\n     * @return {?}\n     */\n    function () {\n        return document.fullscreenElement ||\n            document.webkitFullscreenElement ||\n            (/** @type {?} */ (document)).mozFullScreenElement ||\n            (/** @type {?} */ (document)).msFullscreenElement ||\n            null;\n    };\n    FullscreenOverlayContainer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FullscreenOverlayContainer.ctorParameters = function () { return []; };\n    return FullscreenOverlayContainer;\n}(OverlayContainer));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Overlay, OverlayContainer, CdkOverlayOrigin, CdkConnectedOverlay, FullscreenOverlayContainer, OverlayRef, ViewportRuler, OverlayKeyboardDispatcher, OverlayPositionBuilder, GlobalPositionStrategy, ConnectedPositionStrategy, VIEWPORT_RULER_PROVIDER, CdkConnectedOverlay as ConnectedOverlayDirective, CdkOverlayOrigin as OverlayOrigin, OverlayConfig, ConnectionPositionPair, ScrollingVisibility, ConnectedOverlayPositionChange, CdkScrollable, ScrollDispatcher, ScrollStrategyOptions, RepositionScrollStrategy, CloseScrollStrategy, NoopScrollStrategy, BlockScrollStrategy, OVERLAY_PROVIDERS, OverlayModule, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER as ɵg, OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY as ɵf, OVERLAY_CONTAINER_PROVIDER as ɵb, OVERLAY_CONTAINER_PROVIDER_FACTORY as ɵa, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY as ɵc, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER as ɵe, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY as ɵd };\n//# sourceMappingURL=overlay.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/overlay.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, SkipSelf } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { take } from 'rxjs/operators/take';\nimport { Platform, PlatformModule, supportsPassiveEventListeners } from '@angular/cdk/platform';\nimport { CommonModule, DOCUMENT } from '@angular/common';\nimport { __extends } from 'tslib';\nimport * as tslib_1 from 'tslib';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { A, DOWN_ARROW, LEFT_ARROW, NINE, RIGHT_ARROW, TAB, UP_ARROW, Z, ZERO } from '@angular/cdk/keycodes';\nimport { debounceTime } from 'rxjs/operators/debounceTime';\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\nimport { tap } from 'rxjs/operators/tap';\nimport { of } from 'rxjs/observable/of';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nvar InteractivityChecker = /** @class */ (function () {\n    function InteractivityChecker(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    InteractivityChecker.prototype.isDisabled = /**\n     * Gets whether an element is disabled.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is disabled.\n     */\n    function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    InteractivityChecker.prototype.isVisible = /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @param {?} element\n     * @return {?} Whether the element is visible.\n     */\n    function (element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    InteractivityChecker.prototype.isTabbable = /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is tabbable.\n     */\n    function (element) {\n        // Nothing is tabbable on the the server 😎\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        var /** @type {?} */ frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            var /** @type {?} */ frameType = frameElement && frameElement.nodeName.toLowerCase();\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Webkit and Blink consider anything inside of an <object> element as non-tabbable.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {\n                return false;\n            }\n            // Webkit and Blink disable tabbing to an element inside of an invisible frame.\n            if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n        var /** @type {?} */ tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe') {\n            // The frames may be tabbable depending on content, but it's not possibly to reliably\n            // investigate the content of the frames.\n            return false;\n        }\n        if (nodeName === 'audio') {\n            if (!element.hasAttribute('controls')) {\n                // By default an <audio> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK) {\n                // In Blink <audio controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'video') {\n            if (!element.hasAttribute('controls') && this._platform.TRIDENT) {\n                // In Trident a <video> element without the controls enabled is not tabbable.\n                return false;\n            }\n            else if (this._platform.BLINK || this._platform.FIREFOX) {\n                // In Chrome and Firefox <video controls> elements are always tabbable.\n                return true;\n            }\n        }\n        if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            // In all Blink and WebKit based browsers <object> elements are never tabbable.\n            return false;\n        }\n        // In iOS the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        return element.tabIndex >= 0;\n    };\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is focusable.\n     */\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    InteractivityChecker.prototype.isFocusable = /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param {?} element Element to be checked.\n     * @return {?} Whether the element is focusable.\n     */\n    function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    InteractivityChecker.ctorParameters = function () { return [\n        { type: Platform, },\n    ]; };\n    return InteractivityChecker;\n}());\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n * @param {?} window\n * @return {?}\n */\nfunction getFrameElement(window) {\n    try {\n        return /** @type {?} */ (window.frameElement);\n    }\n    catch (/** @type {?} */ e) {\n        return null;\n    }\n}\n/**\n * Checks whether the specified element has any geometry / rectangles.\n * @param {?} element\n * @return {?}\n */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/**\n * Gets whether an element's\n * @param {?} element\n * @return {?}\n */\nfunction isNativeFormElement(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/**\n * Gets whether an element is an `<input type=\"hidden\">`.\n * @param {?} element\n * @return {?}\n */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/**\n * Gets whether an element is an anchor that has an href attribute.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/**\n * Gets whether an element is an input element.\n * @param {?} element\n * @return {?}\n */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/**\n * Gets whether an element is an anchor element.\n * @param {?} element\n * @return {?}\n */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/**\n * Gets whether an element has a valid tabindex.\n * @param {?} element\n * @return {?}\n */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var /** @type {?} */ tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n * @param {?} element\n * @return {?}\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    var /** @type {?} */ tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/**\n * Checks whether the specified element is potentially tabbable on iOS\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyTabbableIOS(element) {\n    var /** @type {?} */ nodeName = element.nodeName.toLowerCase();\n    var /** @type {?} */ inputType = nodeName === 'input' && (/** @type {?} */ (element)).type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n * @param {?} element\n * @return {?}\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/**\n * Gets the parent window of a DOM node with regards of being inside of an iframe.\n * @param {?} node\n * @return {?}\n */\nfunction getWindow(node) {\n    return node.ownerDocument.defaultView || window;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.\n */\nvar FocusTrap = /** @class */ (function () {\n    function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {\n        if (deferAnchors === void 0) { deferAnchors = false; }\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    Object.defineProperty(FocusTrap.prototype, \"enabled\", {\n        /** Whether the focus trap is active. */\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this._enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this._enabled = val;\n            if (this._startAnchor && this._endAnchor) {\n                this._startAnchor.tabIndex = this._endAnchor.tabIndex = this._enabled ? 0 : -1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Destroys the focus trap by cleaning up the anchors. */\n    /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    FocusTrap.prototype.destroy = /**\n     * Destroys the focus trap by cleaning up the anchors.\n     * @return {?}\n     */\n    function () {\n        if (this._startAnchor && this._startAnchor.parentNode) {\n            this._startAnchor.parentNode.removeChild(this._startAnchor);\n        }\n        if (this._endAnchor && this._endAnchor.parentNode) {\n            this._endAnchor.parentNode.removeChild(this._endAnchor);\n        }\n        this._startAnchor = this._endAnchor = null;\n    };\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     */\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    FocusTrap.prototype.attachAnchors = /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        if (!this._startAnchor) {\n            this._startAnchor = this._createAnchor();\n        }\n        if (!this._endAnchor) {\n            this._endAnchor = this._createAnchor();\n        }\n        this._ngZone.runOutsideAngular(function () {\n            /** @type {?} */ ((_this._startAnchor)).addEventListener('focus', function () {\n                _this.focusLastTabbableElement();\n            }); /** @type {?} */\n            ((_this._endAnchor)).addEventListener('focus', function () {\n                _this.focusFirstTabbableElement();\n            });\n            if (_this._element.parentNode) {\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._startAnchor)), _this._element);\n                _this._element.parentNode.insertBefore(/** @type {?} */ ((_this._endAnchor)), _this._element.nextSibling);\n            }\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElementWhenReady = /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });\n        });\n    };\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElementWhenReady = /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @return {?} Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfuly.\n     */\n    function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });\n        });\n    };\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    FocusTrap.prototype._getRegionBoundary = /**\n     * Get the specified boundary element of the trapped region.\n     * @param {?} bound The boundary to get (start or end of trapped region).\n     * @return {?} The boundary element.\n     */\n    function (bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ markers = /** @type {?} */ (this._element.querySelectorAll(\"[cdk-focus-region-\" + bound + \"], \" +\n            (\"[cdkFocusRegion\" + bound + \"], \") +\n            (\"[cdk-focus-\" + bound + \"]\")));\n        for (var /** @type {?} */ i = 0; i < markers.length; i++) {\n            if (markers[i].hasAttribute(\"cdk-focus-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n            else if (markers[i].hasAttribute(\"cdk-focus-region-\" + bound)) {\n                console.warn(\"Found use of deprecated attribute 'cdk-focus-region-\" + bound + \"',\" +\n                    (\" use 'cdkFocusRegion\" + bound + \"' instead.\"), markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    };\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusInitialElement = /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        var /** @type {?} */ redirectToElement = /** @type {?} */ (this._element.querySelector(\"[cdk-focus-initial], \" +\n            \"[cdkFocusInitial]\"));\n        if (this._element.hasAttribute(\"cdk-focus-initial\")) {\n            console.warn(\"Found use of deprecated attribute 'cdk-focus-initial',\" +\n                \" use 'cdkFocusInitial' instead.\", this._element);\n        }\n        if (redirectToElement) {\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    };\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusFirstTabbableElement = /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfuly.\n     */\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    FocusTrap.prototype.focusLastTabbableElement = /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @return {?} Whether focus was moved successfuly.\n     */\n    function () {\n        var /** @type {?} */ redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    };\n    /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getFirstTabbableElement = /**\n     * Get the first tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = 0; i < children.length; i++) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    FocusTrap.prototype._getLastTabbableElement = /**\n     * Get the last tabbable element from a DOM subtree (inclusive).\n     * @param {?} root\n     * @return {?}\n     */\n    function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        var /** @type {?} */ children = root.children || root.childNodes;\n        for (var /** @type {?} */ i = children.length - 1; i >= 0; i--) {\n            var /** @type {?} */ tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(/** @type {?} */ (children[i])) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    FocusTrap.prototype._createAnchor = /**\n     * Creates an anchor element.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ anchor = this._document.createElement('div');\n        anchor.tabIndex = this._enabled ? 0 : -1;\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        return anchor;\n    };\n    /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    FocusTrap.prototype._executeOnStable = /**\n     * Executes a function when the zone is stable.\n     * @param {?} fn\n     * @return {?}\n     */\n    function (fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(fn);\n        }\n    };\n    return FocusTrap;\n}());\n/**\n * Factory that allows easy instantiation of focus traps.\n */\nvar FocusTrapFactory = /** @class */ (function () {\n    function FocusTrapFactory(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    FocusTrapFactory.prototype.create = /**\n     * Creates a focus-trapped region around the given element.\n     * @param {?} element The element around which focus will be trapped.\n     * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @return {?} The created focus trap instance.\n     */\n    function (element, deferCaptureElements) {\n        if (deferCaptureElements === void 0) { deferCaptureElements = false; }\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    };\n    FocusTrapFactory.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusTrapFactory.ctorParameters = function () { return [\n        { type: InteractivityChecker, },\n        { type: NgZone, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return FocusTrapFactory;\n}());\n/**\n * Directive for trapping focus within a region.\n * \\@docs-private\n * @deprecated\n * \\@deletion-target 6.0.0\n */\nvar FocusTrapDeprecatedDirective = /** @class */ (function () {\n    function FocusTrapDeprecatedDirective(_elementRef, _focusTrapFactory) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(FocusTrapDeprecatedDirective.prototype, \"disabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return !this.focusTrap.enabled; },\n        set: /**\n         * @param {?} val\n         * @return {?}\n         */\n        function (val) {\n            this.focusTrap.enabled = !coerceBooleanProperty(val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n    };\n    /**\n     * @return {?}\n     */\n    FocusTrapDeprecatedDirective.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n    };\n    FocusTrapDeprecatedDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: 'cdk-focus-trap',\n                },] },\n    ];\n    /** @nocollapse */\n    FocusTrapDeprecatedDirective.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n    ]; };\n    FocusTrapDeprecatedDirective.propDecorators = {\n        \"disabled\": [{ type: Input },],\n    };\n    return FocusTrapDeprecatedDirective;\n}());\n/**\n * Directive for trapping focus within a region.\n */\nvar CdkTrapFocus = /** @class */ (function () {\n    function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /**\n         * Previously focused element to restore focus to upon destroy when using autoCapture.\n         */\n        this._previouslyFocusedElement = null;\n        this._document = _document;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    Object.defineProperty(CdkTrapFocus.prototype, \"enabled\", {\n        get: /**\n         * Whether the focus trap is active.\n         * @return {?}\n         */\n        function () { return this.focusTrap.enabled; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CdkTrapFocus.prototype, \"autoCapture\", {\n        get: /**\n         * Whether the directive should automatially move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         * @return {?}\n         */\n        function () { return this._autoCapture; },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) { this._autoCapture = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CdkTrapFocus.prototype.ngAfterContentInit = /**\n     * @return {?}\n     */\n    function () {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    };\n    CdkTrapFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkTrapFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusTrapFactory, },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    CdkTrapFocus.propDecorators = {\n        \"enabled\": [{ type: Input, args: ['cdkTrapFocus',] },],\n        \"autoCapture\": [{ type: Input, args: ['cdkTrapFocusAutoCapture',] },],\n    };\n    return CdkTrapFocus;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * IDs are deliminated by an empty space, as per the spec.\n */\nvar ID_DELIMINATOR = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction addAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMINATOR));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @param {?} id\n * @return {?}\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    var /** @type {?} */ ids = getAriaReferenceIds(el, attr);\n    var /** @type {?} */ filteredIds = ids.filter(function (val) { return val != id.trim(); });\n    el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n * @param {?} el\n * @param {?} attr\n * @return {?}\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace deliminated) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Interface used to register message elements and keep a count of how many registrations have\n * the same message and the reference to the message element used for the `aria-describedby`.\n * @record\n */\n\n/**\n * ID used for the body container where all messages are appended.\n */\nvar MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n */\nvar CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n */\nvar CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/**\n * Global incremental identifier for each registered message element.\n */\nvar nextId = 0;\n/**\n * Global map of all registered message elements that have been placed into the document.\n */\nvar messageRegistry = new Map();\n/**\n * Container for all registered messages.\n */\nvar messagesContainer = null;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n * \\@docs-private\n */\nvar AriaDescriber = /** @class */ (function () {\n    function AriaDescriber(_document) {\n        this._document = _document;\n    }\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     */\n    /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.describe = /**\n     * Adds to the host element an aria-describedby reference to a hidden element that contains\n     * the message. If the same message has already been registered, then it will reuse the created\n     * message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (hostElement.nodeType !== this._document.ELEMENT_NODE || !message.trim()) {\n            return;\n        }\n        if (!messageRegistry.has(message)) {\n            this._createMessageElement(message);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, message)) {\n            this._addMessageReference(hostElement, message);\n        }\n    };\n    /** Removes the host element's aria-describedby reference to the message element. */\n    /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype.removeDescription = /**\n     * Removes the host element's aria-describedby reference to the message element.\n     * @param {?} hostElement\n     * @param {?} message\n     * @return {?}\n     */\n    function (hostElement, message) {\n        if (hostElement.nodeType !== this._document.ELEMENT_NODE || !message.trim()) {\n            return;\n        }\n        if (this._isElementDescribedByMessage(hostElement, message)) {\n            this._removeMessageReference(hostElement, message);\n        }\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        if (registeredMessage && registeredMessage.referenceCount === 0) {\n            this._deleteMessageElement(message);\n        }\n        if (messagesContainer && messagesContainer.childNodes.length === 0) {\n            this._deleteMessagesContainer();\n        }\n    };\n    /** Unregisters all created message elements and removes the message container. */\n    /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    AriaDescriber.prototype.ngOnDestroy = /**\n     * Unregisters all created message elements and removes the message container.\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ describedElements = this._document.querySelectorAll(\"[\" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + \"]\");\n        for (var /** @type {?} */ i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        if (messagesContainer) {\n            this._deleteMessagesContainer();\n        }\n        messageRegistry.clear();\n    };\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessageElement = /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ messageElement = this._document.createElement('div');\n        messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + \"-\" + nextId++);\n        messageElement.appendChild(/** @type {?} */ ((this._document.createTextNode(message))));\n        if (!messagesContainer) {\n            this._createMessagesContainer();\n        } /** @type {?} */\n        ((messagesContainer)).appendChild(messageElement);\n        messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });\n    };\n    /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessageElement = /**\n     * Deletes the message element from the global messages container.\n     * @param {?} message\n     * @return {?}\n     */\n    function (message) {\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageElement = registeredMessage && registeredMessage.messageElement;\n        if (messagesContainer && messageElement) {\n            messagesContainer.removeChild(messageElement);\n        }\n        messageRegistry.delete(message);\n    };\n    /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    AriaDescriber.prototype._createMessagesContainer = /**\n     * Creates the global container for all aria-describedby messages.\n     * @return {?}\n     */\n    function () {\n        messagesContainer = this._document.createElement('div');\n        messagesContainer.setAttribute('id', MESSAGES_CONTAINER_ID);\n        messagesContainer.setAttribute('aria-hidden', 'true');\n        messagesContainer.style.display = 'none';\n        this._document.body.appendChild(messagesContainer);\n    };\n    /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    AriaDescriber.prototype._deleteMessagesContainer = /**\n     * Deletes the global messages container.\n     * @return {?}\n     */\n    function () {\n        if (messagesContainer && messagesContainer.parentNode) {\n            messagesContainer.parentNode.removeChild(messagesContainer);\n            messagesContainer = null;\n        }\n    };\n    /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**\n     * Removes all cdk-describedby messages that are hosted through the element.\n     * @param {?} element\n     * @return {?}\n     */\n    function (element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        var /** @type {?} */ originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n            .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    };\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._addMessageReference = /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n        registeredMessage.referenceCount++;\n    };\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._removeMessageReference = /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ registeredMessage = /** @type {?} */ ((messageRegistry.get(message)));\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    };\n    /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    AriaDescriber.prototype._isElementDescribedByMessage = /**\n     * Returns true if the element has been described by the provided message ID.\n     * @param {?} element\n     * @param {?} message\n     * @return {?}\n     */\n    function (element, message) {\n        var /** @type {?} */ referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        var /** @type {?} */ registeredMessage = messageRegistry.get(message);\n        var /** @type {?} */ messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    };\n    AriaDescriber.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    AriaDescriber.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return AriaDescriber;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} _document\n * @return {?}\n */\nfunction ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {\n    return parentDispatcher || new AriaDescriber(_document);\n}\n/**\n * \\@docs-private\n */\nvar ARIA_DESCRIBER_PROVIDER = {\n    // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.\n    provide: AriaDescriber,\n    deps: [\n        [new Optional(), new SkipSelf(), AriaDescriber],\n        /** @type {?} */ (DOCUMENT)\n    ],\n    useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This interface is for items that can be passed to a ListKeyManager.\n * @record\n */\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nvar ListKeyManager = /** @class */ (function () {\n    function ListKeyManager(_items) {\n        var _this = this;\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._wrap = false;\n        this._letterKeyStream = new Subject();\n        this._typeaheadSubscription = Subscription.EMPTY;\n        this._vertical = true;\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject();\n        /**\n         * Stream that emits whenever the active item of the list manager changes.\n         */\n        this.change = new Subject();\n        _items.changes.subscribe(function (newItems) {\n            if (_this._activeItem) {\n                var /** @type {?} */ itemArray = newItems.toArray();\n                var /** @type {?} */ newIndex = itemArray.indexOf(_this._activeItem);\n                if (newIndex > -1 && newIndex !== _this._activeItemIndex) {\n                    _this._activeItemIndex = newIndex;\n                }\n            }\n        });\n    }\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     */\n    /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withWrap = /**\n     * Turns on wrapping mode, which ensures that the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @return {?}\n     */\n    function () {\n        this._wrap = true;\n        return this;\n    };\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withVerticalOrientation = /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param {?=} enabled Whether vertical selection should be enabled.\n     * @return {?}\n     */\n    function (enabled) {\n        if (enabled === void 0) { enabled = true; }\n        this._vertical = enabled;\n        return this;\n    };\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withHorizontalOrientation = /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param {?} direction Direction in which the selection can be moved.\n     * @return {?}\n     */\n    function (direction) {\n        this._horizontal = direction;\n        return this;\n    };\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    ListKeyManager.prototype.withTypeAhead = /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.\n     * @return {?}\n     */\n    function (debounceInterval) {\n        var _this = this;\n        if (debounceInterval === void 0) { debounceInterval = 200; }\n        if (this._items.length && this._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(tap(function (keyCode) { return _this._pressedLetters.push(keyCode); }), debounceTime(debounceInterval), filter(function () { return _this._pressedLetters.length > 0; }), map(function () { return _this._pressedLetters.join(''); })).subscribe(function (inputString) {\n            var /** @type {?} */ items = _this._items.toArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (var /** @type {?} */ i = 1; i < items.length + 1; i++) {\n                var /** @type {?} */ index = (_this._activeItemIndex + i) % items.length;\n                var /** @type {?} */ item = items[index];\n                if (!item.disabled && /** @type {?} */ ((item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {\n                    _this.setActiveItem(index);\n                    break;\n                }\n            }\n            _this._pressedLetters = [];\n        });\n        return this;\n    };\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param index The index of the item to be set as active.\n     */\n    /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setActiveItem = /**\n     * Sets the active item to the item at the index specified.\n     * @param {?} index The index of the item to be set as active.\n     * @return {?}\n     */\n    function (index) {\n        var /** @type {?} */ previousIndex = this._activeItemIndex;\n        this._activeItemIndex = index;\n        this._activeItem = this._items.toArray()[index];\n        if (this._activeItemIndex !== previousIndex) {\n            this.change.next(index);\n        }\n    };\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    ListKeyManager.prototype.onKeydown = /**\n     * Sets the active item depending on the key event passed in.\n     * @param {?} event Keyboard event to be used for determining which element should be active.\n     * @return {?}\n     */\n    function (event) {\n        var /** @type {?} */ keyCode = event.keyCode;\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical) {\n                    this.setNextItemActive();\n                    break;\n                }\n            case UP_ARROW:\n                if (this._vertical) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setNextItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal === 'ltr') {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else if (this._horizontal === 'rtl') {\n                    this.setNextItemActive();\n                    break;\n                }\n            default:\n                // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                if (event.key && event.key.length === 1) {\n                    this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                }\n                else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                    this._letterKeyStream.next(String.fromCharCode(keyCode));\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    };\n    Object.defineProperty(ListKeyManager.prototype, \"activeItemIndex\", {\n        /** Index of the currently active item. */\n        get: /**\n         * Index of the currently active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItemIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ListKeyManager.prototype, \"activeItem\", {\n        /** The active item. */\n        get: /**\n         * The active item.\n         * @return {?}\n         */\n        function () {\n            return this._activeItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Sets the active item to the first enabled item in the list. */\n    /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setFirstItemActive = /**\n     * Sets the active item to the first enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(0, 1);\n    };\n    /** Sets the active item to the last enabled item in the list. */\n    /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setLastItemActive = /**\n     * Sets the active item to the last enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    };\n    /** Sets the active item to the next enabled item in the list. */\n    /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setNextItemActive = /**\n     * Sets the active item to the next enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    };\n    /** Sets the active item to a previous enabled item in the list. */\n    /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    ListKeyManager.prototype.setPreviousItemActive = /**\n     * Sets the active item to a previous enabled item in the list.\n     * @return {?}\n     */\n    function () {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    };\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param index The new activeItemIndex.\n     */\n    /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    ListKeyManager.prototype.updateActiveItemIndex = /**\n     * Allows setting of the activeItemIndex without any other effects.\n     * @param {?} index The new activeItemIndex.\n     * @return {?}\n     */\n    function (index) {\n        this._activeItemIndex = index;\n    };\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByDelta = /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     * @param {?} delta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (delta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        this._wrap ? this._setActiveInWrapMode(delta, items)\n            : this._setActiveInDefaultMode(delta, items);\n    };\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInWrapMode = /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        // when active item would leave menu, wrap to beginning or end\n        this._activeItemIndex =\n            (this._activeItemIndex + delta + items.length) % items.length;\n        // skip all disabled menu items recursively until an enabled one is reached\n        if (items[this._activeItemIndex].disabled) {\n            this._setActiveInWrapMode(delta, items);\n        }\n        else {\n            this.setActiveItem(this._activeItemIndex);\n        }\n    };\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveInDefaultMode = /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     * @param {?} delta\n     * @param {?} items\n     * @return {?}\n     */\n    function (delta, items) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta, items);\n    };\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    ListKeyManager.prototype._setActiveItemByIndex = /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     * @param {?} index\n     * @param {?} fallbackDelta\n     * @param {?=} items\n     * @return {?}\n     */\n    function (index, fallbackDelta, items) {\n        if (items === void 0) { items = this._items.toArray(); }\n        if (!items[index]) {\n            return;\n        }\n        while (items[index].disabled) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    };\n    return ListKeyManager;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for highlightable items (used by the ActiveDescendantKeyManager).\n * Each item must know how to style itself as active or inactive and whether or not it is\n * currently disabled.\n * @record\n */\n\nvar ActiveDescendantKeyManager = /** @class */ (function (_super) {\n    __extends(ActiveDescendantKeyManager, _super);\n    function ActiveDescendantKeyManager() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    ActiveDescendantKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds active styles to the newly active item and removes active\n     * styles from the previously active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    };\n    return ActiveDescendantKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * This is the interface for focusable items (used by the FocusKeyManager).\n * Each item must know how to focus itself, whether or not it is currently disabled\n * and be able to supply it's label.\n * @record\n */\n\nvar FocusKeyManager = /** @class */ (function (_super) {\n    __extends(FocusKeyManager, _super);\n    function FocusKeyManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._origin = 'program';\n        return _this;\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setFocusOrigin = /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param {?} origin Focus origin to be used when focusing items.\n     * @return {?}\n     */\n    function (origin) {\n        this._origin = origin;\n        return this;\n    };\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     */\n    /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    FocusKeyManager.prototype.setActiveItem = /**\n     * This method sets the active item to the item at the specified index.\n     * It also adds focuses the newly active item.\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        _super.prototype.setActiveItem.call(this, index);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    };\n    return FocusKeyManager;\n}(ListKeyManager));\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken('liveAnnouncerElement');\nvar LiveAnnouncer = /** @class */ (function () {\n    function LiveAnnouncer(elementToken, _document) {\n        this._document = _document;\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * Announces a message to screenreaders.\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element\n     */\n    /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.announce = /**\n     * Announces a message to screenreaders.\n     * @param {?} message Message to be announced to the screenreader\n     * @param {?=} politeness The politeness of the announcer element\n     * @return {?}\n     */\n    function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        if (this._liveElement && this._liveElement.parentNode) {\n            this._liveElement.parentNode.removeChild(this._liveElement);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    LiveAnnouncer.prototype._createLiveElement = /**\n     * @return {?}\n     */\n    function () {\n        var /** @type {?} */ liveEl = this._document.createElement('div');\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    LiveAnnouncer.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    LiveAnnouncer.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] },] },\n        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },\n    ]; };\n    return LiveAnnouncer;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} liveElement\n * @param {?} _document\n * @return {?}\n */\nfunction LIVE_ANNOUNCER_PROVIDER_FACTORY(parentDispatcher, liveElement, _document) {\n    return parentDispatcher || new LiveAnnouncer(liveElement, _document);\n}\n/**\n * \\@docs-private\n */\nvar LIVE_ANNOUNCER_PROVIDER = {\n    // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.\n    provide: LiveAnnouncer,\n    deps: [\n        [new Optional(), new SkipSelf(), LiveAnnouncer],\n        [new Optional(), new Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],\n        DOCUMENT,\n    ],\n    useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nvar TOUCH_BUFFER_MS = 650;\n/**\n * Monitors mouse and keyboard events to determine the cause of focus events.\n */\nvar FocusMonitor = /** @class */ (function () {\n    function FocusMonitor(_ngZone, _platform) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /**\n         * The focus origin that the next focus event is a result of.\n         */\n        this._origin = null;\n        /**\n         * Whether the window has just been focused.\n         */\n        this._windowFocused = false;\n        /**\n         * Map of elements being monitored to their info.\n         */\n        this._elementInfo = new Map();\n        /**\n         * A map of global objects to lists of current listeners.\n         */\n        this._unregisterGlobalListeners = function () { };\n        /**\n         * The number of elements currently being monitored.\n         */\n        this._monitoredElementCount = 0;\n    }\n    /**\n     * @param {?} element\n     * @param {?=} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    FocusMonitor.prototype.monitor = /**\n     * @param {?} element\n     * @param {?=} renderer\n     * @param {?=} checkChildren\n     * @return {?}\n     */\n    function (element, renderer, checkChildren) {\n        var _this = this;\n        // TODO(mmalerba): clean up after deprecated signature is removed.\n        if (!(renderer instanceof Renderer2)) {\n            checkChildren = renderer;\n        }\n        checkChildren = !!checkChildren;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return of(null);\n        }\n        // Check if we're already monitoring this element.\n        if (this._elementInfo.has(element)) {\n            var /** @type {?} */ cachedInfo = this._elementInfo.get(element); /** @type {?} */\n            ((cachedInfo)).checkChildren = checkChildren;\n            return /** @type {?} */ ((cachedInfo)).subject.asObservable();\n        }\n        // Create monitored element info.\n        var /** @type {?} */ info = {\n            unlisten: function () { },\n            checkChildren: checkChildren,\n            subject: new Subject()\n        };\n        this._elementInfo.set(element, info);\n        this._incrementMonitoredElementCount();\n        // Start listening. We need to listen in capture phase since focus events don't bubble.\n        var /** @type {?} */ focusListener = function (event) { return _this._onFocus(event, element); };\n        var /** @type {?} */ blurListener = function (event) { return _this._onBlur(event, element); };\n        this._ngZone.runOutsideAngular(function () {\n            element.addEventListener('focus', focusListener, true);\n            element.addEventListener('blur', blurListener, true);\n        });\n        // Create an unlisten function for later.\n        info.unlisten = function () {\n            element.removeEventListener('focus', focusListener, true);\n            element.removeEventListener('blur', blurListener, true);\n        };\n        return info.subject.asObservable();\n    };\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param element The element to stop monitoring.\n     */\n    /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    FocusMonitor.prototype.stopMonitoring = /**\n     * Stops monitoring an element and removes all focus classes.\n     * @param {?} element The element to stop monitoring.\n     * @return {?}\n     */\n    function (element) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            elementInfo.unlisten();\n            elementInfo.subject.complete();\n            this._setClasses(element);\n            this._elementInfo.delete(element);\n            this._decrementMonitoredElementCount();\n        }\n    };\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param element The element to focus.\n     * @param origin The focus origin.\n     */\n    /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype.focusVia = /**\n     * Focuses the element via the specified focus origin.\n     * @param {?} element The element to focus.\n     * @param {?} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        this._setOriginForCurrentEventQueue(origin);\n        element.focus();\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });\n    };\n    /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    FocusMonitor.prototype._registerGlobalListeners = /**\n     * Register necessary event listeners on the document and window.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        // Do nothing if we're not on the browser platform.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        // On keydown record the origin and clear any touch event that may be in progress.\n        var /** @type {?} */ documentKeydownListener = function () {\n            _this._lastTouchTarget = null;\n            _this._setOriginForCurrentEventQueue('keyboard');\n        };\n        // On mousedown record the origin only if there is not touch target, since a mousedown can\n        // happen as a result of a touch event.\n        var /** @type {?} */ documentMousedownListener = function () {\n            if (!_this._lastTouchTarget) {\n                _this._setOriginForCurrentEventQueue('mouse');\n            }\n        };\n        // When the touchstart event fires the focus event is not yet in the event queue. This means\n        // we can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to\n        // see if a focus happens.\n        var /** @type {?} */ documentTouchstartListener = function (event) {\n            if (_this._touchTimeoutId != null) {\n                clearTimeout(_this._touchTimeoutId);\n            }\n            _this._lastTouchTarget = event.target;\n            _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);\n        };\n        // Make a note of when the window regains focus, so we can restore the origin info for the\n        // focused element.\n        var /** @type {?} */ windowFocusListener = function () {\n            _this._windowFocused = true;\n            _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; }, 0);\n        };\n        // Note: we listen to events in the capture phase so we can detect them even if the user stops\n        // propagation.\n        this._ngZone.runOutsideAngular(function () {\n            document.addEventListener('keydown', documentKeydownListener, true);\n            document.addEventListener('mousedown', documentMousedownListener, true);\n            document.addEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.addEventListener('focus', windowFocusListener);\n        });\n        this._unregisterGlobalListeners = function () {\n            document.removeEventListener('keydown', documentKeydownListener, true);\n            document.removeEventListener('mousedown', documentMousedownListener, true);\n            document.removeEventListener('touchstart', documentTouchstartListener, supportsPassiveEventListeners() ? (/** @type {?} */ ({ passive: true, capture: true })) : true);\n            window.removeEventListener('focus', windowFocusListener);\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(_this._windowFocusTimeoutId);\n            clearTimeout(_this._touchTimeoutId);\n            clearTimeout(_this._originTimeoutId);\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    FocusMonitor.prototype._toggleClass = /**\n     * @param {?} element\n     * @param {?} className\n     * @param {?} shouldSet\n     * @return {?}\n     */\n    function (element, className, shouldSet) {\n        if (shouldSet) {\n            element.classList.add(className);\n        }\n        else {\n            element.classList.remove(className);\n        }\n    };\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setClasses = /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param {?} element The element to update the classes on.\n     * @param {?=} origin The focus origin.\n     * @return {?}\n     */\n    function (element, origin) {\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (elementInfo) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n    };\n    /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    FocusMonitor.prototype._setOriginForCurrentEventQueue = /**\n     * Sets the origin and schedules an async function to clear it at the end of the event queue.\n     * @param {?} origin The origin to set.\n     * @return {?}\n     */\n    function (origin) {\n        var _this = this;\n        this._origin = origin;\n        this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 0);\n    };\n    /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    FocusMonitor.prototype._wasCausedByTouch = /**\n     * Checks whether the given focus event was caused by a touchstart event.\n     * @param {?} event The focus event to check.\n     * @return {?} Whether the event was caused by a touch.\n     */\n    function (event) {\n        // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n        // Consider the following dom structure:\n        //\n        // <div #parent tabindex=\"0\" cdkFocusClasses>\n        //   <div #child (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // If the user touches the #child element and the #parent is programmatically focused as a\n        // result, this code will still consider it to have been caused by the touch event and will\n        // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n        // relatively small edge-case that can be worked around by using\n        // focusVia(parentEl, 'program') to focus the parent element.\n        //\n        // If we decide that we absolutely must handle this case correctly, we can do so by listening\n        // for the first focus event after the touchstart, and then the first blur event after that\n        // focus event. When that blur event fires we know that whatever follows is not a result of the\n        // touchstart.\n        var /** @type {?} */ focusTarget = event.target;\n        return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n            (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n    };\n    /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onFocus = /**\n     * Handles focus events on a registered element.\n     * @param {?} event The focus event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {\n            return;\n        }\n        // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n        // 1) The window has just regained focus, in which case we want to restore the focused state of\n        //    the element from before the window blurred.\n        // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n        // 3) The element was programmatically focused, in which case we should mark the origin as\n        //    'program'.\n        if (!this._origin) {\n            if (this._windowFocused && this._lastFocusOrigin) {\n                this._origin = this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                this._origin = 'touch';\n            }\n            else {\n                this._origin = 'program';\n            }\n        }\n        this._setClasses(element, this._origin);\n        elementInfo.subject.next(this._origin);\n        this._lastFocusOrigin = this._origin;\n        this._origin = null;\n    };\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    FocusMonitor.prototype._onBlur = /**\n     * Handles blur events on a registered element.\n     * @param {?} event The blur event.\n     * @param {?} element The monitored element.\n     * @return {?}\n     */\n    function (event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        var /** @type {?} */ elementInfo = this._elementInfo.get(element);\n        if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n            element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        elementInfo.subject.next(null);\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._incrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount == 1) {\n            this._registerGlobalListeners();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    FocusMonitor.prototype._decrementMonitoredElementCount = /**\n     * @return {?}\n     */\n    function () {\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            this._unregisterGlobalListeners();\n            this._unregisterGlobalListeners = function () { };\n        }\n    };\n    FocusMonitor.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    FocusMonitor.ctorParameters = function () { return [\n        { type: NgZone, },\n        { type: Platform, },\n    ]; };\n    return FocusMonitor;\n}());\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nvar CdkMonitorFocus = /** @class */ (function () {\n    function CdkMonitorFocus(_elementRef, _focusMonitor) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this.cdkFocusChange = new EventEmitter();\n        this._monitorSubscription = this._focusMonitor.monitor(this._elementRef.nativeElement, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });\n    }\n    /**\n     * @return {?}\n     */\n    CdkMonitorFocus.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);\n        this._monitorSubscription.unsubscribe();\n    };\n    CdkMonitorFocus.decorators = [\n        { type: Directive, args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                },] },\n    ];\n    /** @nocollapse */\n    CdkMonitorFocus.ctorParameters = function () { return [\n        { type: ElementRef, },\n        { type: FocusMonitor, },\n    ]; };\n    CdkMonitorFocus.propDecorators = {\n        \"cdkFocusChange\": [{ type: Output },],\n    };\n    return CdkMonitorFocus;\n}());\n/**\n * \\@docs-private\n * @param {?} parentDispatcher\n * @param {?} ngZone\n * @param {?} platform\n * @return {?}\n */\nfunction FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {\n    return parentDispatcher || new FocusMonitor(ngZone, platform);\n}\n/**\n * \\@docs-private\n */\nvar FOCUS_MONITOR_PROVIDER = {\n    // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.\n    provide: FocusMonitor,\n    deps: [[new Optional(), new SkipSelf(), FocusMonitor], NgZone, Platform],\n    useFactory: FOCUS_MONITOR_PROVIDER_FACTORY\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Screenreaders will often fire fake mousedown events when a focusable element\n * is activated using the keyboard. We can typically distinguish between these faked\n * mousedown events and real mousedown events using the \"buttons\" property. While\n * real mousedowns will indicate the mouse button that was pressed (e.g. \"1\" for\n * the left mouse button), faked mousedowns will usually set the property value to 0.\n * @param {?} event\n * @return {?}\n */\nfunction isFakeMousedownFromScreenReader(event) {\n    return event.buttons === 0;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar A11yModule = /** @class */ (function () {\n    function A11yModule() {\n    }\n    A11yModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule, PlatformModule],\n                    declarations: [CdkTrapFocus, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    exports: [CdkTrapFocus, FocusTrapDeprecatedDirective, CdkMonitorFocus],\n                    providers: [\n                        InteractivityChecker,\n                        FocusTrapFactory,\n                        AriaDescriber,\n                        LIVE_ANNOUNCER_PROVIDER,\n                        ARIA_DESCRIBER_PROVIDER,\n                        FOCUS_MONITOR_PROVIDER,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    A11yModule.ctorParameters = function () { return []; };\n    return A11yModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkTrapFocus as FocusTrapDirective, MESSAGES_CONTAINER_ID, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, AriaDescriber, ARIA_DESCRIBER_PROVIDER_FACTORY, ARIA_DESCRIBER_PROVIDER, ActiveDescendantKeyManager, FocusKeyManager, ListKeyManager, FocusTrap, FocusTrapFactory, FocusTrapDeprecatedDirective, CdkTrapFocus, InteractivityChecker, LIVE_ANNOUNCER_ELEMENT_TOKEN, LiveAnnouncer, LIVE_ANNOUNCER_PROVIDER_FACTORY, LIVE_ANNOUNCER_PROVIDER, TOUCH_BUFFER_MS, FocusMonitor, CdkMonitorFocus, FOCUS_MONITOR_PROVIDER_FACTORY, FOCUS_MONITOR_PROVIDER, isFakeMousedownFromScreenReader, A11yModule };\n//# sourceMappingURL=a11y.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/a11y.es5.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"./contextMenuContent.component\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuContentComponent = [\".passive[_ngcontent-%COMP%] {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu[_ngcontent-%COMP%]:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\"];\nvar RenderType_ContextMenuContentComponent = i0.ɵcrt({ encapsulation: 0, styles: styles_ContextMenuContentComponent, data: {} });\nexport { RenderType_ContextMenuContentComponent as RenderType_ContextMenuContentComponent };\nfunction View_ContextMenuContentComponent_3(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵand(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_2(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 5, \"a\", [[\"href\", \"\"]], [[2, \"dropdown-item\", null], [2, \"active\", null], [2, \"disabled\", null], [2, \"hasSubMenu\", null]], [[null, \"click\"], [null, \"mouseenter\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.onMenuItemSelect(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_1 = (_co.onOpenSubMenu(_v.parent.context.$implicit, $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n            \"])), (_l()(), i0.ɵand(16777216, null, null, 2, null, View_ContextMenuContentComponent_3)), i0.ɵdid(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.ɵpod(4, { $implicit: 0 }), (_l()(), i0.ɵted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_4 = _ck(_v, 4, 0, _co.item); var currVal_5 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_4, currVal_5); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_v.parent.context.$implicit.isActive && _co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_2 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); var currVal_3 = !!_v.parent.context.$implicit.subMenu; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3); }); }\nfunction View_ContextMenuContentComponent_5(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵand(0, null, null, 0))], null, null); }\nfunction View_ContextMenuContentComponent_4(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 5, \"span\", [[\"class\", \"passive\"]], [[2, \"dropdown-item\", null], [2, \"disabled\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"click\" === en)) {\n        var pd_0 = (_co.stopEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"contextmenu\" === en)) {\n        var pd_1 = (_co.stopEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n            \"])), (_l()(), i0.ɵand(16777216, null, null, 2, null, View_ContextMenuContentComponent_5)), i0.ɵdid(3, 540672, null, 0, i1.NgTemplateOutlet, [i0.ViewContainerRef], { ngTemplateOutletContext: [0, \"ngTemplateOutletContext\"], ngTemplateOutlet: [1, \"ngTemplateOutlet\"] }, null), i0.ɵpod(4, { $implicit: 0 }), (_l()(), i0.ɵted(-1, null, [\"\\n          \"]))], function (_ck, _v) { var _co = _v.component; var currVal_2 = _ck(_v, 4, 0, _co.item); var currVal_3 = _v.parent.context.$implicit.template; _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.useBootstrap4; var currVal_1 = (_co.useBootstrap4 && !_co.isMenuItemEnabled(_v.parent.context.$implicit)); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_ContextMenuContentComponent_1(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, [[2, 0], [\"li\", 1]], null, 7, \"li\", [], [[2, \"disabled\", null], [2, \"divider\", null], [2, \"dropdown-divider\", null], [2, \"active\", null], [1, \"role\", 0]], null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n          \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_ContextMenuContentComponent_2)), i0.ɵdid(3, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n\\n          \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_ContextMenuContentComponent_4)), i0.ɵdid(6, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n        \"]))], function (_ck, _v) { var currVal_5 = (!_v.context.$implicit.divider && !_v.context.$implicit.passive); _ck(_v, 3, 0, currVal_5); var currVal_6 = (!_v.context.$implicit.divider && _v.context.$implicit.passive); _ck(_v, 6, 0, currVal_6); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = !_co.isMenuItemEnabled(_v.context.$implicit); var currVal_1 = _v.context.$implicit.divider; var currVal_2 = (_co.useBootstrap4 && _v.context.$implicit.divider); var currVal_3 = (_v.context.$implicit.isActive && _co.isMenuItemEnabled(_v.context.$implicit)); var currVal_4 = (_v.context.$implicit.divider ? \"separator\" : undefined); _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); }); }\nexport function View_ContextMenuContentComponent_0(_l) { return i0.ɵvid(0, [i0.ɵqud(402653184, 1, { menuElement: 0 }), i0.ɵqud(671088640, 2, { menuItemElements: 1 }), (_l()(), i0.ɵeld(2, 0, null, null, 7, \"div\", [[\"class\", \"dropdown open show ngx-contextmenu\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵeld(4, 0, [[1, 0], [\"menu\", 1]], null, 4, \"ul\", [[\"class\", \"dropdown-menu show\"], [\"style\", \"position: static; float: none;\"], [\"tabindex\", \"0\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n        \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_ContextMenuContentComponent_1)), i0.ɵdid(7, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.menuItems; _ck(_v, 7, 0, currVal_0); }, null); }\nexport function View_ContextMenuContentComponent_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"context-menu-content\", [], null, [[\"window\", \"keydown.ArrowDown\"], [\"window\", \"keydown.ArrowUp\"], [\"window\", \"keydown.ArrowRight\"], [\"window\", \"keydown.Enter\"], [\"window\", \"keydown.Space\"], [\"window\", \"keydown.Escape\"], [\"window\", \"keydown.ArrowLeft\"], [\"document\", \"click\"], [\"document\", \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"window:keydown.ArrowDown\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"window:keydown.ArrowUp\" === en)) {\n        var pd_1 = (i0.ɵnov(_v, 1).onKeyEvent($event) !== false);\n        ad = (pd_1 && ad);\n    } if ((\"window:keydown.ArrowRight\" === en)) {\n        var pd_2 = (i0.ɵnov(_v, 1).keyboardOpenSubMenu($event) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"window:keydown.Enter\" === en)) {\n        var pd_3 = (i0.ɵnov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"window:keydown.Space\" === en)) {\n        var pd_4 = (i0.ɵnov(_v, 1).keyboardMenuItemSelect($event) !== false);\n        ad = (pd_4 && ad);\n    } if ((\"window:keydown.Escape\" === en)) {\n        var pd_5 = (i0.ɵnov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_5 && ad);\n    } if ((\"window:keydown.ArrowLeft\" === en)) {\n        var pd_6 = (i0.ɵnov(_v, 1).onCloseLeafMenu($event) !== false);\n        ad = (pd_6 && ad);\n    } if ((\"document:click\" === en)) {\n        var pd_7 = (i0.ɵnov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_7 && ad);\n    } if ((\"document:contextmenu\" === en)) {\n        var pd_8 = (i0.ɵnov(_v, 1).closeMenu($event) !== false);\n        ad = (pd_8 && ad);\n    } return ad; }, View_ContextMenuContentComponent_0, RenderType_ContextMenuContentComponent)), i0.ɵdid(1, 4440064, null, 0, i2.ContextMenuContentComponent, [i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS], i0.Renderer], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar ContextMenuContentComponentNgFactory = i0.ɵccf(\"context-menu-content\", i2.ContextMenuContentComponent, View_ContextMenuContentComponent_Host_0, { menuItems: \"menuItems\", item: \"item\", event: \"event\", parentContextMenu: \"parentContextMenu\", overlay: \"overlay\", isLeaf: \"isLeaf\" }, { execute: \"execute\", openSubMenu: \"openSubMenu\", closeLeafMenu: \"closeLeafMenu\", closeAllMenus: \"closeAllMenus\" }, []);\nexport { ContextMenuContentComponentNgFactory as ContextMenuContentComponentNgFactory };\n//# sourceMappingURL=contextMenuContent.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./contextMenu.component\";\nimport * as i2 from \"./contextMenu.service\";\nimport * as i3 from \"./contextMenu.tokens\";\nvar styles_ContextMenuComponent = [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"];\nvar RenderType_ContextMenuComponent = i0.ɵcrt({ encapsulation: 2, styles: styles_ContextMenuComponent, data: {} });\nexport { RenderType_ContextMenuComponent as RenderType_ContextMenuComponent };\nexport function View_ContextMenuComponent_0(_l) { return i0.ɵvid(0, [i0.ɵqud(402653184, 1, { menuElement: 0 }), (_l()(), i0.ɵted(-1, null, [\" \"]))], null, null); }\nexport function View_ContextMenuComponent_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"context-menu\", [], null, null, null, View_ContextMenuComponent_0, RenderType_ContextMenuComponent)), i0.ɵdid(1, 180224, null, 1, i1.ContextMenuComponent, [i2.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i3.CONTEXT_MENU_OPTIONS]], null, null), i0.ɵqud(603979776, 1, { menuItems: 1 })], null, null); }\nvar ContextMenuComponentNgFactory = i0.ɵccf(\"context-menu\", i1.ContextMenuComponent, View_ContextMenuComponent_Host_0, { autoFocus: \"autoFocus\", useBootstrap4: \"useBootstrap4\", disabled: \"disabled\" }, { close: \"close\", open: \"open\" }, []);\nexport { ContextMenuComponentNgFactory as ContextMenuComponentNgFactory };\n//# sourceMappingURL=contextMenu.component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive\";\nimport * as i3 from \"ngx-contextmenu/lib/contextMenu.attach.directive\";\nimport * as i4 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i5 from \"../../../src/modules/month/calendar-month-view.component.ngfactory\";\nimport * as i6 from \"../../../src/modules/month/calendar-month-view.component\";\nimport * as i7 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i8 from \"../../../src/modules/week/calendar-week-view.component.ngfactory\";\nimport * as i9 from \"../../../src/modules/week/calendar-week-view.component\";\nimport * as i10 from \"../../../src/modules/day/calendar-day-view.component.ngfactory\";\nimport * as i11 from \"../../../src/modules/day/calendar-day-view.component\";\nimport * as i12 from \"../../../src/modules/common/calendar-date.pipe\";\nimport * as i13 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i14 from \"../../../src/modules/common/calendar-event-title.pipe\";\nimport * as i15 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i16 from \"../demo-utils/calendar-header.component.ngfactory\";\nimport * as i17 from \"../demo-utils/calendar-header.component\";\nimport * as i18 from \"../../../node_modules/ngx-contextmenu/lib/contextMenu.component.ngfactory\";\nimport * as i19 from \"ngx-contextmenu/lib/contextMenu.component\";\nimport * as i20 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i21 from \"ngx-contextmenu/lib/contextMenu.item.directive\";\nimport * as i22 from \"./component\";\nvar styles_DemoComponent = [\".fill-height[_ngcontent-%COMP%] {\\n      flex: 1;\\n      display: flex;\\n      flex-direction: column;\\n      align-items: stretch;\\n    }\"];\nvar RenderType_DemoComponent = i0.ɵcrt({ encapsulation: 0, styles: styles_DemoComponent, data: {} });\nexport { RenderType_DemoComponent as RenderType_DemoComponent };\nfunction View_DemoComponent_1(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵted(-1, null, [\"\\n    Add event\\n  \"]))], null, null); }\nfunction View_DemoComponent_3(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"span\", [[\"class\", \"cal-day-badge\"]], null, null, null, null, null)), (_l()(), i0.ɵted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.day.badgeTotal; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_DemoComponent_4(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 16777216, null, null, 4, \"div\", [[\"class\", \"cal-event\"]], [[4, \"backgroundColor\", null]], [[null, \"mouseenter\"], [null, \"mouseleave\"], [null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"mouseenter\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 2).onMouseOver() !== false);\n        ad = (pd_0 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_1 = (i0.ɵnov(_v, 2).onMouseOut() !== false);\n        ad = (pd_1 && ad);\n    } if ((\"mouseenter\" === en)) {\n        var pd_2 = (_v.parent.context.highlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_2 && ad);\n    } if ((\"mouseleave\" === en)) {\n        var pd_3 = (_v.parent.context.unhighlightDay.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_3 && ad);\n    } if ((\"click\" === en)) {\n        $event.stopPropagation();\n        var pd_4 = (_v.parent.context.eventClicked.emit({ event: _v.context.$implicit }) !== false);\n        ad = (pd_4 && ad);\n    } return ad; }, null, null)), i0.ɵdid(1, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.ɵdid(2, 147456, null, 0, i2.CalendarTooltipDirective, [i0.ElementRef, i0.Injector, i0.Renderer2, i0.ComponentFactoryResolver, i0.ViewContainerRef, i1.DOCUMENT], { contents: [0, \"contents\"], placement: [1, \"placement\"] }, null), i0.ɵppd(3, 3), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵand(0, null, null, 0))], function (_ck, _v) { var currVal_1 = \"cal-event\"; var currVal_2 = ((_v.context.$implicit == null) ? null : _v.context.$implicit.cssClass); _ck(_v, 1, 0, currVal_1, currVal_2); var currVal_3 = i0.ɵunv(_v, 2, 0, _ck(_v, 3, 0, i0.ɵnov(_v.parent.parent, 1), _v.context.$implicit.title, \"monthTooltip\", _v.context.$implicit)); var currVal_4 = _v.parent.context.tooltipPlacement; _ck(_v, 2, 0, currVal_3, currVal_4); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.color.primary; _ck(_v, 0, 0, currVal_0); }); }\nfunction View_DemoComponent_2(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵted(-1, null, [\"\\n\\n  \"])), (_l()(), i0.ɵeld(1, 0, null, null, 18, \"div\", [[\"class\", \"fill-height\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 2).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.ɵdid(2, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵeld(4, 0, null, null, 8, \"div\", [[\"class\", \"cal-cell-top\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_3)), i0.ɵdid(7, 16384, null, 0, i1.NgIf, [i0.ViewContainerRef, i0.TemplateRef], { ngIf: [0, \"ngIf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵeld(9, 0, null, null, 2, \"span\", [[\"class\", \"cal-day-number\"]], null, null, null, null, null)), (_l()(), i0.ɵted(10, null, [\"\", \"\"])), i0.ɵppd(11, 3), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵeld(14, 0, null, null, 4, \"div\", [[\"class\", \"cal-events\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_4)), i0.ɵdid(17, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.day.date; var currVal_1 = i0.ɵnov(_v.parent, 7); _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = (_v.context.day.badgeTotal > 0); _ck(_v, 7, 0, currVal_2); var currVal_4 = _v.context.day.events; _ck(_v, 17, 0, currVal_4); }, function (_ck, _v) { var currVal_3 = i0.ɵunv(_v, 10, 0, _ck(_v, 11, 0, i0.ɵnov(_v.parent, 0), _v.context.day.date, \"monthViewDayNumber\", _v.context.locale)); _ck(_v, 10, 0, currVal_3); }); }\nfunction View_DemoComponent_6(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 11, \"div\", [[\"class\", \"cal-header\"]], [[2, \"cal-past\", null], [2, \"cal-today\", null], [2, \"cal-future\", null], [2, \"cal-weekend\", null], [2, \"cal-drag-over\", null]], [[null, \"click\"], [null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 1).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"click\" === en)) {\n        var pd_1 = (_v.parent.context.dayHeaderClicked.emit({ day: _v.context.$implicit }) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, null, null)), i0.ɵdid(1, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵeld(3, 0, null, null, 2, \"b\", [], null, null, null, null, null)), (_l()(), i0.ɵted(4, null, [\"\", \"\"])), i0.ɵppd(5, 3), (_l()(), i0.ɵeld(6, 0, null, null, 0, \"br\", [], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n      \"])), (_l()(), i0.ɵeld(8, 0, null, null, 2, \"span\", [], null, null, null, null, null)), (_l()(), i0.ɵted(9, null, [\"\", \"\"])), i0.ɵppd(10, 3), (_l()(), i0.ɵted(-1, null, [\"\\n    \"]))], function (_ck, _v) { var currVal_5 = _v.context.$implicit.date; var currVal_6 = i0.ɵnov(_v.parent.parent, 7); _ck(_v, 1, 0, currVal_5, currVal_6); }, function (_ck, _v) { var currVal_0 = _v.context.$implicit.isPast; var currVal_1 = _v.context.$implicit.isToday; var currVal_2 = _v.context.$implicit.isFuture; var currVal_3 = _v.context.$implicit.isWeekend; var currVal_4 = _v.context.$implicit.dragOver; _ck(_v, 0, 0, currVal_0, currVal_1, currVal_2, currVal_3, currVal_4); var currVal_7 = i0.ɵunv(_v, 4, 0, _ck(_v, 5, 0, i0.ɵnov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnHeader\", _v.parent.context.locale)); _ck(_v, 4, 0, currVal_7); var currVal_8 = i0.ɵunv(_v, 9, 0, _ck(_v, 10, 0, i0.ɵnov(_v.parent.parent, 0), _v.context.$implicit.date, \"weekViewColumnSubHeader\", _v.parent.context.locale)); _ck(_v, 9, 0, currVal_8); }); }\nfunction View_DemoComponent_5(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵeld(1, 0, null, null, 4, \"div\", [[\"class\", \"cal-day-headers\"]], null, null, null, null, null)), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_6)), i0.ɵdid(4, 802816, null, 0, i1.NgForOf, [i0.ViewContainerRef, i0.TemplateRef, i0.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = _v.context.days; _ck(_v, 4, 0, currVal_0); }, null); }\nfunction View_DemoComponent_7(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵeld(1, 0, null, null, 7, \"div\", [[\"class\", \"cal-hour-segment\"]], null, [[null, \"contextmenu\"]], function (_v, en, $event) { var ad = true; if ((\"contextmenu\" === en)) {\n        var pd_0 = (i0.ɵnov(_v, 3).onContextMenu($event) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i0.ɵdid(2, 278528, null, 0, i1.NgClass, [i0.IterableDiffers, i0.KeyValueDiffers, i0.ElementRef, i0.Renderer2], { klass: [0, \"klass\"], ngClass: [1, \"ngClass\"] }, null), i0.ɵdid(3, 16384, null, 0, i3.ContextMenuAttachDirective, [i4.ContextMenuService], { contextMenuSubject: [0, \"contextMenuSubject\"], contextMenu: [1, \"contextMenu\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n    \"])), (_l()(), i0.ɵeld(5, 0, null, null, 2, \"div\", [[\"class\", \"cal-time\"]], [[8, \"hidden\", 0]], null, null, null, null)), (_l()(), i0.ɵted(6, null, [\"\\n      \", \"\\n    \"])), i0.ɵppd(7, 3), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵted(-1, null, [\"\\n\"]))], function (_ck, _v) { var currVal_0 = \"cal-hour-segment\"; var currVal_1 = _v.context.segment.cssClass; _ck(_v, 2, 0, currVal_0, currVal_1); var currVal_2 = _v.context.segment.date; var currVal_3 = i0.ɵnov(_v.parent, 7); _ck(_v, 3, 0, currVal_2, currVal_3); }, function (_ck, _v) { var currVal_4 = !_v.context.segment.isStart; _ck(_v, 5, 0, currVal_4); var currVal_5 = i0.ɵunv(_v, 6, 0, _ck(_v, 7, 0, i0.ɵnov(_v.parent, 0), _v.context.segment.date, \"dayViewHour\", _v.context.locale)); _ck(_v, 6, 0, currVal_5); }); }\nfunction View_DemoComponent_8(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"mwl-calendar-month-view\", [], null, null, null, i5.View_CalendarMonthViewComponent_0, i5.RenderType_CalendarMonthViewComponent)), i0.ɵdid(1, 770048, null, 0, i6.CalendarMonthViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], cellTemplate: [3, \"cellTemplate\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.ɵnov(_v.parent, 14); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_9(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"mwl-calendar-week-view\", [], null, null, null, i8.View_CalendarWeekViewComponent_0, i8.RenderType_CalendarWeekViewComponent)), i0.ɵdid(1, 770048, null, 0, i9.CalendarWeekViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], headerTemplate: [3, \"headerTemplate\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.ɵnov(_v.parent, 16); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nfunction View_DemoComponent_10(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 2, \"mwl-calendar-day-view\", [], null, null, null, i10.View_CalendarDayViewComponent_0, i10.RenderType_CalendarDayViewComponent)), i0.ɵdid(1, 770048, null, 0, i11.CalendarDayViewComponent, [i0.ChangeDetectorRef, i7.CalendarUtils, i0.LOCALE_ID], { viewDate: [0, \"viewDate\"], events: [1, \"events\"], refresh: [2, \"refresh\"], hourSegmentTemplate: [3, \"hourSegmentTemplate\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.viewDate; var currVal_1 = _co.events; var currVal_2 = _co.refresh; var currVal_3 = i0.ɵnov(_v.parent, 18); _ck(_v, 1, 0, currVal_0, currVal_1, currVal_2, currVal_3); }, null); }\nexport function View_DemoComponent_0(_l) { return i0.ɵvid(2, [i0.ɵpid(0, i12.CalendarDatePipe, [i13.CalendarDateFormatter, i0.LOCALE_ID]), i0.ɵpid(0, i14.CalendarEventTitlePipe, [i15.CalendarEventTitleFormatter]), (_l()(), i0.ɵeld(2, 0, null, null, 2, \"mwl-demo-utils-calendar-header\", [], null, [[null, \"viewChange\"], [null, \"viewDateChange\"]], function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"viewChange\" === en)) {\n        var pd_0 = ((_co.view = $event) !== false);\n        ad = (pd_0 && ad);\n    } if ((\"viewDateChange\" === en)) {\n        var pd_1 = ((_co.viewDate = $event) !== false);\n        ad = (pd_1 && ad);\n    } return ad; }, i16.View_CalendarHeaderComponent_0, i16.RenderType_CalendarHeaderComponent)), i0.ɵdid(3, 49152, null, 0, i17.CalendarHeaderComponent, [], { view: [0, \"view\"], viewDate: [1, \"viewDate\"] }, { viewChange: \"viewChange\", viewDateChange: \"viewDateChange\" }), (_l()(), i0.ɵted(-1, null, [\"\\n\"])), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵeld(6, 0, null, null, 6, \"context-menu\", [], null, null, null, i18.View_ContextMenuComponent_0, i18.RenderType_ContextMenuComponent)), i0.ɵdid(7, 180224, [[\"basicMenu\", 4]], 1, i19.ContextMenuComponent, [i4.ContextMenuService, i0.ChangeDetectorRef, i0.ElementRef, [2, i20.CONTEXT_MENU_OPTIONS]], null, null), i0.ɵqud(603979776, 1, { menuItems: 1 }), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵand(0, null, null, 1, function (_v, en, $event) { var ad = true; var _co = _v.component; if ((\"execute\" === en)) {\n        var pd_0 = (_co.addEvent($event.item) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, View_DemoComponent_1)), i0.ɵdid(11, 16384, [[1, 4]], 0, i21.ContextMenuItemDirective, [i0.TemplateRef, i0.ElementRef], null, { execute: \"execute\" }), (_l()(), i0.ɵted(-1, null, [\"\\n\"])), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵand(0, [[\"monthCellTemplate\", 2]], null, 0, null, View_DemoComponent_2)), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵand(0, [[\"weekHeaderTemplate\", 2]], null, 0, null, View_DemoComponent_5)), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵand(0, [[\"dayHourSegmentTemplate\", 2]], null, 0, null, View_DemoComponent_7)), (_l()(), i0.ɵted(-1, null, [\"\\n\\n\"])), (_l()(), i0.ɵeld(20, 0, null, null, 11, \"div\", [], null, null, null, null, null)), i0.ɵdid(21, 16384, null, 0, i1.NgSwitch, [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_8)), i0.ɵdid(24, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_9)), i0.ɵdid(27, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n  \"])), (_l()(), i0.ɵand(16777216, null, null, 1, null, View_DemoComponent_10)), i0.ɵdid(30, 278528, null, 0, i1.NgSwitchCase, [i0.ViewContainerRef, i0.TemplateRef, i1.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i0.ɵted(-1, null, [\"\\n\"]))], function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.view; var currVal_1 = _co.viewDate; _ck(_v, 3, 0, currVal_0, currVal_1); var currVal_2 = _co.view; _ck(_v, 21, 0, currVal_2); var currVal_3 = \"month\"; _ck(_v, 24, 0, currVal_3); var currVal_4 = \"week\"; _ck(_v, 27, 0, currVal_4); var currVal_5 = \"day\"; _ck(_v, 30, 0, currVal_5); }, null); }\nexport function View_DemoComponent_Host_0(_l) { return i0.ɵvid(0, [(_l()(), i0.ɵeld(0, 0, null, null, 1, \"mwl-demo-component\", [], null, null, null, View_DemoComponent_0, RenderType_DemoComponent)), i0.ɵdid(1, 49152, null, 0, i22.DemoComponent, [], null, null)], null, null); }\nvar DemoComponentNgFactory = i0.ɵccf(\"mwl-demo-component\", i22.DemoComponent, View_DemoComponent_Host_0, {}, {}, []);\nexport { DemoComponentNgFactory as DemoComponentNgFactory };\n//# sourceMappingURL=component.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/component.ngfactory.js\n// module id = null\n// module chunks = ","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { CalendarModule } from 'angular-calendar';\nimport { ContextMenuModule } from 'ngx-contextmenu';\nimport { DemoUtilsModule } from '../demo-utils/module';\nimport { DemoComponent } from './component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CalendarModule.forRoot(),\n    ContextMenuModule.forRoot({\n      useBootstrap4: true\n    }),\n    DemoUtilsModule,\n    RouterModule.forChild([{ path: '', component: DemoComponent }])\n  ],\n  declarations: [DemoComponent],\n  exports: [DemoComponent]\n})\nexport class DemoModule {}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/module.ts","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Directive, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, Optional, Output } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n */\nvar DIR_DOCUMENT = new InjectionToken('cdk-dir-doc');\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nvar Directionality = /** @class */ (function () {\n    function Directionality(_document) {\n        /**\n         * The current 'ltr' or 'rtl' value.\n         */\n        this.value = 'ltr';\n        /**\n         * Stream that emits whenever the 'ltr' / 'rtl' state changes.\n         */\n        this.change = new EventEmitter();\n        if (_document) {\n            // TODO: handle 'auto' value -\n            // We still need to account for dir=\"auto\".\n            // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n            // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;\n            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));\n        }\n    }\n    Directionality.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    Directionality.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] },] },\n    ]; };\n    return Directionality;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nvar Dir = /** @class */ (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        /**\n         * Whether the `value` has been set to its initial value.\n         */\n        this._isInitialized = false;\n        /**\n         * Event emitted when the direction changes.\n         */\n        this.change = new EventEmitter();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: /**\n         * \\@docs-private\n         * @return {?}\n         */\n        function () { return this._dir; },\n        set: /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            var /** @type {?} */ old = this._dir;\n            this._dir = v;\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        /** Current layout direction of the element. */\n        get: /**\n         * Current layout direction of the element.\n         * @return {?}\n         */\n        function () { return this.dir; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Initialize once default value has been set. */\n    /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    Dir.prototype.ngAfterContentInit = /**\n     * Initialize once default value has been set.\n     * @return {?}\n     */\n    function () {\n        this._isInitialized = true;\n    };\n    /**\n     * @return {?}\n     */\n    Dir.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.change.complete();\n    };\n    Dir.decorators = [\n        { type: Directive, args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[dir]': 'dir' },\n                    exportAs: 'dir',\n                },] },\n    ];\n    /** @nocollapse */\n    Dir.ctorParameters = function () { return []; };\n    Dir.propDecorators = {\n        \"change\": [{ type: Output, args: ['dirChange',] },],\n        \"dir\": [{ type: Input },],\n    };\n    return Dir;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar BidiModule = /** @class */ (function () {\n    function BidiModule() {\n    }\n    BidiModule.decorators = [\n        { type: NgModule, args: [{\n                    exports: [Dir],\n                    declarations: [Dir],\n                    providers: [\n                        { provide: DIR_DOCUMENT, useExisting: DOCUMENT },\n                        Directionality,\n                    ]\n                },] },\n    ];\n    /** @nocollapse */\n    BidiModule.ctorParameters = function () { return []; };\n    return BidiModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Directionality, DIR_DOCUMENT, Dir, BidiModule };\n//# sourceMappingURL=bidi.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/bidi.es5.js\n// module id = null\n// module chunks = ","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar PAGE_UP = 33;\nvar PAGE_DOWN = 34;\nvar HOME = 36;\nvar END = 35;\nvar ENTER = 13;\nvar SPACE = 32;\nvar TAB = 9;\nvar ESCAPE = 27;\nvar BACKSPACE = 8;\nvar DELETE = 46;\nvar A = 65;\nvar Z = 90;\nvar ZERO = 48;\nvar NINE = 57;\nvar COMMA = 188;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, PAGE_UP, PAGE_DOWN, HOME, END, ENTER, SPACE, TAB, ESCAPE, BACKSPACE, DELETE, A, Z, ZERO, NINE, COMMA };\n//# sourceMappingURL=keycodes.es5.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@angular/cdk/esm5/keycodes.es5.js\n// module id = null\n// module chunks = ","import { InjectionToken } from '@angular/core';\nexport var CONTEXT_MENU_OPTIONS = new InjectionToken('CONTEXT_MENU_OPTIONS');\n//# sourceMappingURL=contextMenu.tokens.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.tokens.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { OverlayRef } from '@angular/cdk/overlay';\nimport { ChangeDetectorRef, Component, ElementRef, Inject, Input, Optional, Renderer, ViewChild, ViewChildren, } from '@angular/core';\nimport { EventEmitter, Output, QueryList, HostListener } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nvar ARROW_LEFT_KEYCODE = 37;\nvar ContextMenuContentComponent = (function () {\n    function ContextMenuContentComponent(changeDetector, elementRef, options, renderer) {\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.renderer = renderer;\n        this.menuItems = [];\n        this.isLeaf = false;\n        this.execute = new EventEmitter();\n        this.openSubMenu = new EventEmitter();\n        this.closeLeafMenu = new EventEmitter();\n        this.closeAllMenus = new EventEmitter();\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n    }\n    ContextMenuContentComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.menuItems.forEach(function (menuItem) {\n            menuItem.currentItem = _this.item;\n            _this.subscription.add(menuItem.execute.subscribe(function (event) { return _this.execute.emit(__assign({}, event, { menuItem: menuItem })); }));\n        });\n        var queryList = new QueryList();\n        queryList.reset(this.menuItems);\n        this._keyManager = new ActiveDescendantKeyManager(queryList).withWrap();\n    };\n    ContextMenuContentComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        if (this.autoFocus) {\n            setTimeout(function () { return _this.focus(); });\n        }\n        this.overlay.updatePosition();\n    };\n    ContextMenuContentComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuContentComponent.prototype.focus = function () {\n        if (this.autoFocus) {\n            this.menuElement.nativeElement.focus();\n        }\n    };\n    ContextMenuContentComponent.prototype.stopEvent = function ($event) {\n        $event.stopPropagation();\n    };\n    ContextMenuContentComponent.prototype.isMenuItemEnabled = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.enabled);\n    };\n    ContextMenuContentComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem && menuItem.visible);\n    };\n    ContextMenuContentComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuContentComponent.prototype.isDisabled = function (link) {\n        return link.enabled && !link.enabled(this.item);\n    };\n    ContextMenuContentComponent.prototype.onKeyEvent = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this._keyManager.onKeydown(event);\n    };\n    ContextMenuContentComponent.prototype.keyboardOpenSubMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onOpenSubMenu(menuItem);\n        }\n    };\n    ContextMenuContentComponent.prototype.keyboardMenuItemSelect = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        var menuItem = this.menuItems[this._keyManager.activeItemIndex];\n        if (menuItem) {\n            this.onMenuItemSelect(menuItem, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.onCloseLeafMenu = function (event) {\n        if (!this.isLeaf) {\n            return;\n        }\n        this.cancelEvent(event);\n        this.closeLeafMenu.emit({ exceptRootMenu: event.keyCode === ARROW_LEFT_KEYCODE, event: event });\n    };\n    ContextMenuContentComponent.prototype.closeMenu = function (event) {\n        if (event.type === 'click' && event.button === 2) {\n            return;\n        }\n        this.closeAllMenus.emit({ event: event });\n    };\n    ContextMenuContentComponent.prototype.onOpenSubMenu = function (menuItem, event) {\n        var anchorElementRef = this.menuItemElements.toArray()[this._keyManager.activeItemIndex];\n        var anchorElement = anchorElementRef && anchorElementRef.nativeElement;\n        this.openSubMenu.emit({\n            anchorElement: anchorElement,\n            contextMenu: menuItem.subMenu,\n            event: event,\n            item: this.item,\n            parentContextMenu: this,\n        });\n    };\n    ContextMenuContentComponent.prototype.onMenuItemSelect = function (menuItem, event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.onOpenSubMenu(menuItem, event);\n        if (!menuItem.subMenu) {\n            menuItem.triggerExecute(this.item, event);\n        }\n    };\n    ContextMenuContentComponent.prototype.cancelEvent = function (event) {\n        if (!event) {\n            return;\n        }\n        var target = event.target;\n        if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(target.tagName) > -1 || target.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuContentComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'context-menu-content',\n                    styles: [\n                        \".passive {\\n       display: block;\\n       padding: 3px 20px;\\n       clear: both;\\n       font-weight: normal;\\n       line-height: @line-height-base;\\n       white-space: nowrap;\\n     }\\n    .hasSubMenu:before {\\n      content: \\\"\\u25B6\\\";\\n      float: right;\\n    }\",\n                    ],\n                    template: \"<div class=\\\"dropdown open show ngx-contextmenu\\\" tabindex=\\\"0\\\">\\n      <ul #menu class=\\\"dropdown-menu show\\\" style=\\\"position: static; float: none;\\\" tabindex=\\\"0\\\">\\n        <li #li *ngFor=\\\"let menuItem of menuItems; let i = index\\\" [class.disabled]=\\\"!isMenuItemEnabled(menuItem)\\\"\\n            [class.divider]=\\\"menuItem.divider\\\" [class.dropdown-divider]=\\\"useBootstrap4 && menuItem.divider\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [attr.role]=\\\"menuItem.divider ? 'separator' : undefined\\\">\\n          <a *ngIf=\\\"!menuItem.divider && !menuItem.passive\\\" href [class.dropdown-item]=\\\"useBootstrap4\\\"\\n            [class.active]=\\\"menuItem.isActive && isMenuItemEnabled(menuItem)\\\"\\n            [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\" [class.hasSubMenu]=\\\"!!menuItem.subMenu\\\"\\n            (click)=\\\"onMenuItemSelect(menuItem, $event)\\\" (mouseenter)=\\\"onOpenSubMenu(menuItem, $event)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </a>\\n\\n          <span (click)=\\\"stopEvent($event)\\\" (contextmenu)=\\\"stopEvent($event)\\\" class=\\\"passive\\\"\\n                *ngIf=\\\"!menuItem.divider && menuItem.passive\\\" [class.dropdown-item]=\\\"useBootstrap4\\\"\\n                [class.disabled]=\\\"useBootstrap4 && !isMenuItemEnabled(menuItem)\\\">\\n            <ng-template [ngTemplateOutlet]=\\\"menuItem.template\\\" [ngTemplateOutletContext]=\\\"{ $implicit: item }\\\"></ng-template>\\n          </span>\\n        </li>\\n      </ul>\\n    </div>\\n  \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuContentComponent.ctorParameters = function () { return [\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n        { type: Renderer, },\n    ]; };\n    ContextMenuContentComponent.propDecorators = {\n        \"menuItems\": [{ type: Input },],\n        \"item\": [{ type: Input },],\n        \"event\": [{ type: Input },],\n        \"parentContextMenu\": [{ type: Input },],\n        \"overlay\": [{ type: Input },],\n        \"isLeaf\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n        \"openSubMenu\": [{ type: Output },],\n        \"closeLeafMenu\": [{ type: Output },],\n        \"closeAllMenus\": [{ type: Output },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n        \"menuItemElements\": [{ type: ViewChildren, args: ['li',] },],\n        \"onKeyEvent\": [{ type: HostListener, args: ['window:keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowUp', ['$event'],] },],\n        \"keyboardOpenSubMenu\": [{ type: HostListener, args: ['window:keydown.ArrowRight', ['$event'],] },],\n        \"keyboardMenuItemSelect\": [{ type: HostListener, args: ['window:keydown.Enter', ['$event'],] }, { type: HostListener, args: ['window:keydown.Space', ['$event'],] },],\n        \"onCloseLeafMenu\": [{ type: HostListener, args: ['window:keydown.Escape', ['$event'],] }, { type: HostListener, args: ['window:keydown.ArrowLeft', ['$event'],] },],\n        \"closeMenu\": [{ type: HostListener, args: ['document:click', ['$event'],] }, { type: HostListener, args: ['document:contextmenu', ['$event'],] },],\n    };\n    return ContextMenuContentComponent;\n}());\nexport { ContextMenuContentComponent };\n//# sourceMappingURL=contextMenuContent.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenuContent.component.js\n// module id = null\n// module chunks = ","import { Directive, ElementRef, EventEmitter, Input, Output, TemplateRef } from '@angular/core';\nvar ContextMenuItemDirective = (function () {\n    function ContextMenuItemDirective(template, elementRef) {\n        this.template = template;\n        this.elementRef = elementRef;\n        this.divider = false;\n        this.enabled = true;\n        this.passive = false;\n        this.visible = true;\n        this.execute = new EventEmitter();\n        this.isActive = false;\n    }\n    Object.defineProperty(ContextMenuItemDirective.prototype, \"disabled\", {\n        get: function () {\n            return this.passive ||\n                this.divider ||\n                !this.evaluateIfFunction(this.enabled, this.currentItem);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ContextMenuItemDirective.prototype.evaluateIfFunction = function (value, item) {\n        if (value instanceof Function) {\n            return value(item);\n        }\n        return value;\n    };\n    ContextMenuItemDirective.prototype.setActiveStyles = function () {\n        this.isActive = true;\n    };\n    ContextMenuItemDirective.prototype.setInactiveStyles = function () {\n        this.isActive = false;\n    };\n    ContextMenuItemDirective.prototype.triggerExecute = function (item, $event) {\n        if (!this.evaluateIfFunction(this.enabled, item)) {\n            return;\n        }\n        this.execute.emit({ event: $event, item: item });\n    };\n    ContextMenuItemDirective.decorators = [\n        { type: Directive, args: [{\n                    /* tslint:disable:directive-selector-type */\n                    selector: '[contextMenuItem]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuItemDirective.ctorParameters = function () { return [\n        { type: TemplateRef, },\n        { type: ElementRef, },\n    ]; };\n    ContextMenuItemDirective.propDecorators = {\n        \"subMenu\": [{ type: Input },],\n        \"divider\": [{ type: Input },],\n        \"enabled\": [{ type: Input },],\n        \"passive\": [{ type: Input },],\n        \"visible\": [{ type: Input },],\n        \"execute\": [{ type: Output },],\n    };\n    return ContextMenuItemDirective;\n}());\nexport { ContextMenuItemDirective };\n//# sourceMappingURL=contextMenu.item.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.item.directive.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { Overlay, ScrollStrategyOptions } from '@angular/cdk/overlay';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuService = (function () {\n    function ContextMenuService(overlay, scrollStrategy) {\n        this.overlay = overlay;\n        this.scrollStrategy = scrollStrategy;\n        this.isDestroyingLeafMenu = false;\n        this.show = new Subject();\n        this.triggerClose = new Subject();\n        this.close = new Subject();\n        this.overlays = [];\n        this.fakeElement = {\n            getBoundingClientRect: function () {\n                return ({\n                    bottom: 0,\n                    height: 0,\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    width: 0,\n                });\n            }\n        };\n    }\n    ContextMenuService.prototype.openContextMenu = function (context) {\n        var anchorElement = context.anchorElement, event = context.event, parentContextMenu = context.parentContextMenu;\n        if (!parentContextMenu) {\n            var mouseEvent_1 = event;\n            this.fakeElement.getBoundingClientRect = function () {\n                return ({\n                    bottom: mouseEvent_1.clientY,\n                    height: 0,\n                    left: mouseEvent_1.clientX,\n                    right: mouseEvent_1.clientX,\n                    top: mouseEvent_1.clientY,\n                    width: 0,\n                });\n            };\n            this.closeAllContextMenus({ eventType: 'cancel', event: event });\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: anchorElement || this.fakeElement }, { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })\n                .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });\n            this.overlays = [this.overlay.create({\n                    positionStrategy: positionStrategy,\n                    panelClass: 'ngx-contextmenu',\n                    scrollStrategy: this.scrollStrategy.close(),\n                })];\n            this.attachContextMenu(this.overlays[0], context);\n        }\n        else {\n            var positionStrategy = this.overlay.position().connectedTo({ nativeElement: event ? event.target : anchorElement }, { originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })\n                .withFallbackPosition({ originX: 'end', originY: 'bottom' }, { overlayX: 'start', overlayY: 'bottom' })\n                .withFallbackPosition({ originX: 'start', originY: 'bottom' }, { overlayX: 'end', overlayY: 'bottom' });\n            var newOverlay = this.overlay.create({\n                positionStrategy: positionStrategy,\n                panelClass: 'ngx-contextmenu',\n                scrollStrategy: this.scrollStrategy.close(),\n            });\n            this.destroySubMenus(parentContextMenu);\n            this.overlays = this.overlays.concat(newOverlay);\n            this.attachContextMenu(newOverlay, context);\n        }\n    };\n    ContextMenuService.prototype.attachContextMenu = function (overlay, context) {\n        var _this = this;\n        var event = context.event, item = context.item, menuItems = context.menuItems;\n        var contextMenuContent = overlay.attach(new ComponentPortal(ContextMenuContentComponent));\n        contextMenuContent.instance.event = event;\n        contextMenuContent.instance.item = item;\n        contextMenuContent.instance.menuItems = menuItems;\n        contextMenuContent.instance.overlay = overlay;\n        contextMenuContent.instance.isLeaf = true;\n        overlay.contextMenu = contextMenuContent.instance;\n        var subscriptions = new Subscription();\n        subscriptions.add(contextMenuContent.instance.execute.asObservable()\n            .subscribe(function (executeEvent) { return _this.closeAllContextMenus(__assign({ eventType: 'execute' }, executeEvent)); }));\n        subscriptions.add(contextMenuContent.instance.closeAllMenus.asObservable()\n            .subscribe(function (closeAllEvent) { return _this.closeAllContextMenus(__assign({ eventType: 'cancel' }, closeAllEvent)); }));\n        subscriptions.add(contextMenuContent.instance.closeLeafMenu.asObservable()\n            .subscribe(function (closeLeafMenuEvent) { return _this.destroyLeafMenu(closeLeafMenuEvent); }));\n        subscriptions.add(contextMenuContent.instance.openSubMenu.asObservable()\n            .subscribe(function (subMenuEvent) {\n            _this.destroySubMenus(contextMenuContent.instance);\n            if (!subMenuEvent.contextMenu) {\n                contextMenuContent.instance.isLeaf = true;\n                return;\n            }\n            contextMenuContent.instance.isLeaf = false;\n            _this.show.next(subMenuEvent);\n        }));\n        contextMenuContent.onDestroy(function () {\n            menuItems.forEach(function (menuItem) { return menuItem.isActive = false; });\n            subscriptions.unsubscribe();\n        });\n    };\n    ContextMenuService.prototype.closeAllContextMenus = function (closeEvent) {\n        if (this.overlays) {\n            this.close.next(closeEvent);\n            this.overlays.forEach(function (overlay, index) {\n                overlay.detach();\n                overlay.dispose();\n            });\n        }\n        this.overlays = [];\n    };\n    ContextMenuService.prototype.getLastAttachedOverlay = function () {\n        var overlay = this.overlays[this.overlays.length - 1];\n        while (this.overlays.length > 1 && overlay && !overlay.hasAttached()) {\n            overlay.detach();\n            overlay.dispose();\n            this.overlays = this.overlays.slice(0, -1);\n            overlay = this.overlays[this.overlays.length - 1];\n        }\n        return overlay;\n    };\n    ContextMenuService.prototype.destroyLeafMenu = function (_a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, exceptRootMenu = _b.exceptRootMenu, event = _b.event;\n        if (this.isDestroyingLeafMenu) {\n            return;\n        }\n        this.isDestroyingLeafMenu = true;\n        setTimeout(function () {\n            var overlay = _this.getLastAttachedOverlay();\n            if (_this.overlays.length > 1 && overlay) {\n                overlay.detach();\n                overlay.dispose();\n            }\n            if (!exceptRootMenu && _this.overlays.length > 0 && overlay) {\n                _this.close.next({ eventType: 'cancel', event: event });\n                overlay.detach();\n                overlay.dispose();\n            }\n            var newLeaf = _this.getLastAttachedOverlay();\n            if (newLeaf) {\n                newLeaf.contextMenu.isLeaf = true;\n            }\n            _this.isDestroyingLeafMenu = false;\n        });\n    };\n    ContextMenuService.prototype.destroySubMenus = function (contextMenu) {\n        var overlay = contextMenu.overlay;\n        var index = this.overlays.indexOf(overlay);\n        this.overlays.slice(index + 1).forEach(function (subMenuOverlay) {\n            subMenuOverlay.detach();\n            subMenuOverlay.dispose();\n        });\n    };\n    ContextMenuService.prototype.isLeafMenu = function (contextMenuContent) {\n        var overlay = this.getLastAttachedOverlay();\n        return contextMenuContent.overlay === overlay;\n    };\n    ContextMenuService.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    ContextMenuService.ctorParameters = function () { return [\n        { type: Overlay, },\n        { type: ScrollStrategyOptions, },\n    ]; };\n    return ContextMenuService;\n}());\nexport { ContextMenuService };\n//# sourceMappingURL=contextMenu.service.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.service.js\n// module id = null\n// module chunks = ","var __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nimport { ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Optional, Output, QueryList, ViewChild, ViewEncapsulation, } from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\nimport { first } from 'rxjs/operators';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nvar ContextMenuComponent = (function () {\n    function ContextMenuComponent(_contextMenuService, changeDetector, elementRef, options) {\n        var _this = this;\n        this._contextMenuService = _contextMenuService;\n        this.changeDetector = changeDetector;\n        this.elementRef = elementRef;\n        this.options = options;\n        this.autoFocus = false;\n        this.useBootstrap4 = false;\n        this.disabled = false;\n        this.close = new EventEmitter();\n        this.open = new EventEmitter();\n        this.visibleMenuItems = [];\n        this.links = [];\n        this.subscription = new Subscription();\n        if (options) {\n            this.autoFocus = options.autoFocus;\n            this.useBootstrap4 = options.useBootstrap4;\n        }\n        this.subscription.add(_contextMenuService.show.subscribe(function (menuEvent) {\n            _this.onMenuEvent(menuEvent);\n        }));\n    }\n    ContextMenuComponent.prototype.ngOnDestroy = function () {\n        this.subscription.unsubscribe();\n    };\n    ContextMenuComponent.prototype.onMenuEvent = function (menuEvent) {\n        var _this = this;\n        if (this.disabled) {\n            return;\n        }\n        var contextMenu = menuEvent.contextMenu, event = menuEvent.event, item = menuEvent.item;\n        if (contextMenu && contextMenu !== this) {\n            return;\n        }\n        this.event = event;\n        this.item = item;\n        this.setVisibleMenuItems();\n        this._contextMenuService.openContextMenu(__assign({}, menuEvent, { menuItems: this.visibleMenuItems }));\n        this._contextMenuService.close.asObservable().pipe(first()).subscribe(function (closeEvent) { return _this.close.emit(closeEvent); });\n        this.open.emit(menuEvent);\n    };\n    ContextMenuComponent.prototype.isMenuItemVisible = function (menuItem) {\n        return this.evaluateIfFunction(menuItem.visible);\n    };\n    ContextMenuComponent.prototype.setVisibleMenuItems = function () {\n        var _this = this;\n        this.visibleMenuItems = this.menuItems.filter(function (menuItem) { return _this.isMenuItemVisible(menuItem); });\n    };\n    ContextMenuComponent.prototype.evaluateIfFunction = function (value) {\n        if (value instanceof Function) {\n            return value(this.item);\n        }\n        return value;\n    };\n    ContextMenuComponent.decorators = [\n        { type: Component, args: [{\n                    encapsulation: ViewEncapsulation.None,\n                    selector: 'context-menu',\n                    styles: [\"\\n    .cdk-overlay-container {\\n      position: fixed;\\n      z-index: 1000;\\n      pointer-events: none;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n    }\\n    .ngx-contextmenu.cdk-overlay-pane {\\n      position: absolute;\\n      pointer-events: auto;\\n      box-sizing: border-box;\\n    }\\n  \"],\n                    template: \" \",\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuComponent.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n        { type: ChangeDetectorRef, },\n        { type: ElementRef, },\n        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_OPTIONS,] },] },\n    ]; };\n    ContextMenuComponent.propDecorators = {\n        \"autoFocus\": [{ type: Input },],\n        \"useBootstrap4\": [{ type: Input },],\n        \"disabled\": [{ type: Input },],\n        \"close\": [{ type: Output },],\n        \"open\": [{ type: Output },],\n        \"menuItems\": [{ type: ContentChildren, args: [ContextMenuItemDirective,] },],\n        \"menuElement\": [{ type: ViewChild, args: ['menu',] },],\n    };\n    return ContextMenuComponent;\n}());\nexport { ContextMenuComponent };\n//# sourceMappingURL=contextMenu.component.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.component.js\n// module id = null\n// module chunks = ","import { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuService } from './contextMenu.service';\nimport { Directive, HostListener, Input } from '@angular/core';\nvar ContextMenuAttachDirective = (function () {\n    function ContextMenuAttachDirective(contextMenuService) {\n        this.contextMenuService = contextMenuService;\n    }\n    ContextMenuAttachDirective.prototype.onContextMenu = function (event) {\n        this.contextMenuService.show.next({\n            contextMenu: this.contextMenu,\n            event: event,\n            item: this.contextMenuSubject,\n        });\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    ContextMenuAttachDirective.decorators = [\n        { type: Directive, args: [{\n                    selector: '[contextMenu]',\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuAttachDirective.ctorParameters = function () { return [\n        { type: ContextMenuService, },\n    ]; };\n    ContextMenuAttachDirective.propDecorators = {\n        \"contextMenuSubject\": [{ type: Input },],\n        \"contextMenu\": [{ type: Input },],\n        \"onContextMenu\": [{ type: HostListener, args: ['contextmenu', ['$event'],] },],\n    };\n    return ContextMenuAttachDirective;\n}());\nexport { ContextMenuAttachDirective };\n//# sourceMappingURL=contextMenu.attach.directive.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/contextMenu.attach.directive.js\n// module id = null\n// module chunks = ","import { Component, ChangeDetectionStrategy } from '@angular/core';\nimport { CalendarEvent } from 'angular-calendar';\nimport { Subject } from 'rxjs/Subject';\nimport { colors } from '../demo-utils/colors';\n\n@Component({\n  selector: 'mwl-demo-component',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  templateUrl: 'template.html',\n  styles: [\n    `\n    .fill-height {\n      flex: 1;\n      display: flex;\n      flex-direction: column;\n      align-items: stretch;\n    }\n  `\n  ]\n})\nexport class DemoComponent {\n  view: string = 'month';\n\n  viewDate: Date = new Date();\n\n  events: CalendarEvent[] = [];\n\n  refresh: Subject<any> = new Subject();\n\n  addEvent(date: Date): void {\n    this.events.push({\n      start: date,\n      title: 'New event',\n      color: colors.red\n    });\n    this.refresh.next();\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./demos/demo-modules/context-menu/component.ts","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { ContextMenuAttachDirective } from './contextMenu.attach.directive';\nimport { ContextMenuComponent } from './contextMenu.component';\nimport { ContextMenuItemDirective } from './contextMenu.item.directive';\nimport { ContextMenuService } from './contextMenu.service';\nimport { CONTEXT_MENU_OPTIONS } from './contextMenu.tokens';\nimport { ContextMenuContentComponent } from './contextMenuContent.component';\nvar ContextMenuModule = (function () {\n    function ContextMenuModule() {\n    }\n    ContextMenuModule.forRoot = function (options) {\n        return {\n            ngModule: ContextMenuModule,\n            providers: [\n                ContextMenuService,\n                {\n                    provide: CONTEXT_MENU_OPTIONS,\n                    useValue: options,\n                },\n            ],\n        };\n    };\n    ContextMenuModule.decorators = [\n        { type: NgModule, args: [{\n                    declarations: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuContentComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    entryComponents: [\n                        ContextMenuContentComponent,\n                    ],\n                    exports: [\n                        ContextMenuAttachDirective,\n                        ContextMenuComponent,\n                        ContextMenuItemDirective,\n                    ],\n                    imports: [\n                        CommonModule,\n                        OverlayModule,\n                    ],\n                },] },\n    ];\n    /** @nocollapse */\n    ContextMenuModule.ctorParameters = function () { return []; };\n    return ContextMenuModule;\n}());\nexport { ContextMenuModule };\n//# sourceMappingURL=ngx-contextmenu.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ngx-contextmenu/lib/ngx-contextmenu.js\n// module id = null\n// module chunks = ","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./module\";\nimport * as i2 from \"../../../src/modules/common/calendar-tooltip.directive.ngfactory\";\nimport * as i3 from \"../../../node_modules/ngx-contextmenu/lib/contextMenuContent.component.ngfactory\";\nimport * as i4 from \"../../../node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker.ngfactory\";\nimport * as i5 from \"./component.ngfactory\";\nimport * as i6 from \"@angular/common\";\nimport * as i7 from \"@angular/cdk/bidi\";\nimport * as i8 from \"@angular/cdk/platform\";\nimport * as i9 from \"@angular/cdk/scrolling\";\nimport * as i10 from \"@angular/cdk/overlay\";\nimport * as i11 from \"@angular/forms\";\nimport * as i12 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-calendar\";\nimport * as i13 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-i18n\";\nimport * as i14 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-parser-formatter\";\nimport * as i15 from \"@ng-bootstrap/ng-bootstrap/datepicker/ngb-date-adapter\";\nimport * as i16 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker-config\";\nimport * as i17 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker-config\";\nimport * as i18 from \"angular-draggable-droppable\";\nimport * as i19 from \"../../../src/modules/common/calendar-event-title-formatter.provider\";\nimport * as i20 from \"../../../src/modules/common/calendar-date-formatter.provider\";\nimport * as i21 from \"../../../src/modules/common/calendar-utils.provider\";\nimport * as i22 from \"ngx-contextmenu/lib/contextMenu.service\";\nimport * as i23 from \"../../../src/modules/common/calendar-common.module\";\nimport * as i24 from \"../../../src/modules/month/calendar-month.module\";\nimport * as i25 from \"angular-resizable-element\";\nimport * as i26 from \"../../../src/modules/week/calendar-week.module\";\nimport * as i27 from \"../../../src/modules/day/calendar-day.module\";\nimport * as i28 from \"../../../src/modules/calendar.module\";\nimport * as i29 from \"@angular/cdk/portal\";\nimport * as i30 from \"ngx-contextmenu/lib/ngx-contextmenu\";\nimport * as i31 from \"@ng-bootstrap/ng-bootstrap/datepicker/datepicker.module\";\nimport * as i32 from \"@ng-bootstrap/ng-bootstrap/timepicker/timepicker.module\";\nimport * as i33 from \"../demo-utils/module\";\nimport * as i34 from \"@angular/router\";\nimport * as i35 from \"ngx-contextmenu/lib/contextMenu.tokens\";\nimport * as i36 from \"./component\";\nvar DemoModuleNgFactory = i0.ɵcmf(i1.DemoModule, [], function (_l) { return i0.ɵmod([i0.ɵmpd(512, i0.ComponentFactoryResolver, i0.ɵCodegenComponentFactoryResolver, [[8, [i2.CalendarTooltipWindowComponentNgFactory, i3.ContextMenuContentComponentNgFactory, i4.NgbDatepickerNgFactory, i5.DemoComponentNgFactory]], [3, i0.ComponentFactoryResolver], i0.NgModuleRef]), i0.ɵmpd(4608, i6.NgLocalization, i6.NgLocaleLocalization, [i0.LOCALE_ID, [2, i6.ɵa]]), i0.ɵmpd(6144, i7.DIR_DOCUMENT, null, [i6.DOCUMENT]), i0.ɵmpd(4608, i7.Directionality, i7.Directionality, [[2, i7.DIR_DOCUMENT]]), i0.ɵmpd(4608, i8.Platform, i8.Platform, []), i0.ɵmpd(5120, i9.ScrollDispatcher, i9.SCROLL_DISPATCHER_PROVIDER_FACTORY, [[3, i9.ScrollDispatcher], i0.NgZone, i8.Platform]), i0.ɵmpd(5120, i9.ViewportRuler, i9.VIEWPORT_RULER_PROVIDER_FACTORY, [[3, i9.ViewportRuler], i8.Platform, i0.NgZone]), i0.ɵmpd(4608, i10.ScrollStrategyOptions, i10.ScrollStrategyOptions, [i9.ScrollDispatcher, i9.ViewportRuler, i0.NgZone, i6.DOCUMENT]), i0.ɵmpd(5120, i10.OverlayContainer, i10.ɵa, [[3, i10.OverlayContainer], i6.DOCUMENT]), i0.ɵmpd(4608, i10.OverlayPositionBuilder, i10.OverlayPositionBuilder, [i9.ViewportRuler, i6.DOCUMENT]), i0.ɵmpd(5120, i10.OverlayKeyboardDispatcher, i10.ɵf, [[3, i10.OverlayKeyboardDispatcher], i6.DOCUMENT]), i0.ɵmpd(4608, i10.Overlay, i10.Overlay, [i10.ScrollStrategyOptions, i10.OverlayContainer, i0.ComponentFactoryResolver, i10.OverlayPositionBuilder, i10.OverlayKeyboardDispatcher, i0.ApplicationRef, i0.Injector, i0.NgZone, i6.DOCUMENT]), i0.ɵmpd(5120, i10.ɵc, i10.ɵd, [i10.Overlay]), i0.ɵmpd(4608, i11.ɵi, i11.ɵi, []), i0.ɵmpd(4608, i12.NgbCalendar, i12.NgbCalendarGregorian, []), i0.ɵmpd(4608, i13.NgbDatepickerI18n, i13.NgbDatepickerI18nDefault, []), i0.ɵmpd(4608, i14.NgbDateParserFormatter, i14.NgbDateISOParserFormatter, []), i0.ɵmpd(4608, i15.NgbDateAdapter, i15.NgbDateStructAdapter, []), i0.ɵmpd(4608, i16.NgbDatepickerConfig, i16.NgbDatepickerConfig, []), i0.ɵmpd(4608, i17.NgbTimepickerConfig, i17.NgbTimepickerConfig, []), i0.ɵmpd(4608, i18.DraggableHelper, i18.DraggableHelper, []), i0.ɵmpd(4608, i19.CalendarEventTitleFormatter, i19.CalendarEventTitleFormatter, []), i0.ɵmpd(4608, i20.CalendarDateFormatter, i20.CalendarDateFormatter, []), i0.ɵmpd(4608, i21.CalendarUtils, i21.CalendarUtils, []), i0.ɵmpd(4608, i22.ContextMenuService, i22.ContextMenuService, [i10.Overlay, i10.ScrollStrategyOptions]), i0.ɵmpd(512, i6.CommonModule, i6.CommonModule, []), i0.ɵmpd(512, i23.CalendarCommonModule, i23.CalendarCommonModule, []), i0.ɵmpd(512, i18.DragAndDropModule, i18.DragAndDropModule, []), i0.ɵmpd(512, i24.CalendarMonthModule, i24.CalendarMonthModule, []), i0.ɵmpd(512, i25.ResizableModule, i25.ResizableModule, []), i0.ɵmpd(512, i26.CalendarWeekModule, i26.CalendarWeekModule, []), i0.ɵmpd(512, i27.CalendarDayModule, i27.CalendarDayModule, []), i0.ɵmpd(512, i28.CalendarModule, i28.CalendarModule, []), i0.ɵmpd(512, i7.BidiModule, i7.BidiModule, []), i0.ɵmpd(512, i29.PortalModule, i29.PortalModule, []), i0.ɵmpd(512, i8.PlatformModule, i8.PlatformModule, []), i0.ɵmpd(512, i9.ScrollDispatchModule, i9.ScrollDispatchModule, []), i0.ɵmpd(512, i10.OverlayModule, i10.OverlayModule, []), i0.ɵmpd(512, i30.ContextMenuModule, i30.ContextMenuModule, []), i0.ɵmpd(512, i11.ɵba, i11.ɵba, []), i0.ɵmpd(512, i11.FormsModule, i11.FormsModule, []), i0.ɵmpd(512, i31.NgbDatepickerModule, i31.NgbDatepickerModule, []), i0.ɵmpd(512, i32.NgbTimepickerModule, i32.NgbTimepickerModule, []), i0.ɵmpd(512, i33.DemoUtilsModule, i33.DemoUtilsModule, []), i0.ɵmpd(512, i34.RouterModule, i34.RouterModule, [[2, i34.ɵa], [2, i34.Router]]), i0.ɵmpd(512, i1.DemoModule, i1.DemoModule, []), i0.ɵmpd(256, i35.CONTEXT_MENU_OPTIONS, { useBootstrap4: true }, []), i0.ɵmpd(1024, i34.ROUTES, function () { return [[{ path: \"\", component: i36.DemoComponent }]]; }, [])]); });\nexport { DemoModuleNgFactory as DemoModuleNgFactory };\n//# sourceMappingURL=module.ngfactory.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./demos/demo-modules/context-menu/module.ngfactory.js\n// module id = null\n// module chunks = ","\"use strict\";\nfunction isDate(value) {\n    return value instanceof Date && !isNaN(+value);\n}\nexports.isDate = isDate;\n//# sourceMappingURL=isDate.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/isDate.js\n// module id = 710\n// module chunks = 1","\"use strict\";\nvar isScheduler_1 = require('../util/isScheduler');\nvar of_1 = require('./of');\nvar from_1 = require('./from');\nvar concatAll_1 = require('../operators/concatAll');\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n        return from_1.from(observables[0]);\n    }\n    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/concat.js\n// module id = 712\n// module chunks = 1","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar audit_1 = require('./audit');\nvar timer_1 = require('../observable/timer');\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source values, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * <img src=\"./img/auditTime.png\" width=\"100%\">\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.auditTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} duration Time to wait before emitting the most recent source\n * value, measured in milliseconds or the time unit determined internally\n * by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the rate-limiting behavior.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method auditTime\n * @owner Observable\n */\nfunction auditTime(duration, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n}\nexports.auditTime = auditTime;\n//# sourceMappingURL=auditTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/auditTime.js\n// module id = 713\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/audit.png\" width=\"100%\">\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value or completes, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return {Observable<T>} An Observable that performs rate-limiting of\n * emissions from the source Observable.\n * @method audit\n * @owner Observable\n */\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nexports.audit = audit;\nvar AuditOperator = (function () {\n    function AuditOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    AuditOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n    };\n    return AuditOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AuditSubscriber = (function (_super) {\n    __extends(AuditSubscriber, _super);\n    function AuditSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    AuditSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n            if (duration === errorObject_1.errorObject) {\n                this.destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                if (innerSubscription.closed) {\n                    this.clearThrottle();\n                }\n                else {\n                    this.add(this.throttled = innerSubscription);\n                }\n            }\n        }\n    };\n    AuditSubscriber.prototype.clearThrottle = function () {\n        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = null;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = null;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    };\n    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        this.clearThrottle();\n    };\n    AuditSubscriber.prototype.notifyComplete = function () {\n        this.clearThrottle();\n    };\n    return AuditSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=audit.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/audit.js\n// module id = 714\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nfunction debounceTime(dueTime, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n}\nexports.debounceTime = debounceTime;\nvar DebounceTimeOperator = (function () {\n    function DebounceTimeOperator(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    DebounceTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    };\n    return DebounceTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceTimeSubscriber = (function (_super) {\n    __extends(DebounceTimeSubscriber, _super);\n    function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n        _super.call(this, destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    DebounceTimeSubscriber.prototype._next = function (value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    };\n    DebounceTimeSubscriber.prototype._complete = function () {\n        this.debouncedNext();\n        this.destination.complete();\n    };\n    DebounceTimeSubscriber.prototype.debouncedNext = function () {\n        this.clearDebounce();\n        if (this.hasValue) {\n            this.destination.next(this.lastValue);\n            this.lastValue = null;\n            this.hasValue = false;\n        }\n    };\n    DebounceTimeSubscriber.prototype.clearDebounce = function () {\n        var debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    };\n    return DebounceTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounceTime.js\n// module id = 715\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar isArray_1 = require('../util/isArray');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar none = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nfunction combineLatest() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = null;\n    if (typeof observables[observables.length - 1] === 'function') {\n        project = observables.pop();\n    }\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n        observables = observables[0].slice();\n    }\n    return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };\n}\nexports.combineLatest = combineLatest;\nvar CombineLatestOperator = (function () {\n    function CombineLatestOperator(project) {\n        this.project = project;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n    };\n    return CombineLatestOperator;\n}());\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, project) {\n        _super.call(this, destination);\n        this.project = project;\n        this.active = 0;\n        this.values = [];\n        this.observables = [];\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(none);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === none ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.project) {\n                this._tryProject(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryProject = function (values) {\n        var result;\n        try {\n            result = this.project.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.CombineLatestSubscriber = CombineLatestSubscriber;\n//# sourceMappingURL=combineLatest.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/combineLatest.js\n// module id = 716\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * <img src=\"./img/find.png\" width=\"100%\">\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found.\n *\n * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable<T>} An Observable of the first item that matches the\n * condition.\n * @method find\n * @owner Observable\n */\nfunction find(predicate, thisArg) {\n    if (typeof predicate !== 'function') {\n        throw new TypeError('predicate is not a function');\n    }\n    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };\n}\nexports.find = find;\nvar FindValueOperator = (function () {\n    function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n    }\n    FindValueOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n    };\n    return FindValueOperator;\n}());\nexports.FindValueOperator = FindValueOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FindValueSubscriber = (function (_super) {\n    __extends(FindValueSubscriber, _super);\n    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.yieldIndex = yieldIndex;\n        this.thisArg = thisArg;\n        this.index = 0;\n    }\n    FindValueSubscriber.prototype.notifyComplete = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    FindValueSubscriber.prototype._next = function (value) {\n        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n        var index = this.index++;\n        try {\n            var result = predicate.call(thisArg || this, value, index, this.source);\n            if (result) {\n                this.notifyComplete(this.yieldIndex ? index : value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    FindValueSubscriber.prototype._complete = function () {\n        this.notifyComplete(this.yieldIndex ? -1 : undefined);\n    };\n    return FindValueSubscriber;\n}(Subscriber_1.Subscriber));\nexports.FindValueSubscriber = FindValueSubscriber;\n//# sourceMappingURL=find.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/find.js\n// module id = 717\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar queue_1 = require('./scheduler/queue');\nvar Subscription_1 = require('./Subscription');\nvar observeOn_1 = require('./operators/observeOn');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nvar SubjectSubscription_1 = require('./SubjectSubscription');\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n        _super.call(this);\n        this.scheduler = scheduler;\n        this._events = [];\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n    }\n    ReplaySubject.prototype.next = function (value) {\n        var now = this._getNow();\n        this._events.push(new ReplayEvent(now, value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _events = this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscription = Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n        }\n        var len = _events.length;\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n            subscriber.next(_events[i].value);\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue_1.queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject_1.Subject));\nexports.ReplaySubject = ReplaySubject;\nvar ReplayEvent = (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/ReplaySubject.js\n// module id = 718\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar isArray_1 = require('../util/isArray');\nvar Subscriber_1 = require('../Subscriber');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar iterator_1 = require('../symbol/iterator');\n/* tslint:enable:max-line-length */\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nfunction zip() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function zipOperatorFunction(source) {\n        return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.zip = zip;\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nfunction zipStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var project = observables[observables.length - 1];\n    if (typeof project === 'function') {\n        observables.pop();\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\nexports.zipStatic = zipStatic;\nvar ZipOperator = (function () {\n    function ZipOperator(project) {\n        this.project = project;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.project));\n    };\n    return ZipOperator;\n}());\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, project, values) {\n        if (values === void 0) { values = Object.create(null); }\n        _super.call(this, destination);\n        this.iterators = [];\n        this.active = 0;\n        this.project = (typeof project === 'function') ? project : null;\n        this.values = values;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray_1.isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator_1.iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (iterator.stillUnsubscribed) {\n                this.add(iterator.subscribe(iterator, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator = iterators[i];\n            var result = iterator.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.project) {\n            this._tryProject(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber_1.Subscriber));\nexports.ZipSubscriber = ZipSubscriber;\nvar StaticIterator = (function () {\n    function StaticIterator(iterator) {\n        this.iterator = iterator;\n        this.nextResult = iterator.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        _super.call(this, destination);\n        this.parent = parent;\n        this.observable = observable;\n        this.stillUnsubscribed = true;\n        this.buffer = [];\n        this.isComplete = false;\n    }\n    ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=zip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/zip.js\n// module id = 719\n// module chunks = 1","\"use strict\";\nvar TimerObservable_1 = require('./TimerObservable');\nexports.timer = TimerObservable_1.TimerObservable.create;\n//# sourceMappingURL=timer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/timer.js\n// module id = 723\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isNumeric_1 = require('../util/isNumeric');\nvar Observable_1 = require('../Observable');\nvar async_1 = require('../scheduler/async');\nvar isScheduler_1 = require('../util/isScheduler');\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar TimerObservable = (function (_super) {\n    __extends(TimerObservable, _super);\n    function TimerObservable(dueTime, period, scheduler) {\n        if (dueTime === void 0) { dueTime = 0; }\n        _super.call(this);\n        this.period = -1;\n        this.dueTime = 0;\n        if (isNumeric_1.isNumeric(period)) {\n            this.period = Number(period) < 1 && 1 || Number(period);\n        }\n        else if (isScheduler_1.isScheduler(period)) {\n            scheduler = period;\n        }\n        if (!isScheduler_1.isScheduler(scheduler)) {\n            scheduler = async_1.async;\n        }\n        this.scheduler = scheduler;\n        this.dueTime = isDate_1.isDate(dueTime) ?\n            (+dueTime - this.scheduler.now()) :\n            dueTime;\n    }\n    /**\n     * Creates an Observable that starts emitting after an `initialDelay` and\n     * emits ever increasing numbers after each `period` of time thereafter.\n     *\n     * <span class=\"informal\">Its like {@link interval}, but you can specify when\n     * should the emissions start.</span>\n     *\n     * <img src=\"./img/timer.png\" width=\"100%\">\n     *\n     * `timer` returns an Observable that emits an infinite sequence of ascending\n     * integers, with a constant interval of time, `period` of your choosing\n     * between those emissions. The first emission happens after the specified\n     * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n     * operator uses the `async` IScheduler to provide a notion of time, but you\n     * may pass any IScheduler to it. If `period` is not specified, the output\n     * Observable emits only one value, `0`. Otherwise, it emits an infinite\n     * sequence.\n     *\n     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n     * var numbers = Rx.Observable.timer(3000, 1000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits one number after five seconds</caption>\n     * var numbers = Rx.Observable.timer(5000);\n     * numbers.subscribe(x => console.log(x));\n     *\n     * @see {@link interval}\n     * @see {@link delay}\n     *\n     * @param {number|Date} initialDelay The initial delay time to wait before\n     * emitting the first value of `0`.\n     * @param {number} [period] The period of time between emissions of the\n     * subsequent numbers.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n     * the emission of values, and providing a notion of \"time\".\n     * @return {Observable} An Observable that emits a `0` after the\n     * `initialDelay` and ever increasing numbers after each `period` of time\n     * thereafter.\n     * @static true\n     * @name timer\n     * @owner Observable\n     */\n    TimerObservable.create = function (initialDelay, period, scheduler) {\n        if (initialDelay === void 0) { initialDelay = 0; }\n        return new TimerObservable(initialDelay, period, scheduler);\n    };\n    TimerObservable.dispatch = function (state) {\n        var index = state.index, period = state.period, subscriber = state.subscriber;\n        var action = this;\n        subscriber.next(index);\n        if (subscriber.closed) {\n            return;\n        }\n        else if (period === -1) {\n            return subscriber.complete();\n        }\n        state.index = index + 1;\n        action.schedule(state, period);\n    };\n    TimerObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n        return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n            index: index, period: period, subscriber: subscriber\n        });\n    };\n    return TimerObservable;\n}(Observable_1.Observable));\nexports.TimerObservable = TimerObservable;\n//# sourceMappingURL=TimerObservable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/TimerObservable.js\n// module id = 724\n// module chunks = 1","\"use strict\";\nvar audit_1 = require('./operators/audit');\nexports.audit = audit_1.audit;\nvar auditTime_1 = require('./operators/auditTime');\nexports.auditTime = auditTime_1.auditTime;\nvar buffer_1 = require('./operators/buffer');\nexports.buffer = buffer_1.buffer;\nvar bufferCount_1 = require('./operators/bufferCount');\nexports.bufferCount = bufferCount_1.bufferCount;\nvar bufferTime_1 = require('./operators/bufferTime');\nexports.bufferTime = bufferTime_1.bufferTime;\nvar bufferToggle_1 = require('./operators/bufferToggle');\nexports.bufferToggle = bufferToggle_1.bufferToggle;\nvar bufferWhen_1 = require('./operators/bufferWhen');\nexports.bufferWhen = bufferWhen_1.bufferWhen;\nvar catchError_1 = require('./operators/catchError');\nexports.catchError = catchError_1.catchError;\nvar combineAll_1 = require('./operators/combineAll');\nexports.combineAll = combineAll_1.combineAll;\nvar combineLatest_1 = require('./operators/combineLatest');\nexports.combineLatest = combineLatest_1.combineLatest;\nvar concat_1 = require('./operators/concat');\nexports.concat = concat_1.concat;\nvar concatAll_1 = require('./operators/concatAll');\nexports.concatAll = concatAll_1.concatAll;\nvar concatMap_1 = require('./operators/concatMap');\nexports.concatMap = concatMap_1.concatMap;\nvar concatMapTo_1 = require('./operators/concatMapTo');\nexports.concatMapTo = concatMapTo_1.concatMapTo;\nvar count_1 = require('./operators/count');\nexports.count = count_1.count;\nvar debounce_1 = require('./operators/debounce');\nexports.debounce = debounce_1.debounce;\nvar debounceTime_1 = require('./operators/debounceTime');\nexports.debounceTime = debounceTime_1.debounceTime;\nvar defaultIfEmpty_1 = require('./operators/defaultIfEmpty');\nexports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\nvar delay_1 = require('./operators/delay');\nexports.delay = delay_1.delay;\nvar delayWhen_1 = require('./operators/delayWhen');\nexports.delayWhen = delayWhen_1.delayWhen;\nvar dematerialize_1 = require('./operators/dematerialize');\nexports.dematerialize = dematerialize_1.dematerialize;\nvar distinct_1 = require('./operators/distinct');\nexports.distinct = distinct_1.distinct;\nvar distinctUntilChanged_1 = require('./operators/distinctUntilChanged');\nexports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\nvar distinctUntilKeyChanged_1 = require('./operators/distinctUntilKeyChanged');\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\nvar elementAt_1 = require('./operators/elementAt');\nexports.elementAt = elementAt_1.elementAt;\nvar every_1 = require('./operators/every');\nexports.every = every_1.every;\nvar exhaust_1 = require('./operators/exhaust');\nexports.exhaust = exhaust_1.exhaust;\nvar exhaustMap_1 = require('./operators/exhaustMap');\nexports.exhaustMap = exhaustMap_1.exhaustMap;\nvar expand_1 = require('./operators/expand');\nexports.expand = expand_1.expand;\nvar filter_1 = require('./operators/filter');\nexports.filter = filter_1.filter;\nvar finalize_1 = require('./operators/finalize');\nexports.finalize = finalize_1.finalize;\nvar find_1 = require('./operators/find');\nexports.find = find_1.find;\nvar findIndex_1 = require('./operators/findIndex');\nexports.findIndex = findIndex_1.findIndex;\nvar first_1 = require('./operators/first');\nexports.first = first_1.first;\nvar groupBy_1 = require('./operators/groupBy');\nexports.groupBy = groupBy_1.groupBy;\nvar ignoreElements_1 = require('./operators/ignoreElements');\nexports.ignoreElements = ignoreElements_1.ignoreElements;\nvar isEmpty_1 = require('./operators/isEmpty');\nexports.isEmpty = isEmpty_1.isEmpty;\nvar last_1 = require('./operators/last');\nexports.last = last_1.last;\nvar map_1 = require('./operators/map');\nexports.map = map_1.map;\nvar mapTo_1 = require('./operators/mapTo');\nexports.mapTo = mapTo_1.mapTo;\nvar materialize_1 = require('./operators/materialize');\nexports.materialize = materialize_1.materialize;\nvar max_1 = require('./operators/max');\nexports.max = max_1.max;\nvar merge_1 = require('./operators/merge');\nexports.merge = merge_1.merge;\nvar mergeAll_1 = require('./operators/mergeAll');\nexports.mergeAll = mergeAll_1.mergeAll;\nvar mergeMap_1 = require('./operators/mergeMap');\nexports.mergeMap = mergeMap_1.mergeMap;\nvar mergeMap_2 = require('./operators/mergeMap');\nexports.flatMap = mergeMap_2.mergeMap;\nvar mergeMapTo_1 = require('./operators/mergeMapTo');\nexports.mergeMapTo = mergeMapTo_1.mergeMapTo;\nvar mergeScan_1 = require('./operators/mergeScan');\nexports.mergeScan = mergeScan_1.mergeScan;\nvar min_1 = require('./operators/min');\nexports.min = min_1.min;\nvar multicast_1 = require('./operators/multicast');\nexports.multicast = multicast_1.multicast;\nvar observeOn_1 = require('./operators/observeOn');\nexports.observeOn = observeOn_1.observeOn;\nvar onErrorResumeNext_1 = require('./operators/onErrorResumeNext');\nexports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\nvar pairwise_1 = require('./operators/pairwise');\nexports.pairwise = pairwise_1.pairwise;\nvar partition_1 = require('./operators/partition');\nexports.partition = partition_1.partition;\nvar pluck_1 = require('./operators/pluck');\nexports.pluck = pluck_1.pluck;\nvar publish_1 = require('./operators/publish');\nexports.publish = publish_1.publish;\nvar publishBehavior_1 = require('./operators/publishBehavior');\nexports.publishBehavior = publishBehavior_1.publishBehavior;\nvar publishLast_1 = require('./operators/publishLast');\nexports.publishLast = publishLast_1.publishLast;\nvar publishReplay_1 = require('./operators/publishReplay');\nexports.publishReplay = publishReplay_1.publishReplay;\nvar race_1 = require('./operators/race');\nexports.race = race_1.race;\nvar reduce_1 = require('./operators/reduce');\nexports.reduce = reduce_1.reduce;\nvar repeat_1 = require('./operators/repeat');\nexports.repeat = repeat_1.repeat;\nvar repeatWhen_1 = require('./operators/repeatWhen');\nexports.repeatWhen = repeatWhen_1.repeatWhen;\nvar retry_1 = require('./operators/retry');\nexports.retry = retry_1.retry;\nvar retryWhen_1 = require('./operators/retryWhen');\nexports.retryWhen = retryWhen_1.retryWhen;\nvar refCount_1 = require('./operators/refCount');\nexports.refCount = refCount_1.refCount;\nvar sample_1 = require('./operators/sample');\nexports.sample = sample_1.sample;\nvar sampleTime_1 = require('./operators/sampleTime');\nexports.sampleTime = sampleTime_1.sampleTime;\nvar scan_1 = require('./operators/scan');\nexports.scan = scan_1.scan;\nvar sequenceEqual_1 = require('./operators/sequenceEqual');\nexports.sequenceEqual = sequenceEqual_1.sequenceEqual;\nvar share_1 = require('./operators/share');\nexports.share = share_1.share;\nvar shareReplay_1 = require('./operators/shareReplay');\nexports.shareReplay = shareReplay_1.shareReplay;\nvar single_1 = require('./operators/single');\nexports.single = single_1.single;\nvar skip_1 = require('./operators/skip');\nexports.skip = skip_1.skip;\nvar skipLast_1 = require('./operators/skipLast');\nexports.skipLast = skipLast_1.skipLast;\nvar skipUntil_1 = require('./operators/skipUntil');\nexports.skipUntil = skipUntil_1.skipUntil;\nvar skipWhile_1 = require('./operators/skipWhile');\nexports.skipWhile = skipWhile_1.skipWhile;\nvar startWith_1 = require('./operators/startWith');\nexports.startWith = startWith_1.startWith;\n/**\n * TODO(https://github.com/ReactiveX/rxjs/issues/2900): Add back subscribeOn once it can be\n * treeshaken. Currently if this export is added back, it\n * forces apps to bring in asap scheduler along with\n * Immediate, root, and other supporting code.\n */\n// export { subscribeOn } from './operators/subscribeOn';\nvar switchAll_1 = require('./operators/switchAll');\nexports.switchAll = switchAll_1.switchAll;\nvar switchMap_1 = require('./operators/switchMap');\nexports.switchMap = switchMap_1.switchMap;\nvar switchMapTo_1 = require('./operators/switchMapTo');\nexports.switchMapTo = switchMapTo_1.switchMapTo;\nvar take_1 = require('./operators/take');\nexports.take = take_1.take;\nvar takeLast_1 = require('./operators/takeLast');\nexports.takeLast = takeLast_1.takeLast;\nvar takeUntil_1 = require('./operators/takeUntil');\nexports.takeUntil = takeUntil_1.takeUntil;\nvar takeWhile_1 = require('./operators/takeWhile');\nexports.takeWhile = takeWhile_1.takeWhile;\nvar tap_1 = require('./operators/tap');\nexports.tap = tap_1.tap;\nvar throttle_1 = require('./operators/throttle');\nexports.throttle = throttle_1.throttle;\nvar throttleTime_1 = require('./operators/throttleTime');\nexports.throttleTime = throttleTime_1.throttleTime;\nvar timeInterval_1 = require('./operators/timeInterval');\nexports.timeInterval = timeInterval_1.timeInterval;\nvar timeout_1 = require('./operators/timeout');\nexports.timeout = timeout_1.timeout;\nvar timeoutWith_1 = require('./operators/timeoutWith');\nexports.timeoutWith = timeoutWith_1.timeoutWith;\nvar timestamp_1 = require('./operators/timestamp');\nexports.timestamp = timestamp_1.timestamp;\nvar toArray_1 = require('./operators/toArray');\nexports.toArray = toArray_1.toArray;\nvar window_1 = require('./operators/window');\nexports.window = window_1.window;\nvar windowCount_1 = require('./operators/windowCount');\nexports.windowCount = windowCount_1.windowCount;\nvar windowTime_1 = require('./operators/windowTime');\nexports.windowTime = windowTime_1.windowTime;\nvar windowToggle_1 = require('./operators/windowToggle');\nexports.windowToggle = windowToggle_1.windowToggle;\nvar windowWhen_1 = require('./operators/windowWhen');\nexports.windowWhen = windowWhen_1.windowWhen;\nvar withLatestFrom_1 = require('./operators/withLatestFrom');\nexports.withLatestFrom = withLatestFrom_1.withLatestFrom;\nvar zip_1 = require('./operators/zip');\nexports.zip = zip_1.zip;\nvar zipAll_1 = require('./operators/zipAll');\nexports.zipAll = zipAll_1.zipAll;\n//# sourceMappingURL=operators.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators.js\n// module id = 725\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * <img src=\"./img/buffer.png\" width=\"100%\">\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * Observable emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * @example <caption>On every click, emit array of most recent interval events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var buffered = interval.buffer(clicks);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param {Observable<any>} closingNotifier An Observable that signals the\n * buffer to be emitted on the output Observable.\n * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n * values.\n * @method buffer\n * @owner Observable\n */\nfunction buffer(closingNotifier) {\n    return function bufferOperatorFunction(source) {\n        return source.lift(new BufferOperator(closingNotifier));\n    };\n}\nexports.buffer = buffer;\nvar BufferOperator = (function () {\n    function BufferOperator(closingNotifier) {\n        this.closingNotifier = closingNotifier;\n    }\n    BufferOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n    };\n    return BufferOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSubscriber = (function (_super) {\n    __extends(BufferSubscriber, _super);\n    function BufferSubscriber(destination, closingNotifier) {\n        _super.call(this, destination);\n        this.buffer = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n    }\n    BufferSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var buffer = this.buffer;\n        this.buffer = [];\n        this.destination.next(buffer);\n    };\n    return BufferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=buffer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/buffer.js\n// module id = 726\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * <img src=\"./img/bufferCount.png\" width=\"100%\">\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * @example <caption>Emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>On every click, emit the last two click events as an array</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferCount(2, 1);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param {number} bufferSize The maximum size of the buffer emitted.\n * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return {Observable<T[]>} An Observable of arrays of buffered values.\n * @method bufferCount\n * @owner Observable\n */\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) { startBufferEvery = null; }\n    return function bufferCountOperatorFunction(source) {\n        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n    };\n}\nexports.bufferCount = bufferCount;\nvar BufferCountOperator = (function () {\n    function BufferCountOperator(bufferSize, startBufferEvery) {\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        if (!startBufferEvery || bufferSize === startBufferEvery) {\n            this.subscriberClass = BufferCountSubscriber;\n        }\n        else {\n            this.subscriberClass = BufferSkipCountSubscriber;\n        }\n    }\n    BufferCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n    };\n    return BufferCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferCountSubscriber = (function (_super) {\n    __extends(BufferCountSubscriber, _super);\n    function BufferCountSubscriber(destination, bufferSize) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.buffer = [];\n    }\n    BufferCountSubscriber.prototype._next = function (value) {\n        var buffer = this.buffer;\n        buffer.push(value);\n        if (buffer.length == this.bufferSize) {\n            this.destination.next(buffer);\n            this.buffer = [];\n        }\n    };\n    BufferCountSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer.length > 0) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferCountSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferSkipCountSubscriber = (function (_super) {\n    __extends(BufferSkipCountSubscriber, _super);\n    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n        _super.call(this, destination);\n        this.bufferSize = bufferSize;\n        this.startBufferEvery = startBufferEvery;\n        this.buffers = [];\n        this.count = 0;\n    }\n    BufferSkipCountSubscriber.prototype._next = function (value) {\n        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n        this.count++;\n        if (count % startBufferEvery === 0) {\n            buffers.push([]);\n        }\n        for (var i = buffers.length; i--;) {\n            var buffer = buffers[i];\n            buffer.push(value);\n            if (buffer.length === bufferSize) {\n                buffers.splice(i, 1);\n                this.destination.next(buffer);\n            }\n        }\n    };\n    BufferSkipCountSubscriber.prototype._complete = function () {\n        var _a = this, buffers = _a.buffers, destination = _a.destination;\n        while (buffers.length > 0) {\n            var buffer = buffers.shift();\n            if (buffer.length > 0) {\n                destination.next(buffer);\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    return BufferSkipCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=bufferCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferCount.js\n// module id = 727\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nfunction bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async_1.async;\n    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nexports.bufferTime = bufferTime;\nvar BufferTimeOperator = (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferTimeSubscriber = (function (_super) {\n    __extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        _super.call(this, destination);\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n        this.contexts = [];\n        var context = this.openContext();\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context = contexts[i];\n            var buffer = context.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            destination.next(context.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferTime.js\n// module id = 728\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nfunction bufferToggle(openings, closingSelector) {\n    return function bufferToggleOperatorFunction(source) {\n        return source.lift(new BufferToggleOperator(openings, closingSelector));\n    };\n}\nexports.bufferToggle = bufferToggle;\nvar BufferToggleOperator = (function () {\n    function BufferToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    BufferToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return BufferToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferToggleSubscriber = (function (_super) {\n    __extends(BufferToggleSubscriber, _super);\n    function BufferToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult_1.subscribeToResult(this, openings));\n    }\n    BufferToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        for (var i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    };\n    BufferToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._error.call(this, err);\n    };\n    BufferToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        while (contexts.length > 0) {\n            var context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        _super.prototype._complete.call(this);\n    };\n    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    };\n    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.closeBuffer(innerSub.context);\n    };\n    BufferToggleSubscriber.prototype.openBuffer = function (value) {\n        try {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    };\n    BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n        var contexts = this.contexts;\n        if (contexts && context) {\n            var buffer = context.buffer, subscription = context.subscription;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    };\n    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n        var contexts = this.contexts;\n        var buffer = [];\n        var subscription = new Subscription_1.Subscription();\n        var context = { buffer: buffer, subscription: subscription };\n        contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    };\n    return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferToggle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferToggle.js\n// module id = 729\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nfunction bufferWhen(closingSelector) {\n    return function (source) {\n        return source.lift(new BufferWhenOperator(closingSelector));\n    };\n}\nexports.bufferWhen = bufferWhen;\nvar BufferWhenOperator = (function () {\n    function BufferWhenOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    BufferWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    };\n    return BufferWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar BufferWhenSubscriber = (function (_super) {\n    __extends(BufferWhenSubscriber, _super);\n    function BufferWhenSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    BufferWhenSubscriber.prototype._next = function (value) {\n        this.buffer.push(value);\n    };\n    BufferWhenSubscriber.prototype._complete = function () {\n        var buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferWhenSubscriber.prototype._unsubscribe = function () {\n        this.buffer = null;\n        this.subscribing = false;\n    };\n    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    };\n    BufferWhenSubscriber.prototype.notifyComplete = function () {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    };\n    BufferWhenSubscriber.prototype.openBuffer = function () {\n        var closingSubscription = this.closingSubscription;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        var buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            this.error(errorObject_1.errorObject.e);\n        }\n        else {\n            closingSubscription = new Subscription_1.Subscription();\n            this.closingSubscription = closingSubscription;\n            this.add(closingSubscription);\n            this.subscribing = true;\n            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            this.subscribing = false;\n        }\n    };\n    return BufferWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=bufferWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/bufferWhen.js\n// module id = 730\n// module chunks = 1","\"use strict\";\nvar combineLatest_1 = require('../operators/combineLatest');\nfunction combineAll(project) {\n    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };\n}\nexports.combineAll = combineAll;\n//# sourceMappingURL=combineAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/combineAll.js\n// module id = 731\n// module chunks = 1","\"use strict\";\nvar concat_1 = require('../observable/concat');\nvar concat_2 = require('../observable/concat');\nexports.concatStatic = concat_2.concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n}\nexports.concat = concat;\n//# sourceMappingURL=concat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/concat.js\n// module id = 732\n// module chunks = 1","\"use strict\";\nvar concatMap_1 = require('./concatMap');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An observable of values merged together by joining the\n * passed observable with itself, one after the other, for each value emitted\n * from the source.\n * @method concatMapTo\n * @owner Observable\n */\nfunction concatMapTo(innerObservable, resultSelector) {\n    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);\n}\nexports.concatMapTo = concatMapTo;\n//# sourceMappingURL=concatMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/concatMapTo.js\n// module id = 733\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * <img src=\"./img/count.png\" width=\"100%\">\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var secondsBeforeClick = seconds.takeUntil(clicks);\n * var result = secondsBeforeClick.count();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n * var numbers = Rx.Observable.range(1, 7);\n * var result = numbers.count(i => i % 2 === 1);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 4\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n * boolean function to select what values are to be counted. It is provided with\n * arguments of:\n * - `value`: the value from the source Observable.\n * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n * - `source`: the source Observable instance itself.\n * @return {Observable} An Observable of one number that represents the count as\n * described above.\n * @method count\n * @owner Observable\n */\nfunction count(predicate) {\n    return function (source) { return source.lift(new CountOperator(predicate, source)); };\n}\nexports.count = count;\nvar CountOperator = (function () {\n    function CountOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    CountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n    };\n    return CountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CountSubscriber = (function (_super) {\n    __extends(CountSubscriber, _super);\n    function CountSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.count = 0;\n        this.index = 0;\n    }\n    CountSubscriber.prototype._next = function (value) {\n        if (this.predicate) {\n            this._tryPredicate(value);\n        }\n        else {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._tryPredicate = function (value) {\n        var result;\n        try {\n            result = this.predicate(value, this.index++, this.source);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.count++;\n        }\n    };\n    CountSubscriber.prototype._complete = function () {\n        this.destination.next(this.count);\n        this.destination.complete();\n    };\n    return CountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=count.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/count.js\n// module id = 734\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits a value from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * <img src=\"./img/debounce.png\" width=\"100%\">\n *\n * `debounce` delays values emitted by the source Observable, but drops previous\n * pending delayed emissions if a new value arrives on the source Observable.\n * This operator keeps track of the most recent value from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The value is emitted only when the duration\n * Observable emits a value or completes, and if no other value was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * value appears before the duration Observable emits, the previous value will\n * be dropped and will not be emitted on the output Observable.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n * @see {@link throttle}\n *\n * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n * @method debounce\n * @owner Observable\n */\nfunction debounce(durationSelector) {\n    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };\n}\nexports.debounce = debounce;\nvar DebounceOperator = (function () {\n    function DebounceOperator(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    DebounceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n    };\n    return DebounceOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DebounceSubscriber = (function (_super) {\n    __extends(DebounceSubscriber, _super);\n    function DebounceSubscriber(destination, durationSelector) {\n        _super.call(this, destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n        this.durationSubscription = null;\n    }\n    DebounceSubscriber.prototype._next = function (value) {\n        try {\n            var result = this.durationSelector.call(this, value);\n            if (result) {\n                this._tryNext(value, result);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DebounceSubscriber.prototype._complete = function () {\n        this.emitValue();\n        this.destination.complete();\n    };\n    DebounceSubscriber.prototype._tryNext = function (value, duration) {\n        var subscription = this.durationSubscription;\n        this.value = value;\n        this.hasValue = true;\n        if (subscription) {\n            subscription.unsubscribe();\n            this.remove(subscription);\n        }\n        subscription = subscribeToResult_1.subscribeToResult(this, duration);\n        if (!subscription.closed) {\n            this.add(this.durationSubscription = subscription);\n        }\n    };\n    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    DebounceSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            var value = this.value;\n            var subscription = this.durationSubscription;\n            if (subscription) {\n                this.durationSubscription = null;\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            this.value = null;\n            this.hasValue = false;\n            _super.prototype._next.call(this, value);\n        }\n    };\n    return DebounceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=debounce.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/debounce.js\n// module id = 735\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * <img src=\"./img/delay.png\" width=\"100%\">\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * @example <caption>Delay each click by one second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @example <caption>Delay all clicks until a future date happens</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var date = new Date('March 15, 2050 12:00:00'); // in the future\n * var delayedClicks = clicks.delay(date); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounceTime}\n * @see {@link delayWhen}\n *\n * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n * a `Date` until which the emission of the source items is delayed.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for\n * managing the timers that handle the time-shift for each item.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified timeout or Date.\n * @method delay\n * @owner Observable\n */\nfunction delay(delay, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteDelay = isDate_1.isDate(delay);\n    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n}\nexports.delay = delay;\nvar DelayOperator = (function () {\n    function DelayOperator(delay, scheduler) {\n        this.delay = delay;\n        this.scheduler = scheduler;\n    }\n    DelayOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n    };\n    return DelayOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelaySubscriber = (function (_super) {\n    __extends(DelaySubscriber, _super);\n    function DelaySubscriber(destination, delay, scheduler) {\n        _super.call(this, destination);\n        this.delay = delay;\n        this.scheduler = scheduler;\n        this.queue = [];\n        this.active = false;\n        this.errored = false;\n    }\n    DelaySubscriber.dispatch = function (state) {\n        var source = state.source;\n        var queue = source.queue;\n        var scheduler = state.scheduler;\n        var destination = state.destination;\n        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n            queue.shift().notification.observe(destination);\n        }\n        if (queue.length > 0) {\n            var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n            this.schedule(state, delay_1);\n        }\n        else {\n            source.active = false;\n        }\n    };\n    DelaySubscriber.prototype._schedule = function (scheduler) {\n        this.active = true;\n        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n            source: this, destination: this.destination, scheduler: scheduler\n        }));\n    };\n    DelaySubscriber.prototype.scheduleNotification = function (notification) {\n        if (this.errored === true) {\n            return;\n        }\n        var scheduler = this.scheduler;\n        var message = new DelayMessage(scheduler.now() + this.delay, notification);\n        this.queue.push(message);\n        if (this.active === false) {\n            this._schedule(scheduler);\n        }\n    };\n    DelaySubscriber.prototype._next = function (value) {\n        this.scheduleNotification(Notification_1.Notification.createNext(value));\n    };\n    DelaySubscriber.prototype._error = function (err) {\n        this.errored = true;\n        this.queue = [];\n        this.destination.error(err);\n    };\n    DelaySubscriber.prototype._complete = function () {\n        this.scheduleNotification(Notification_1.Notification.createComplete());\n    };\n    return DelaySubscriber;\n}(Subscriber_1.Subscriber));\nvar DelayMessage = (function () {\n    function DelayMessage(time, notification) {\n        this.time = time;\n        this.notification = notification;\n    }\n    return DelayMessage;\n}());\n//# sourceMappingURL=delay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/delay.js\n// module id = 736\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Observable_1 = require('../Observable');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * <img src=\"./img/delayWhen.png\" width=\"100%\">\n *\n * `delayWhen` time shifts each emitted value from the source Observable by a\n * time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the source value as\n * argument, and should return an Observable, called the \"duration\" Observable.\n * The source value is emitted on the output Observable only when the duration\n * Observable emits a value or completes.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var delayedClicks = clicks.delayWhen(event =>\n *   Rx.Observable.interval(Math.random() * 5000)\n * );\n * delayedClicks.subscribe(x => console.log(x));\n *\n * @see {@link debounce}\n * @see {@link delay}\n *\n * @param {function(value: T): Observable} delayDurationSelector A function that\n * returns an Observable for each value emitted by the source Observable, which\n * is then used to delay the emission of that item on the output Observable\n * until the Observable returned from this function emits a value.\n * @param {Observable} subscriptionDelay An Observable that triggers the\n * subscription to the source Observable once it emits any value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by an amount of time specified by the Observable returned by\n * `delayDurationSelector`.\n * @method delayWhen\n * @owner Observable\n */\nfunction delayWhen(delayDurationSelector, subscriptionDelay) {\n    if (subscriptionDelay) {\n        return function (source) {\n            return new SubscriptionDelayObservable(source, subscriptionDelay)\n                .lift(new DelayWhenOperator(delayDurationSelector));\n        };\n    }\n    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };\n}\nexports.delayWhen = delayWhen;\nvar DelayWhenOperator = (function () {\n    function DelayWhenOperator(delayDurationSelector) {\n        this.delayDurationSelector = delayDurationSelector;\n    }\n    DelayWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n    };\n    return DelayWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DelayWhenSubscriber = (function (_super) {\n    __extends(DelayWhenSubscriber, _super);\n    function DelayWhenSubscriber(destination, delayDurationSelector) {\n        _super.call(this, destination);\n        this.delayDurationSelector = delayDurationSelector;\n        this.completed = false;\n        this.delayNotifierSubscriptions = [];\n        this.values = [];\n    }\n    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(outerValue);\n        this.removeSubscription(innerSub);\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        var value = this.removeSubscription(innerSub);\n        if (value) {\n            this.destination.next(value);\n        }\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype._next = function (value) {\n        try {\n            var delayNotifier = this.delayDurationSelector(value);\n            if (delayNotifier) {\n                this.tryDelay(delayNotifier, value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    DelayWhenSubscriber.prototype._complete = function () {\n        this.completed = true;\n        this.tryComplete();\n    };\n    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n        subscription.unsubscribe();\n        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n        var value = null;\n        if (subscriptionIdx !== -1) {\n            value = this.values[subscriptionIdx];\n            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n            this.values.splice(subscriptionIdx, 1);\n        }\n        return value;\n    };\n    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n        if (notifierSubscription && !notifierSubscription.closed) {\n            this.add(notifierSubscription);\n            this.delayNotifierSubscriptions.push(notifierSubscription);\n        }\n        this.values.push(value);\n    };\n    DelayWhenSubscriber.prototype.tryComplete = function () {\n        if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n            this.destination.complete();\n        }\n    };\n    return DelayWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelayObservable = (function (_super) {\n    __extends(SubscriptionDelayObservable, _super);\n    function SubscriptionDelayObservable(source, subscriptionDelay) {\n        _super.call(this);\n        this.source = source;\n        this.subscriptionDelay = subscriptionDelay;\n    }\n    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n    };\n    return SubscriptionDelayObservable;\n}(Observable_1.Observable));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubscriptionDelaySubscriber = (function (_super) {\n    __extends(SubscriptionDelaySubscriber, _super);\n    function SubscriptionDelaySubscriber(parent, source) {\n        _super.call(this);\n        this.parent = parent;\n        this.source = source;\n        this.sourceSubscribed = false;\n    }\n    SubscriptionDelaySubscriber.prototype._next = function (unused) {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype._error = function (err) {\n        this.unsubscribe();\n        this.parent.error(err);\n    };\n    SubscriptionDelaySubscriber.prototype._complete = function () {\n        this.subscribeToSource();\n    };\n    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n        if (!this.sourceSubscribed) {\n            this.sourceSubscribed = true;\n            this.unsubscribe();\n            this.source.subscribe(this.parent);\n        }\n    };\n    return SubscriptionDelaySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=delayWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/delayWhen.js\n// module id = 737\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Converts an Observable of {@link Notification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * <img src=\"./img/dematerialize.png\" width=\"100%\">\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link Notification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n * var notifA = new Rx.Notification('N', 'A');\n * var notifB = new Rx.Notification('N', 'B');\n * var notifE = new Rx.Notification('E', void 0,\n *   new TypeError('x.toUpperCase is not a function')\n * );\n * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n * var upperCase = materialized.dematerialize();\n * upperCase.subscribe(x => console.log(x), e => console.error(e));\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n *\n * @see {@link Notification}\n * @see {@link materialize}\n *\n * @return {Observable} An Observable that emits items and notifications\n * embedded in Notification objects emitted by the source Observable.\n * @method dematerialize\n * @owner Observable\n */\nfunction dematerialize() {\n    return function dematerializeOperatorFunction(source) {\n        return source.lift(new DeMaterializeOperator());\n    };\n}\nexports.dematerialize = dematerialize;\nvar DeMaterializeOperator = (function () {\n    function DeMaterializeOperator() {\n    }\n    DeMaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DeMaterializeSubscriber(subscriber));\n    };\n    return DeMaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DeMaterializeSubscriber = (function (_super) {\n    __extends(DeMaterializeSubscriber, _super);\n    function DeMaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    DeMaterializeSubscriber.prototype._next = function (value) {\n        value.observe(this.destination);\n    };\n    return DeMaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=dematerialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/dematerialize.js\n// module id = 738\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar Set_1 = require('../util/Set');\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * @example <caption>A simple example with numbers</caption>\n * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .distinct()\n *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n *\n * @example <caption>An example using a keySelector function</caption>\n * interface Person {\n *    age: number,\n *    name: string\n * }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'})\n *     .distinct((p: Person) => p.name)\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n *\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n * @method distinct\n * @owner Observable\n */\nfunction distinct(keySelector, flushes) {\n    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };\n}\nexports.distinct = distinct;\nvar DistinctOperator = (function () {\n    function DistinctOperator(keySelector, flushes) {\n        this.keySelector = keySelector;\n        this.flushes = flushes;\n    }\n    DistinctOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n    };\n    return DistinctOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DistinctSubscriber = (function (_super) {\n    __extends(DistinctSubscriber, _super);\n    function DistinctSubscriber(destination, keySelector, flushes) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.values = new Set_1.Set();\n        if (flushes) {\n            this.add(subscribeToResult_1.subscribeToResult(this, flushes));\n        }\n    }\n    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values.clear();\n    };\n    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    DistinctSubscriber.prototype._next = function (value) {\n        if (this.keySelector) {\n            this._useKeySelector(value);\n        }\n        else {\n            this._finalizeNext(value, value);\n        }\n    };\n    DistinctSubscriber.prototype._useKeySelector = function (value) {\n        var key;\n        var destination = this.destination;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this._finalizeNext(key, value);\n    };\n    DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n        var values = this.values;\n        if (!values.has(key)) {\n            values.add(key);\n            this.destination.next(value);\n        }\n    };\n    return DistinctSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.DistinctSubscriber = DistinctSubscriber;\n//# sourceMappingURL=distinct.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/distinct.js\n// module id = 739\n// module chunks = 1","\"use strict\";\nvar root_1 = require('./root');\nfunction minimalSetImpl() {\n    // THIS IS NOT a full impl of Set, this is just the minimum\n    // bits of functionality we need for this library.\n    return (function () {\n        function MinimalSet() {\n            this._values = [];\n        }\n        MinimalSet.prototype.add = function (value) {\n            if (!this.has(value)) {\n                this._values.push(value);\n            }\n        };\n        MinimalSet.prototype.has = function (value) {\n            return this._values.indexOf(value) !== -1;\n        };\n        Object.defineProperty(MinimalSet.prototype, \"size\", {\n            get: function () {\n                return this._values.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MinimalSet.prototype.clear = function () {\n            this._values.length = 0;\n        };\n        return MinimalSet;\n    }());\n}\nexports.minimalSetImpl = minimalSetImpl;\nexports.Set = root_1.root.Set || minimalSetImpl();\n//# sourceMappingURL=Set.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/Set.js\n// module id = 740\n// module chunks = 1","\"use strict\";\nvar distinctUntilChanged_1 = require('./distinctUntilChanged');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n * using a property accessed by using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * @example <caption>An example comparing the name of persons</caption>\n *\n *  interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo'},\n *     { age: 6, name: 'Foo'})\n *     .distinctUntilKeyChanged('name')\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n *\n * @example <caption>An example comparing the first letters of the name</caption>\n *\n * interface Person {\n *     age: number,\n *     name: string\n *  }\n *\n * Observable.of<Person>(\n *     { age: 4, name: 'Foo1'},\n *     { age: 7, name: 'Bar'},\n *     { age: 5, name: 'Foo2'},\n *     { age: 6, name: 'Foo3'})\n *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n *     .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param {string} key String key for object property lookup on each item.\n * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n * @method distinctUntilKeyChanged\n * @owner Observable\n */\nfunction distinctUntilKeyChanged(key, compare) {\n    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n}\nexports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n//# sourceMappingURL=distinctUntilKeyChanged.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/distinctUntilKeyChanged.js\n// module id = 741\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * <img src=\"./img/elementAt.png\" width=\"100%\">\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * @example <caption>Emit only the third click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.elementAt(2);\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param {number} index Is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {T} [defaultValue] The default value returned for missing indices.\n * @return {Observable} An Observable that emits a single item, if it is found.\n * Otherwise, will emit the default value if given. If not, then emits an error.\n * @method elementAt\n * @owner Observable\n */\nfunction elementAt(index, defaultValue) {\n    return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };\n}\nexports.elementAt = elementAt;\nvar ElementAtOperator = (function () {\n    function ElementAtOperator(index, defaultValue) {\n        this.index = index;\n        this.defaultValue = defaultValue;\n        if (index < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    ElementAtOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n    };\n    return ElementAtOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ElementAtSubscriber = (function (_super) {\n    __extends(ElementAtSubscriber, _super);\n    function ElementAtSubscriber(destination, index, defaultValue) {\n        _super.call(this, destination);\n        this.index = index;\n        this.defaultValue = defaultValue;\n    }\n    ElementAtSubscriber.prototype._next = function (x) {\n        if (this.index-- === 0) {\n            this.destination.next(x);\n            this.destination.complete();\n        }\n    };\n    ElementAtSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index >= 0) {\n            if (typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n            }\n            else {\n                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n            }\n        }\n        destination.complete();\n    };\n    return ElementAtSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=elementAt.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/elementAt.js\n// module id = 742\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * <img src=\"./img/exhaust.png\" width=\"100%\">\n *\n * `exhaust` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaust` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n * var result = higherOrder.exhaust();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link switch}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n * exclusively until it completes before subscribing to the next.\n * @method exhaust\n * @owner Observable\n */\nfunction exhaust() {\n    return function (source) { return source.lift(new SwitchFirstOperator()); };\n}\nexports.exhaust = exhaust;\nvar SwitchFirstOperator = (function () {\n    function SwitchFirstOperator() {\n    }\n    SwitchFirstOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstSubscriber(subscriber));\n    };\n    return SwitchFirstOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstSubscriber = (function (_super) {\n    __extends(SwitchFirstSubscriber, _super);\n    function SwitchFirstSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasCompleted = false;\n        this.hasSubscription = false;\n    }\n    SwitchFirstSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, value));\n        }\n    };\n    SwitchFirstSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaust.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/exhaust.js\n// module id = 743\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nfunction exhaustMap(project, resultSelector) {\n    return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n}\nexports.exhaustMap = exhaustMap;\nvar SwitchFirstMapOperator = (function () {\n    function SwitchFirstMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchFirstMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchFirstMapSubscriber = (function (_super) {\n    __extends(SwitchFirstMapSubscriber, _super);\n    function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.hasSubscription = false;\n        this.hasCompleted = false;\n        this.index = 0;\n    }\n    SwitchFirstMapSubscriber.prototype._next = function (value) {\n        if (!this.hasSubscription) {\n            this.tryNext(value);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n        var index = this.index++;\n        var destination = this.destination;\n        try {\n            var result = this.project(value, index);\n            this.hasSubscription = true;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (!this.hasSubscription) {\n            this.destination.complete();\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        try {\n            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            destination.next(result);\n        }\n        catch (err) {\n            destination.error(err);\n        }\n    };\n    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.hasSubscription = false;\n        if (this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=exhaustMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/exhaustMap.js\n// module id = 744\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nfunction expand(project, concurrent, scheduler) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (scheduler === void 0) { scheduler = undefined; }\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };\n}\nexports.expand = expand;\nvar ExpandOperator = (function () {\n    function ExpandOperator(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    ExpandOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    };\n    return ExpandOperator;\n}());\nexports.ExpandOperator = ExpandOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ExpandSubscriber = (function (_super) {\n    __extends(ExpandSubscriber, _super);\n    function ExpandSubscriber(destination, project, concurrent, scheduler) {\n        _super.call(this, destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    ExpandSubscriber.dispatch = function (arg) {\n        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n        subscriber.subscribeToProjection(result, value, index);\n    };\n    ExpandSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        var index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            var result = tryCatch_1.tryCatch(this.project)(value, index);\n            if (result === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                var state = { subscriber: this, result: result, value: value, index: index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n        this.active++;\n        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    ExpandSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    };\n    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    return ExpandSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.ExpandSubscriber = ExpandSubscriber;\n//# sourceMappingURL=expand.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/expand.js\n// module id = 745\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * @param {function} callback Function to be called when source terminates.\n * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n * @method finally\n * @owner Observable\n */\nfunction finalize(callback) {\n    return function (source) { return source.lift(new FinallyOperator(callback)); };\n}\nexports.finalize = finalize;\nvar FinallyOperator = (function () {\n    function FinallyOperator(callback) {\n        this.callback = callback;\n    }\n    FinallyOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n    };\n    return FinallyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FinallySubscriber = (function (_super) {\n    __extends(FinallySubscriber, _super);\n    function FinallySubscriber(destination, callback) {\n        _super.call(this, destination);\n        this.add(new Subscription_1.Subscription(callback));\n    }\n    return FinallySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=finalize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/finalize.js\n// module id = 746\n// module chunks = 1","\"use strict\";\nvar find_1 = require('../operators/find');\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * <img src=\"./img/findIndex.png\" width=\"100%\">\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n * A function called with each item to test for condition matching.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of the index of the first item that\n * matches the condition.\n * @method find\n * @owner Observable\n */\nfunction findIndex(predicate, thisArg) {\n    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };\n}\nexports.findIndex = findIndex;\n//# sourceMappingURL=findIndex.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/findIndex.js\n// module id = 747\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\nvar Observable_1 = require('../Observable');\nvar Subject_1 = require('../Subject');\nvar Map_1 = require('../util/Map');\nvar FastMap_1 = require('../util/FastMap');\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nfunction groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return function (source) {\n        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n    };\n}\nexports.groupBy = groupBy;\nvar GroupByOperator = (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        _super.call(this, destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        _super.call(this, group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber_1.Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = (function (_super) {\n    __extends(GroupedObservable, _super);\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        _super.call(this);\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription_1.Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable_1.Observable));\nexports.GroupedObservable = GroupedObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        _super.call(this);\n        this.parent = parent;\n        parent.count++;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription_1.Subscription));\n//# sourceMappingURL=groupBy.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/groupBy.js\n// module id = 748\n// module chunks = 1","\"use strict\";\nvar root_1 = require('./root');\nvar MapPolyfill_1 = require('./MapPolyfill');\nexports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n//# sourceMappingURL=Map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/Map.js\n// module id = 749\n// module chunks = 1","\"use strict\";\nvar MapPolyfill = (function () {\n    function MapPolyfill() {\n        this.size = 0;\n        this._values = [];\n        this._keys = [];\n    }\n    MapPolyfill.prototype.get = function (key) {\n        var i = this._keys.indexOf(key);\n        return i === -1 ? undefined : this._values[i];\n    };\n    MapPolyfill.prototype.set = function (key, value) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            this._keys.push(key);\n            this._values.push(value);\n            this.size++;\n        }\n        else {\n            this._values[i] = value;\n        }\n        return this;\n    };\n    MapPolyfill.prototype.delete = function (key) {\n        var i = this._keys.indexOf(key);\n        if (i === -1) {\n            return false;\n        }\n        this._values.splice(i, 1);\n        this._keys.splice(i, 1);\n        this.size--;\n        return true;\n    };\n    MapPolyfill.prototype.clear = function () {\n        this._keys.length = 0;\n        this._values.length = 0;\n        this.size = 0;\n    };\n    MapPolyfill.prototype.forEach = function (cb, thisArg) {\n        for (var i = 0; i < this.size; i++) {\n            cb.call(thisArg, this._values[i], this._keys[i]);\n        }\n    };\n    return MapPolyfill;\n}());\nexports.MapPolyfill = MapPolyfill;\n//# sourceMappingURL=MapPolyfill.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/MapPolyfill.js\n// module id = 750\n// module chunks = 1","\"use strict\";\nvar FastMap = (function () {\n    function FastMap() {\n        this.values = {};\n    }\n    FastMap.prototype.delete = function (key) {\n        this.values[key] = null;\n        return true;\n    };\n    FastMap.prototype.set = function (key, value) {\n        this.values[key] = value;\n        return this;\n    };\n    FastMap.prototype.get = function (key) {\n        return this.values[key];\n    };\n    FastMap.prototype.forEach = function (cb, thisArg) {\n        var values = this.values;\n        for (var key in values) {\n            if (values.hasOwnProperty(key) && values[key] !== null) {\n                cb.call(thisArg, values[key], key);\n            }\n        }\n    };\n    FastMap.prototype.clear = function () {\n        this.values = {};\n    };\n    return FastMap;\n}());\nexports.FastMap = FastMap;\n//# sourceMappingURL=FastMap.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/FastMap.js\n// module id = 751\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar noop_1 = require('../util/noop');\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n *\n * @return {Observable} An empty Observable that only calls `complete`\n * or `error`, based on which one is called by the source Observable.\n * @method ignoreElements\n * @owner Observable\n */\nfunction ignoreElements() {\n    return function ignoreElementsOperatorFunction(source) {\n        return source.lift(new IgnoreElementsOperator());\n    };\n}\nexports.ignoreElements = ignoreElements;\nvar IgnoreElementsOperator = (function () {\n    function IgnoreElementsOperator() {\n    }\n    IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n    };\n    return IgnoreElementsOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IgnoreElementsSubscriber = (function (_super) {\n    __extends(IgnoreElementsSubscriber, _super);\n    function IgnoreElementsSubscriber() {\n        _super.apply(this, arguments);\n    }\n    IgnoreElementsSubscriber.prototype._next = function (unused) {\n        noop_1.noop();\n    };\n    return IgnoreElementsSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ignoreElements.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/ignoreElements.js\n// module id = 752\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nfunction isEmpty() {\n    return function (source) { return source.lift(new IsEmptyOperator()); };\n}\nexports.isEmpty = isEmpty;\nvar IsEmptyOperator = (function () {\n    function IsEmptyOperator() {\n    }\n    IsEmptyOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new IsEmptySubscriber(observer));\n    };\n    return IsEmptyOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar IsEmptySubscriber = (function (_super) {\n    __extends(IsEmptySubscriber, _super);\n    function IsEmptySubscriber(destination) {\n        _super.call(this, destination);\n    }\n    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n        var destination = this.destination;\n        destination.next(isEmpty);\n        destination.complete();\n    };\n    IsEmptySubscriber.prototype._next = function (value) {\n        this.notifyComplete(false);\n    };\n    IsEmptySubscriber.prototype._complete = function () {\n        this.notifyComplete(true);\n    };\n    return IsEmptySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=isEmpty.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/isEmpty.js\n// module id = 753\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * <img src=\"./img/mapTo.png\" width=\"100%\">\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * @example <caption>Map every click to the string 'Hi'</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var greetings = clicks.mapTo('Hi');\n * greetings.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {any} value The value to map each source value to.\n * @return {Observable} An Observable that emits the given `value` every time\n * the source Observable emits something.\n * @method mapTo\n * @owner Observable\n */\nfunction mapTo(value) {\n    return function (source) { return source.lift(new MapToOperator(value)); };\n}\nexports.mapTo = mapTo;\nvar MapToOperator = (function () {\n    function MapToOperator(value) {\n        this.value = value;\n    }\n    MapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapToSubscriber(subscriber, this.value));\n    };\n    return MapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapToSubscriber = (function (_super) {\n    __extends(MapToSubscriber, _super);\n    function MapToSubscriber(destination, value) {\n        _super.call(this, destination);\n        this.value = value;\n    }\n    MapToSubscriber.prototype._next = function (x) {\n        this.destination.next(this.value);\n    };\n    return MapToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=mapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/mapTo.js\n// module id = 754\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Notification_1 = require('../Notification');\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * <img src=\"./img/materialize.png\" width=\"100%\">\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n * var upperCase = letters.map(x => x.toUpperCase());\n * var materialized = upperCase.materialize();\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n * //   [as project] (http://1…, hasValue: false}\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return {Observable<Notification<T>>} An Observable that emits\n * {@link Notification} objects that wrap the original emissions from the source\n * Observable with metadata.\n * @method materialize\n * @owner Observable\n */\nfunction materialize() {\n    return function materializeOperatorFunction(source) {\n        return source.lift(new MaterializeOperator());\n    };\n}\nexports.materialize = materialize;\nvar MaterializeOperator = (function () {\n    function MaterializeOperator() {\n    }\n    MaterializeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MaterializeSubscriber(subscriber));\n    };\n    return MaterializeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MaterializeSubscriber = (function (_super) {\n    __extends(MaterializeSubscriber, _super);\n    function MaterializeSubscriber(destination) {\n        _super.call(this, destination);\n    }\n    MaterializeSubscriber.prototype._next = function (value) {\n        this.destination.next(Notification_1.Notification.createNext(value));\n    };\n    MaterializeSubscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createError(err));\n        destination.complete();\n    };\n    MaterializeSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        destination.next(Notification_1.Notification.createComplete());\n        destination.complete();\n    };\n    return MaterializeSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=materialize.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/materialize.js\n// module id = 755\n// module chunks = 1","\"use strict\";\nvar reduce_1 = require('./reduce');\n/**\n * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the largest value.\n *\n * <img src=\"./img/max.png\" width=\"100%\">\n *\n * @example <caption>Get the maximal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .max()\n *   .subscribe(x => console.log(x)); // -> 8\n *\n * @example <caption>Use a comparer function to get the maximal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n * }\n *\n * @see {@link min}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable} An Observable that emits item with the largest value.\n * @method max\n * @owner Observable\n */\nfunction max(comparer) {\n    var max = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n        : function (x, y) { return x > y ? x : y; };\n    return reduce_1.reduce(max);\n}\nexports.max = max;\n//# sourceMappingURL=max.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/max.js\n// module id = 756\n// module chunks = 1","\"use strict\";\nvar merge_1 = require('../observable/merge');\nvar merge_2 = require('../observable/merge');\nexports.mergeStatic = merge_2.merge;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (either the source or an\n * Observable given as argument), and simply forwards (without doing any\n * transformation) all the values from all the input Observables to the output\n * Observable. The output Observable only completes once all input Observables\n * have completed. Any error delivered by an input Observable will be immediately\n * emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = clicks.merge(timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = timer1.merge(timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {ObservableInput} other An input Observable to merge with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} An Observable that emits items that are the result of\n * every input Observable.\n * @method merge\n * @owner Observable\n */\nfunction merge() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n}\nexports.merge = merge;\n//# sourceMappingURL=merge.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/merge.js\n// module id = 757\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable.\n * @method mergeMapTo\n * @owner Observable\n */\nfunction mergeMapTo(innerObservable, resultSelector, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n        resultSelector = null;\n    }\n    return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };\n}\nexports.mergeMapTo = mergeMapTo;\n// TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\nvar MergeMapToOperator = (function () {\n    function MergeMapToOperator(ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n    }\n    MergeMapToOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n    };\n    return MergeMapToOperator;\n}());\nexports.MergeMapToOperator = MergeMapToOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapToSubscriber = (function (_super) {\n    __extends(MergeMapToSubscriber, _super);\n    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        _super.call(this, destination);\n        this.ish = ish;\n        this.resultSelector = resultSelector;\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeMapToSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var resultSelector = this.resultSelector;\n            var index = this.index++;\n            var ish = this.ish;\n            var destination = this.destination;\n            this.active++;\n            this._innerSub(ish, destination, resultSelector, value, index);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeMapToSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    MergeMapToSubscriber.prototype.notifyError = function (err) {\n        this.destination.error(err);\n    };\n    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeMapToSubscriber = MergeMapToSubscriber;\n//# sourceMappingURL=mergeMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/mergeMapTo.js\n// module id = 758\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nfunction mergeScan(accumulator, seed, concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };\n}\nexports.mergeScan = mergeScan;\nvar MergeScanOperator = (function () {\n    function MergeScanOperator(accumulator, seed, concurrent) {\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.concurrent = concurrent;\n    }\n    MergeScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n    };\n    return MergeScanOperator;\n}());\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeScanSubscriber = (function (_super) {\n    __extends(MergeScanSubscriber, _super);\n    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this.acc = acc;\n        this.concurrent = concurrent;\n        this.hasValue = false;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n        this.index = 0;\n    }\n    MergeScanSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            var index = this.index++;\n            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n            var destination = this.destination;\n            if (ish === errorObject_1.errorObject) {\n                destination.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.active++;\n                this._innerSub(ish, value, index);\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n    };\n    MergeScanSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var destination = this.destination;\n        this.acc = innerValue;\n        this.hasValue = true;\n        destination.next(innerValue);\n    };\n    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            if (this.hasValue === false) {\n                this.destination.next(this.acc);\n            }\n            this.destination.complete();\n        }\n    };\n    return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeScanSubscriber = MergeScanSubscriber;\n//# sourceMappingURL=mergeScan.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/mergeScan.js\n// module id = 759\n// module chunks = 1","\"use strict\";\nvar reduce_1 = require('./reduce');\n/**\n * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n * and when source Observable completes it emits a single item: the item with the smallest value.\n *\n * <img src=\"./img/min.png\" width=\"100%\">\n *\n * @example <caption>Get the minimal value of a series of numbers</caption>\n * Rx.Observable.of(5, 4, 7, 2, 8)\n *   .min()\n *   .subscribe(x => console.log(x)); // -> 2\n *\n * @example <caption>Use a comparer function to get the minimal item</caption>\n * interface Person {\n *   age: number,\n *   name: string\n * }\n * Observable.of<Person>({age: 7, name: 'Foo'},\n *                       {age: 5, name: 'Bar'},\n *                       {age: 9, name: 'Beer'})\n *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n * }\n *\n * @see {@link max}\n *\n * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n * value of two items.\n * @return {Observable<R>} An Observable that emits item with the smallest value.\n * @method min\n * @owner Observable\n */\nfunction min(comparer) {\n    var min = (typeof comparer === 'function')\n        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n        : function (x, y) { return x < y ? x : y; };\n    return reduce_1.reduce(min);\n}\nexports.min = min;\n//# sourceMappingURL=min.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/min.js\n// module id = 760\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar FromObservable_1 = require('../observable/FromObservable');\nvar isArray_1 = require('../util/isArray');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n *\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * Rx.Observable.of(1, 2, 3, 0)\n *   .map(x => {\n *       if (x === 0) { throw Error(); }\n         return 10 / x;\n *   })\n *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n *   .subscribe(\n *     val => console.log(val),\n *     err => console.log(err),          // Will never be called.\n *     () => console.log('that\\'s it!')\n *   );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"that's it!\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} observables Observables passed either directly or as an array.\n * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n * to the next passed Observable and so on, until it completes or runs out of Observables.\n * @method onErrorResumeNext\n * @owner Observable\n */\nfunction onErrorResumeNext() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };\n}\nexports.onErrorResumeNext = onErrorResumeNext;\n/* tslint:enable:max-line-length */\nfunction onErrorResumeNextStatic() {\n    var nextSources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        nextSources[_i - 0] = arguments[_i];\n    }\n    var source = null;\n    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n        nextSources = nextSources[0];\n    }\n    source = nextSources.shift();\n    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n}\nexports.onErrorResumeNextStatic = onErrorResumeNextStatic;\nvar OnErrorResumeNextOperator = (function () {\n    function OnErrorResumeNextOperator(nextSources) {\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n    };\n    return OnErrorResumeNextOperator;\n}());\nvar OnErrorResumeNextSubscriber = (function (_super) {\n    __extends(OnErrorResumeNextSubscriber, _super);\n    function OnErrorResumeNextSubscriber(destination, nextSources) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.nextSources = nextSources;\n    }\n    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._error = function (err) {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype._complete = function () {\n        this.subscribeToNextSource();\n    };\n    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n        var next = this.nextSources.shift();\n        if (next) {\n            this.add(subscribeToResult_1.subscribeToResult(this, next));\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return OnErrorResumeNextSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=onErrorResumeNext.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/onErrorResumeNext.js\n// module id = 761\n// module chunks = 1","\"use strict\";\nvar not_1 = require('../util/not');\nvar filter_1 = require('./filter');\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * <img src=\"./img/partition.png\" width=\"100%\">\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n * var clicksOnDivs = parts[0];\n * var clicksElsewhere = parts[1];\n * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n *\n * @see {@link filter}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted on the first Observable in the returned array, if\n * `false` the value is emitted on the second Observable in the array. The\n * `index` parameter is the number `i` for the i-th source emission that has\n * happened since the subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n * with values that passed the predicate, and another with values that did not\n * pass the predicate.\n * @method partition\n * @owner Observable\n */\nfunction partition(predicate, thisArg) {\n    return function (source) { return [\n        filter_1.filter(predicate, thisArg)(source),\n        filter_1.filter(not_1.not(predicate, thisArg))(source)\n    ]; };\n}\nexports.partition = partition;\n//# sourceMappingURL=partition.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/partition.js\n// module id = 762\n// module chunks = 1","\"use strict\";\nfunction not(pred, thisArg) {\n    function notPred() {\n        return !(notPred.pred.apply(notPred.thisArg, arguments));\n    }\n    notPred.pred = pred;\n    notPred.thisArg = thisArg;\n    return notPred;\n}\nexports.not = not;\n//# sourceMappingURL=not.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/not.js\n// module id = 763\n// module chunks = 1","\"use strict\";\nvar map_1 = require('./map');\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nfunction pluck() {\n    var properties = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        properties[_i - 0] = arguments[_i];\n    }\n    var length = properties.length;\n    if (length === 0) {\n        throw new Error('list of properties cannot be empty.');\n    }\n    return function (source) { return map_1.map(plucker(properties, length))(source); };\n}\nexports.pluck = pluck;\nfunction plucker(props, length) {\n    var mapper = function (x) {\n        var currentProp = x;\n        for (var i = 0; i < length; i++) {\n            var p = currentProp[props[i]];\n            if (typeof p !== 'undefined') {\n                currentProp = p;\n            }\n            else {\n                return undefined;\n            }\n        }\n        return currentProp;\n    };\n    return mapper;\n}\n//# sourceMappingURL=pluck.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/pluck.js\n// module id = 764\n// module chunks = 1","\"use strict\";\nvar Subject_1 = require('../Subject');\nvar multicast_1 = require('./multicast');\n/* tslint:enable:max-line-length */\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <img src=\"./img/publish.png\" width=\"100%\">\n *\n * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n * @method publish\n * @owner Observable\n */\nfunction publish(selector) {\n    return selector ?\n        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :\n        multicast_1.multicast(new Subject_1.Subject());\n}\nexports.publish = publish;\n//# sourceMappingURL=publish.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/publish.js\n// module id = 765\n// module chunks = 1","\"use strict\";\nvar BehaviorSubject_1 = require('../BehaviorSubject');\nvar multicast_1 = require('./multicast');\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/publishBehavior.js\n// module id = 766\n// module chunks = 1","\"use strict\";\nvar AsyncSubject_1 = require('../AsyncSubject');\nvar multicast_1 = require('./multicast');\nfunction publishLast() {\n    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };\n}\nexports.publishLast = publishLast;\n//# sourceMappingURL=publishLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/publishLast.js\n// module id = 767\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar Subscription_1 = require('./Subscription');\n/**\n * @class AsyncSubject<T>\n */\nvar AsyncSubject = (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        _super.apply(this, arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject_1.Subject));\nexports.AsyncSubject = AsyncSubject;\n//# sourceMappingURL=AsyncSubject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/AsyncSubject.js\n// module id = 768\n// module chunks = 1","\"use strict\";\nvar ReplaySubject_1 = require('../ReplaySubject');\nvar multicast_1 = require('./multicast');\n/* tslint:enable:max-line-length */\nfunction publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n        scheduler = selectorOrScheduler;\n    }\n    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };\n}\nexports.publishReplay = publishReplay;\n//# sourceMappingURL=publishReplay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/publishReplay.js\n// module id = 769\n// module chunks = 1","\"use strict\";\nvar QueueAction_1 = require('./QueueAction');\nvar QueueScheduler_1 = require('./QueueScheduler');\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nexports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n//# sourceMappingURL=queue.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/queue.js\n// module id = 770\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncAction_1 = require('./AsyncAction');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction_1.AsyncAction));\nexports.QueueAction = QueueAction;\n//# sourceMappingURL=QueueAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/QueueAction.js\n// module id = 771\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar AsyncScheduler_1 = require('./AsyncScheduler');\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        _super.apply(this, arguments);\n    }\n    return QueueScheduler;\n}(AsyncScheduler_1.AsyncScheduler));\nexports.QueueScheduler = QueueScheduler;\n//# sourceMappingURL=QueueScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/scheduler/QueueScheduler.js\n// module id = 772\n// module chunks = 1","\"use strict\";\nvar isArray_1 = require('../util/isArray');\nvar race_1 = require('../observable/race');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return function raceOperatorFunction(source) {\n        // if the only argument is an array, it was most likely called with\n        // `pair([obs1, obs2, ...])`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n    };\n}\nexports.race = race;\n//# sourceMappingURL=race.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/race.js\n// module id = 773\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isArray_1 = require('../util/isArray');\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\nfunction race() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    // if the only argument is an array, it was most likely called with\n    // `race([obs1, obs2, ...])`\n    if (observables.length === 1) {\n        if (isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        else {\n            return observables[0];\n        }\n    }\n    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n}\nexports.race = race;\nvar RaceOperator = (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\nexports.RaceOperator = RaceOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RaceSubscriber = (function (_super) {\n    __extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        _super.call(this, destination);\n        this.hasFirst = false;\n        this.observables = [];\n        this.subscriptions = [];\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.RaceSubscriber = RaceSubscriber;\n//# sourceMappingURL=race.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/observable/race.js\n// module id = 774\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n/**\n * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n *\n * <img src=\"./img/repeat.png\" width=\"100%\">\n *\n * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n * an empty Observable.\n * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n * count times.\n * @method repeat\n * @owner Observable\n */\nfunction repeat(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) {\n        if (count === 0) {\n            return new EmptyObservable_1.EmptyObservable();\n        }\n        else if (count < 0) {\n            return source.lift(new RepeatOperator(-1, source));\n        }\n        else {\n            return source.lift(new RepeatOperator(count - 1, source));\n        }\n    };\n}\nexports.repeat = repeat;\nvar RepeatOperator = (function () {\n    function RepeatOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RepeatOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n    };\n    return RepeatOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatSubscriber = (function (_super) {\n    __extends(RepeatSubscriber, _super);\n    function RepeatSubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RepeatSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.complete.call(this);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RepeatSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=repeat.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/repeat.js\n// module id = 775\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nfunction repeatWhen(notifier) {\n    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };\n}\nexports.repeatWhen = repeatWhen;\nvar RepeatWhenOperator = (function () {\n    function RepeatWhenOperator(notifier) {\n        this.notifier = notifier;\n    }\n    RepeatWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    };\n    return RepeatWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RepeatWhenSubscriber = (function (_super) {\n    __extends(RepeatWhenSubscriber, _super);\n    function RepeatWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n        this.sourceIsBeingSubscribedTo = true;\n    }\n    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    };\n    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return _super.prototype.complete.call(this);\n        }\n    };\n    RepeatWhenSubscriber.prototype.complete = function () {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            else if (this.retriesSubscription.closed) {\n                return _super.prototype.complete.call(this);\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next();\n        }\n    };\n    RepeatWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.notifications = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        _super.prototype._unsubscribeAndRecycle.call(this);\n        this.notifications = notifications;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        return this;\n    };\n    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n        this.notifications = new Subject_1.Subject();\n        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n        if (retries === errorObject_1.errorObject) {\n            return _super.prototype.complete.call(this);\n        }\n        this.retries = retries;\n        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n    };\n    return RepeatWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=repeatWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/repeatWhen.js\n// module id = 776\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n * as a number parameter) rather than propagating the `error` call.\n *\n * <img src=\"./img/retry.png\" width=\"100%\">\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n * @param {number} count - Number of retry attempts before failing.\n * @return {Observable} The source Observable modified with the retry logic.\n * @method retry\n * @owner Observable\n */\nfunction retry(count) {\n    if (count === void 0) { count = -1; }\n    return function (source) { return source.lift(new RetryOperator(count, source)); };\n}\nexports.retry = retry;\nvar RetryOperator = (function () {\n    function RetryOperator(count, source) {\n        this.count = count;\n        this.source = source;\n    }\n    RetryOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n    };\n    return RetryOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetrySubscriber = (function (_super) {\n    __extends(RetrySubscriber, _super);\n    function RetrySubscriber(destination, count, source) {\n        _super.call(this, destination);\n        this.count = count;\n        this.source = source;\n    }\n    RetrySubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _a = this, source = _a.source, count = _a.count;\n            if (count === 0) {\n                return _super.prototype.error.call(this, err);\n            }\n            else if (count > -1) {\n                this.count = count - 1;\n            }\n            source.subscribe(this._unsubscribeAndRecycle());\n        }\n    };\n    return RetrySubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=retry.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/retry.js\n// module id = 777\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/retryWhen.png\" width=\"100%\">\n *\n * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return {Observable} The source Observable modified with retry logic.\n * @method retryWhen\n * @owner Observable\n */\nfunction retryWhen(notifier) {\n    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };\n}\nexports.retryWhen = retryWhen;\nvar RetryWhenOperator = (function () {\n    function RetryWhenOperator(notifier, source) {\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n    };\n    return RetryWhenOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RetryWhenSubscriber = (function (_super) {\n    __extends(RetryWhenSubscriber, _super);\n    function RetryWhenSubscriber(destination, notifier, source) {\n        _super.call(this, destination);\n        this.notifier = notifier;\n        this.source = source;\n    }\n    RetryWhenSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var errors = this.errors;\n            var retries = this.retries;\n            var retriesSubscription = this.retriesSubscription;\n            if (!retries) {\n                errors = new Subject_1.Subject();\n                retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                if (retries === errorObject_1.errorObject) {\n                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                }\n                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n            }\n            else {\n                this.errors = null;\n                this.retriesSubscription = null;\n            }\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            errors.next(err);\n        }\n    };\n    RetryWhenSubscriber.prototype._unsubscribe = function () {\n        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n        if (errors) {\n            errors.unsubscribe();\n            this.errors = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    };\n    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n        this.errors = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        this._unsubscribeAndRecycle();\n        this.errors = errors;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        this.source.subscribe(this);\n    };\n    return RetryWhenSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=retryWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/retryWhen.js\n// module id = 778\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nfunction sample(notifier) {\n    return function (source) { return source.lift(new SampleOperator(notifier)); };\n}\nexports.sample = sample;\nvar SampleOperator = (function () {\n    function SampleOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SampleOperator.prototype.call = function (subscriber, source) {\n        var sampleSubscriber = new SampleSubscriber(subscriber);\n        var subscription = source.subscribe(sampleSubscriber);\n        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n        return subscription;\n    };\n    return SampleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleSubscriber = (function (_super) {\n    __extends(SampleSubscriber, _super);\n    function SampleSubscriber() {\n        _super.apply(this, arguments);\n        this.hasValue = false;\n    }\n    SampleSubscriber.prototype._next = function (value) {\n        this.value = value;\n        this.hasValue = true;\n    };\n    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.notifyComplete = function () {\n        this.emitValue();\n    };\n    SampleSubscriber.prototype.emitValue = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    };\n    return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=sample.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/sample.js\n// module id = 779\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * <img src=\"./img/sampleTime.png\" width=\"100%\">\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * @example <caption>Every second, emit the most recent click at most once</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.sampleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param {number} period The sampling period expressed in milliseconds or the\n * time unit determined internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the sampling.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable at the specified time interval.\n * @method sampleTime\n * @owner Observable\n */\nfunction sampleTime(period, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };\n}\nexports.sampleTime = sampleTime;\nvar SampleTimeOperator = (function () {\n    function SampleTimeOperator(period, scheduler) {\n        this.period = period;\n        this.scheduler = scheduler;\n    }\n    SampleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n    };\n    return SampleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SampleTimeSubscriber = (function (_super) {\n    __extends(SampleTimeSubscriber, _super);\n    function SampleTimeSubscriber(destination, period, scheduler) {\n        _super.call(this, destination);\n        this.period = period;\n        this.scheduler = scheduler;\n        this.hasValue = false;\n        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));\n    }\n    SampleTimeSubscriber.prototype._next = function (value) {\n        this.lastValue = value;\n        this.hasValue = true;\n    };\n    SampleTimeSubscriber.prototype.notifyNext = function () {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.lastValue);\n        }\n    };\n    return SampleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNotification(state) {\n    var subscriber = state.subscriber, period = state.period;\n    subscriber.notifyNext();\n    this.schedule(state, period);\n}\n//# sourceMappingURL=sampleTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/sampleTime.js\n// module id = 780\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nfunction sequenceEqual(compareTo, comparor) {\n    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };\n}\nexports.sequenceEqual = sequenceEqual;\nvar SequenceEqualOperator = (function () {\n    function SequenceEqualOperator(compareTo, comparor) {\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n    }\n    SequenceEqualOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    };\n    return SequenceEqualOperator;\n}());\nexports.SequenceEqualOperator = SequenceEqualOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SequenceEqualSubscriber = (function (_super) {\n    __extends(SequenceEqualSubscriber, _super);\n    function SequenceEqualSubscriber(destination, compareTo, comparor) {\n        _super.call(this, destination);\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    SequenceEqualSubscriber.prototype._next = function (value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    };\n    SequenceEqualSubscriber.prototype._complete = function () {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    };\n    SequenceEqualSubscriber.prototype.checkValues = function () {\n        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n        while (_a.length > 0 && _b.length > 0) {\n            var a = _a.shift();\n            var b = _b.shift();\n            var areEqual = false;\n            if (comparor) {\n                areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                if (areEqual === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                areEqual = a === b;\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    };\n    SequenceEqualSubscriber.prototype.emit = function (value) {\n        var destination = this.destination;\n        destination.next(value);\n        destination.complete();\n    };\n    SequenceEqualSubscriber.prototype.nextB = function (value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    };\n    return SequenceEqualSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SequenceEqualSubscriber = SequenceEqualSubscriber;\nvar SequenceEqualCompareToSubscriber = (function (_super) {\n    __extends(SequenceEqualCompareToSubscriber, _super);\n    function SequenceEqualCompareToSubscriber(destination, parent) {\n        _super.call(this, destination);\n        this.parent = parent;\n    }\n    SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n        this.parent.nextB(value);\n    };\n    SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n        this.parent.error(err);\n    };\n    SequenceEqualCompareToSubscriber.prototype._complete = function () {\n        this.parent._complete();\n    };\n    return SequenceEqualCompareToSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=sequenceEqual.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/sequenceEqual.js\n// module id = 781\n// module chunks = 1","\"use strict\";\nvar ReplaySubject_1 = require('../ReplaySubject');\n/**\n * @method shareReplay\n * @owner Observable\n */\nfunction shareReplay(bufferSize, windowTime, scheduler) {\n    return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };\n}\nexports.shareReplay = shareReplay;\nfunction shareReplayOperator(bufferSize, windowTime, scheduler) {\n    var subject;\n    var refCount = 0;\n    var subscription;\n    var hasError = false;\n    var isComplete = false;\n    return function shareReplayOperation(source) {\n        refCount++;\n        if (!subject || hasError) {\n            hasError = false;\n            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n            subscription = source.subscribe({\n                next: function (value) { subject.next(value); },\n                error: function (err) {\n                    hasError = true;\n                    subject.error(err);\n                },\n                complete: function () {\n                    isComplete = true;\n                    subject.complete();\n                },\n            });\n        }\n        var innerSub = subject.subscribe(this);\n        return function () {\n            refCount--;\n            innerSub.unsubscribe();\n            if (subscription && refCount === 0 && isComplete) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n}\n;\n//# sourceMappingURL=shareReplay.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/shareReplay.js\n// module id = 782\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n *\n * <img src=\"./img/single.png\" width=\"100%\">\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n * the predicate.\n .\n * @method single\n * @owner Observable\n */\nfunction single(predicate) {\n    return function (source) { return source.lift(new SingleOperator(predicate, source)); };\n}\nexports.single = single;\nvar SingleOperator = (function () {\n    function SingleOperator(predicate, source) {\n        this.predicate = predicate;\n        this.source = source;\n    }\n    SingleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n    };\n    return SingleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SingleSubscriber = (function (_super) {\n    __extends(SingleSubscriber, _super);\n    function SingleSubscriber(destination, predicate, source) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.source = source;\n        this.seenValue = false;\n        this.index = 0;\n    }\n    SingleSubscriber.prototype.applySingleValue = function (value) {\n        if (this.seenValue) {\n            this.destination.error('Sequence contains more than one element');\n        }\n        else {\n            this.seenValue = true;\n            this.singleValue = value;\n        }\n    };\n    SingleSubscriber.prototype._next = function (value) {\n        var index = this.index++;\n        if (this.predicate) {\n            this.tryNext(value, index);\n        }\n        else {\n            this.applySingleValue(value);\n        }\n    };\n    SingleSubscriber.prototype.tryNext = function (value, index) {\n        try {\n            if (this.predicate(value, index, this.source)) {\n                this.applySingleValue(value);\n            }\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    SingleSubscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (this.index > 0) {\n            destination.next(this.seenValue ? this.singleValue : undefined);\n            destination.complete();\n        }\n        else {\n            destination.error(new EmptyError_1.EmptyError);\n        }\n    };\n    return SingleSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=single.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/single.js\n// module id = 783\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * <img src=\"./img/skip.png\" width=\"100%\">\n *\n * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n * @return {Observable} An Observable that skips values emitted by the source Observable.\n *\n * @method skip\n * @owner Observable\n */\nfunction skip(count) {\n    return function (source) { return source.lift(new SkipOperator(count)); };\n}\nexports.skip = skip;\nvar SkipOperator = (function () {\n    function SkipOperator(total) {\n        this.total = total;\n    }\n    SkipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipSubscriber(subscriber, this.total));\n    };\n    return SkipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipSubscriber = (function (_super) {\n    __extends(SkipSubscriber, _super);\n    function SkipSubscriber(destination, total) {\n        _super.call(this, destination);\n        this.total = total;\n        this.count = 0;\n    }\n    SkipSubscriber.prototype._next = function (x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    };\n    return SkipSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skip.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/skip.js\n// module id = 784\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nfunction skipLast(count) {\n    return function (source) { return source.lift(new SkipLastOperator(count)); };\n}\nexports.skipLast = skipLast;\nvar SkipLastOperator = (function () {\n    function SkipLastOperator(_skipCount) {\n        this._skipCount = _skipCount;\n        if (this._skipCount < 0) {\n            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n        }\n    }\n    SkipLastOperator.prototype.call = function (subscriber, source) {\n        if (this._skipCount === 0) {\n            // If we don't want to skip any values then just subscribe\n            // to Subscriber without any further logic.\n            return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n        }\n        else {\n            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n        }\n    };\n    return SkipLastOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipLastSubscriber = (function (_super) {\n    __extends(SkipLastSubscriber, _super);\n    function SkipLastSubscriber(destination, _skipCount) {\n        _super.call(this, destination);\n        this._skipCount = _skipCount;\n        this._count = 0;\n        this._ring = new Array(_skipCount);\n    }\n    SkipLastSubscriber.prototype._next = function (value) {\n        var skipCount = this._skipCount;\n        var count = this._count++;\n        if (count < skipCount) {\n            this._ring[count] = value;\n        }\n        else {\n            var currentIndex = count % skipCount;\n            var ring = this._ring;\n            var oldValue = ring[currentIndex];\n            ring[currentIndex] = value;\n            this.destination.next(oldValue);\n        }\n    };\n    return SkipLastSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipLast.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/skipLast.js\n// module id = 785\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nfunction skipUntil(notifier) {\n    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };\n}\nexports.skipUntil = skipUntil;\nvar SkipUntilOperator = (function () {\n    function SkipUntilOperator(notifier) {\n        this.notifier = notifier;\n    }\n    SkipUntilOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n    };\n    return SkipUntilOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipUntilSubscriber = (function (_super) {\n    __extends(SkipUntilSubscriber, _super);\n    function SkipUntilSubscriber(destination, notifier) {\n        _super.call(this, destination);\n        this.hasValue = false;\n        this.isInnerStopped = false;\n        this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n    }\n    SkipUntilSubscriber.prototype._next = function (value) {\n        if (this.hasValue) {\n            _super.prototype._next.call(this, value);\n        }\n    };\n    SkipUntilSubscriber.prototype._complete = function () {\n        if (this.isInnerStopped) {\n            _super.prototype._complete.call(this);\n        }\n        else {\n            this.unsubscribe();\n        }\n    };\n    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.hasValue = true;\n    };\n    SkipUntilSubscriber.prototype.notifyComplete = function () {\n        this.isInnerStopped = true;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=skipUntil.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/skipUntil.js\n// module id = 786\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * <img src=\"./img/skipWhile.png\" width=\"100%\">\n *\n * @param {Function} predicate - A function to test each item emitted from the source Observable.\n * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n * specified predicate becomes false.\n * @method skipWhile\n * @owner Observable\n */\nfunction skipWhile(predicate) {\n    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };\n}\nexports.skipWhile = skipWhile;\nvar SkipWhileOperator = (function () {\n    function SkipWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    SkipWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n    };\n    return SkipWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SkipWhileSubscriber = (function (_super) {\n    __extends(SkipWhileSubscriber, _super);\n    function SkipWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.skipping = true;\n        this.index = 0;\n    }\n    SkipWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (this.skipping) {\n            this.tryCallPredicate(value);\n        }\n        if (!this.skipping) {\n            destination.next(value);\n        }\n    };\n    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n        try {\n            var result = this.predicate(value, this.index++);\n            this.skipping = Boolean(result);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n    };\n    return SkipWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=skipWhile.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/skipWhile.js\n// module id = 787\n// module chunks = 1","\"use strict\";\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar ScalarObservable_1 = require('../observable/ScalarObservable');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\nvar concat_1 = require('../observable/concat');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len === 1) {\n            return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n        }\n        else if (len > 1) {\n            return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n        }\n        else {\n            return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n        }\n    };\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/startWith.js\n// module id = 788\n// module chunks = 1","\"use strict\";\nvar switchMap_1 = require('./switchMap');\nvar identity_1 = require('../util/identity');\nfunction switchAll() {\n    return switchMap_1.switchMap(identity_1.identity);\n}\nexports.switchAll = switchAll;\n//# sourceMappingURL=switchAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/switchAll.js\n// module id = 789\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nfunction switchMapTo(innerObservable, resultSelector) {\n    return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };\n}\nexports.switchMapTo = switchMapTo;\nvar SwitchMapToOperator = (function () {\n    function SwitchMapToOperator(observable, resultSelector) {\n        this.observable = observable;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapToOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n    };\n    return SwitchMapToOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapToSubscriber = (function (_super) {\n    __extends(SwitchMapToSubscriber, _super);\n    function SwitchMapToSubscriber(destination, inner, resultSelector) {\n        _super.call(this, destination);\n        this.inner = inner;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapToSubscriber.prototype._next = function (value) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n    };\n    SwitchMapToSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        if (resultSelector) {\n            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            destination.next(innerValue);\n        }\n    };\n    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n        var result;\n        try {\n            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        destination.next(result);\n    };\n    return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMapTo.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/switchMapTo.js\n// module id = 790\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * <img src=\"./img/takeWhile.png\" width=\"100%\">\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.takeWhile(ev => ev.clientX > 200);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates a value emitted by the source Observable and returns a boolean.\n * Also takes the (zero-based) index as the second argument.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable so long as each value satisfies the condition defined by the\n * `predicate`, then completes.\n * @method takeWhile\n * @owner Observable\n */\nfunction takeWhile(predicate) {\n    return function (source) { return source.lift(new TakeWhileOperator(predicate)); };\n}\nexports.takeWhile = takeWhile;\nvar TakeWhileOperator = (function () {\n    function TakeWhileOperator(predicate) {\n        this.predicate = predicate;\n    }\n    TakeWhileOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n    };\n    return TakeWhileOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TakeWhileSubscriber = (function (_super) {\n    __extends(TakeWhileSubscriber, _super);\n    function TakeWhileSubscriber(destination, predicate) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.index = 0;\n    }\n    TakeWhileSubscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        var result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    };\n    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n        var destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            destination.complete();\n        }\n    };\n    return TakeWhileSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=takeWhile.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/takeWhile.js\n// module id = 791\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\nvar throttle_1 = require('./throttle');\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nfunction throttleTime(duration, scheduler, config) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n}\nexports.throttleTime = throttleTime;\nvar ThrottleTimeOperator = (function () {\n    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n    }\n    ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n    };\n    return ThrottleTimeOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ThrottleTimeSubscriber = (function (_super) {\n    __extends(ThrottleTimeSubscriber, _super);\n    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n        _super.call(this, destination);\n        this.duration = duration;\n        this.scheduler = scheduler;\n        this.leading = leading;\n        this.trailing = trailing;\n        this._hasTrailingValue = false;\n        this._trailingValue = null;\n    }\n    ThrottleTimeSubscriber.prototype._next = function (value) {\n        if (this.throttled) {\n            if (this.trailing) {\n                this._trailingValue = value;\n                this._hasTrailingValue = true;\n            }\n        }\n        else {\n            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n            if (this.leading) {\n                this.destination.next(value);\n            }\n        }\n    };\n    ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n        var throttled = this.throttled;\n        if (throttled) {\n            if (this.trailing && this._hasTrailingValue) {\n                this.destination.next(this._trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n            throttled.unsubscribe();\n            this.remove(throttled);\n            this.throttled = null;\n        }\n    };\n    return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchNext(arg) {\n    var subscriber = arg.subscriber;\n    subscriber.clearThrottle();\n}\n//# sourceMappingURL=throttleTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/throttleTime.js\n// module id = 792\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar async_1 = require('../scheduler/async');\nfunction timeInterval(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };\n}\nexports.timeInterval = timeInterval;\nvar TimeInterval = (function () {\n    function TimeInterval(value, interval) {\n        this.value = value;\n        this.interval = interval;\n    }\n    return TimeInterval;\n}());\nexports.TimeInterval = TimeInterval;\n;\nvar TimeIntervalOperator = (function () {\n    function TimeIntervalOperator(scheduler) {\n        this.scheduler = scheduler;\n    }\n    TimeIntervalOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n    };\n    return TimeIntervalOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeIntervalSubscriber = (function (_super) {\n    __extends(TimeIntervalSubscriber, _super);\n    function TimeIntervalSubscriber(destination, scheduler) {\n        _super.call(this, destination);\n        this.scheduler = scheduler;\n        this.lastTime = 0;\n        this.lastTime = scheduler.now();\n    }\n    TimeIntervalSubscriber.prototype._next = function (value) {\n        var now = this.scheduler.now();\n        var span = now - this.lastTime;\n        this.lastTime = now;\n        this.destination.next(new TimeInterval(value, span));\n    };\n    return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeInterval.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/timeInterval.js\n// module id = 793\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar Subscriber_1 = require('../Subscriber');\nvar TimeoutError_1 = require('../util/TimeoutError');\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * <img src=\"./img/timeout.png\" width=\"100%\">\n *\n * `timeout` operator accepts as an argument either a number or a Date.\n *\n * If number was provided, it returns an Observable that behaves like a source\n * Observable, unless there is a period of time where there is no value emitted.\n * So if you provide `100` as argument and first value comes after 50ms from\n * the moment of subscription, this value will be simply re-emitted by the resulting\n * Observable. If however after that 100ms passes without a second value being emitted,\n * stream will end with an error and source Observable will be unsubscribed.\n * These checks are performed throughout whole lifecycle of Observable - from the moment\n * it was subscribed to, until it completes or errors itself. Thus every value must be\n * emitted within specified period since previous value.\n *\n * If provided argument was Date, returned Observable behaves differently. It throws\n * if Observable did not complete before provided Date. This means that periods between\n * emission of particular values do not matter in this case. If Observable did not complete\n * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n * stream behaves just as source Observable.\n *\n * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n * when returned Observable will check if source stream emitted value or completed.\n *\n * @example <caption>Check if ticks are emitted within certain timespan</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n *                       // since `interval` might fire a bit later then scheduled.\n * .subscribe(\n *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n *     err => console.log(err) // Will never be called.\n * );\n *\n * seconds.timeout(900).subscribe(\n *     value => console.log(value), // Will never be called.\n *     err => console.log(err) // Will emit error before even first value is emitted,\n *                             // since it did not arrive within 900ms period.\n * );\n *\n * @example <caption>Use Date to check if Observable completed</caption>\n * const seconds = Rx.Observable.interval(1000);\n *\n * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n * .subscribe(\n *     value => console.log(value), // Will emit values as regular `interval` would\n *                                  // until December 17, 2020 at 03:24:00.\n *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n *                             // since Observable did not complete by then.\n * );\n *\n * @see {@link timeoutWith}\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n * @method timeout\n * @owner Observable\n */\nfunction timeout(due, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    var absoluteTimeout = isDate_1.isDate(due);\n    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n    return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n}\nexports.timeout = timeout;\nvar TimeoutOperator = (function () {\n    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n    }\n    TimeoutOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n    };\n    return TimeoutOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutSubscriber = (function (_super) {\n    __extends(TimeoutSubscriber, _super);\n    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.scheduler = scheduler;\n        this.errorInstance = errorInstance;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n        subscriber.error(subscriber.errorInstance);\n    };\n    TimeoutSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.errorInstance = null;\n    };\n    return TimeoutSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=timeout.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/timeout.js\n// module id = 794\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var err = _super.call(this, 'Timeout has occurred');\n        this.name = err.name = 'TimeoutError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return TimeoutError;\n}(Error));\nexports.TimeoutError = TimeoutError;\n//# sourceMappingURL=TimeoutError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/util/TimeoutError.js\n// module id = 795\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar async_1 = require('../scheduler/async');\nvar isDate_1 = require('../util/isDate');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nfunction timeoutWith(due, withObservable, scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return function (source) {\n        var absoluteTimeout = isDate_1.isDate(due);\n        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n    };\n}\nexports.timeoutWith = timeoutWith;\nvar TimeoutWithOperator = (function () {\n    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    TimeoutWithOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    };\n    return TimeoutWithOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar TimeoutWithSubscriber = (function (_super) {\n    __extends(TimeoutWithSubscriber, _super);\n    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        _super.call(this, destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n        var withObservable = subscriber.withObservable;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n    };\n    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n        var action = this.action;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    };\n    TimeoutWithSubscriber.prototype._next = function (value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        _super.prototype._next.call(this, value);\n    };\n    TimeoutWithSubscriber.prototype._unsubscribe = function () {\n        this.action = null;\n        this.scheduler = null;\n        this.withObservable = null;\n    };\n    return TimeoutWithSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=timeoutWith.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/timeoutWith.js\n// module id = 796\n// module chunks = 1","\"use strict\";\nvar async_1 = require('../scheduler/async');\nvar map_1 = require('./map');\n/**\n * @param scheduler\n * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n * @method timestamp\n * @owner Observable\n */\nfunction timestamp(scheduler) {\n    if (scheduler === void 0) { scheduler = async_1.async; }\n    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });\n    // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n}\nexports.timestamp = timestamp;\nvar Timestamp = (function () {\n    function Timestamp(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    return Timestamp;\n}());\nexports.Timestamp = Timestamp;\n;\n//# sourceMappingURL=timestamp.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/timestamp.js\n// module id = 797\n// module chunks = 1","\"use strict\";\nvar reduce_1 = require('./reduce');\nfunction toArrayReducer(arr, item, index) {\n    arr.push(item);\n    return arr;\n}\nfunction toArray() {\n    return reduce_1.reduce(toArrayReducer, []);\n}\nexports.toArray = toArray;\n//# sourceMappingURL=toArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/toArray.js\n// module id = 798\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * <img src=\"./img/window.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * Observable `windowBoundaries` emits an item. Because each window is an\n * Observable, the output is a higher-order Observable.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var interval = Rx.Observable.interval(1000);\n * var result = clicks.window(interval)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param {Observable<any>} windowBoundaries An Observable that completes the\n * previous window and starts a new window.\n * @return {Observable<Observable<T>>} An Observable of windows, which are\n * Observables emitting values of the source Observable.\n * @method window\n * @owner Observable\n */\nfunction window(windowBoundaries) {\n    return function windowOperatorFunction(source) {\n        return source.lift(new WindowOperator(windowBoundaries));\n    };\n}\nexports.window = window;\nvar WindowOperator = (function () {\n    function WindowOperator(windowBoundaries) {\n        this.windowBoundaries = windowBoundaries;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        var windowSubscriber = new WindowSubscriber(subscriber);\n        var sourceSubscription = source.subscribe(windowSubscriber);\n        if (!sourceSubscription.closed) {\n            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n        }\n        return sourceSubscription;\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination) {\n        _super.call(this, destination);\n        this.window = new Subject_1.Subject();\n        destination.next(this.window);\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow();\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this._complete();\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n    };\n    WindowSubscriber.prototype._unsubscribe = function () {\n        this.window = null;\n    };\n    WindowSubscriber.prototype.openWindow = function () {\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var destination = this.destination;\n        var newWindow = this.window = new Subject_1.Subject();\n        destination.next(newWindow);\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=window.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/window.js\n// module id = 799\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\nvar Subject_1 = require('../Subject');\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nfunction windowCount(windowSize, startWindowEvery) {\n    if (startWindowEvery === void 0) { startWindowEvery = 0; }\n    return function windowCountOperatorFunction(source) {\n        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n    };\n}\nexports.windowCount = windowCount;\nvar WindowCountOperator = (function () {\n    function WindowCountOperator(windowSize, startWindowEvery) {\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n    }\n    WindowCountOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n    };\n    return WindowCountOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowCountSubscriber = (function (_super) {\n    __extends(WindowCountSubscriber, _super);\n    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowSize = windowSize;\n        this.startWindowEvery = startWindowEvery;\n        this.windows = [new Subject_1.Subject()];\n        this.count = 0;\n        destination.next(this.windows[0]);\n    }\n    WindowCountSubscriber.prototype._next = function (value) {\n        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n        var destination = this.destination;\n        var windowSize = this.windowSize;\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len && !this.closed; i++) {\n            windows[i].next(value);\n        }\n        var c = this.count - windowSize + 1;\n        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n            windows.shift().complete();\n        }\n        if (++this.count % startWindowEvery === 0 && !this.closed) {\n            var window_1 = new Subject_1.Subject();\n            windows.push(window_1);\n            destination.next(window_1);\n        }\n    };\n    WindowCountSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().error(err);\n            }\n        }\n        this.destination.error(err);\n    };\n    WindowCountSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        if (windows) {\n            while (windows.length > 0 && !this.closed) {\n                windows.shift().complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowCountSubscriber.prototype._unsubscribe = function () {\n        this.count = 0;\n        this.windows = null;\n    };\n    return WindowCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=windowCount.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/windowCount.js\n// module id = 800\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar async_1 = require('../scheduler/async');\nvar Subscriber_1 = require('../Subscriber');\nvar isNumeric_1 = require('../util/isNumeric');\nvar isScheduler_1 = require('../util/isScheduler');\nfunction windowTime(windowTimeSpan) {\n    var scheduler = async_1.async;\n    var windowCreationInterval = null;\n    var maxWindowSize = Number.POSITIVE_INFINITY;\n    if (isScheduler_1.isScheduler(arguments[3])) {\n        scheduler = arguments[3];\n    }\n    if (isScheduler_1.isScheduler(arguments[2])) {\n        scheduler = arguments[2];\n    }\n    else if (isNumeric_1.isNumeric(arguments[2])) {\n        maxWindowSize = arguments[2];\n    }\n    if (isScheduler_1.isScheduler(arguments[1])) {\n        scheduler = arguments[1];\n    }\n    else if (isNumeric_1.isNumeric(arguments[1])) {\n        windowCreationInterval = arguments[1];\n    }\n    return function windowTimeOperatorFunction(source) {\n        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n    };\n}\nexports.windowTime = windowTime;\nvar WindowTimeOperator = (function () {\n    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n    }\n    WindowTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n    };\n    return WindowTimeOperator;\n}());\nvar CountedSubject = (function (_super) {\n    __extends(CountedSubject, _super);\n    function CountedSubject() {\n        _super.apply(this, arguments);\n        this._numberOfNextedValues = 0;\n    }\n    CountedSubject.prototype.next = function (value) {\n        this._numberOfNextedValues++;\n        _super.prototype.next.call(this, value);\n    };\n    Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n        get: function () {\n            return this._numberOfNextedValues;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return CountedSubject;\n}(Subject_1.Subject));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowTimeSubscriber = (function (_super) {\n    __extends(WindowTimeSubscriber, _super);\n    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.windowTimeSpan = windowTimeSpan;\n        this.windowCreationInterval = windowCreationInterval;\n        this.maxWindowSize = maxWindowSize;\n        this.scheduler = scheduler;\n        this.windows = [];\n        var window = this.openWindow();\n        if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n            var closeState = { subscriber: this, window: window, context: null };\n            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };\n            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n        }\n        else {\n            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };\n            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n        }\n    }\n    WindowTimeSubscriber.prototype._next = function (value) {\n        var windows = this.windows;\n        var len = windows.length;\n        for (var i = 0; i < len; i++) {\n            var window_1 = windows[i];\n            if (!window_1.closed) {\n                window_1.next(value);\n                if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                    this.closeWindow(window_1);\n                }\n            }\n        }\n    };\n    WindowTimeSubscriber.prototype._error = function (err) {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            windows.shift().error(err);\n        }\n        this.destination.error(err);\n    };\n    WindowTimeSubscriber.prototype._complete = function () {\n        var windows = this.windows;\n        while (windows.length > 0) {\n            var window_2 = windows.shift();\n            if (!window_2.closed) {\n                window_2.complete();\n            }\n        }\n        this.destination.complete();\n    };\n    WindowTimeSubscriber.prototype.openWindow = function () {\n        var window = new CountedSubject();\n        this.windows.push(window);\n        var destination = this.destination;\n        destination.next(window);\n        return window;\n    };\n    WindowTimeSubscriber.prototype.closeWindow = function (window) {\n        window.complete();\n        var windows = this.windows;\n        windows.splice(windows.indexOf(window), 1);\n    };\n    return WindowTimeSubscriber;\n}(Subscriber_1.Subscriber));\nfunction dispatchWindowTimeSpanOnly(state) {\n    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n    if (window) {\n        subscriber.closeWindow(window);\n    }\n    state.window = subscriber.openWindow();\n    this.schedule(state, windowTimeSpan);\n}\nfunction dispatchWindowCreation(state) {\n    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n    var window = subscriber.openWindow();\n    var action = this;\n    var context = { action: action, subscription: null };\n    var timeSpanState = { subscriber: subscriber, window: window, context: context };\n    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n    action.add(context.subscription);\n    action.schedule(state, windowCreationInterval);\n}\nfunction dispatchWindowClose(state) {\n    var subscriber = state.subscriber, window = state.window, context = state.context;\n    if (context && context.action && context.subscription) {\n        context.action.remove(context.subscription);\n    }\n    subscriber.closeWindow(window);\n}\n//# sourceMappingURL=windowTime.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/windowTime.js\n// module id = 801\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Subscription_1 = require('../Subscription');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nfunction windowToggle(openings, closingSelector) {\n    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };\n}\nexports.windowToggle = windowToggle;\nvar WindowToggleOperator = (function () {\n    function WindowToggleOperator(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    WindowToggleOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    };\n    return WindowToggleOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowToggleSubscriber = (function (_super) {\n    __extends(WindowToggleSubscriber, _super);\n    function WindowToggleSubscriber(destination, openings, closingSelector) {\n        _super.call(this, destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n    }\n    WindowToggleSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        if (contexts) {\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].window.next(value);\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype._error = function (err) {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.error(err);\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._error.call(this, err);\n    };\n    WindowToggleSubscriber.prototype._complete = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.complete();\n                context.subscription.unsubscribe();\n            }\n        }\n        _super.prototype._complete.call(this);\n    };\n    WindowToggleSubscriber.prototype._unsubscribe = function () {\n        var contexts = this.contexts;\n        this.contexts = null;\n        if (contexts) {\n            var len = contexts.length;\n            var index = -1;\n            while (++index < len) {\n                var context = contexts[index];\n                context.window.unsubscribe();\n                context.subscription.unsubscribe();\n            }\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (outerValue === this.openings) {\n            var closingSelector = this.closingSelector;\n            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n            if (closingNotifier === errorObject_1.errorObject) {\n                return this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                var window_1 = new Subject_1.Subject();\n                var subscription = new Subscription_1.Subscription();\n                var context = { window: window_1, subscription: subscription };\n                this.contexts.push(context);\n                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                if (innerSubscription.closed) {\n                    this.closeWindow(this.contexts.length - 1);\n                }\n                else {\n                    innerSubscription.context = context;\n                    subscription.add(innerSubscription);\n                }\n                this.destination.next(window_1);\n            }\n        }\n        else {\n            this.closeWindow(this.contexts.indexOf(outerValue));\n        }\n    };\n    WindowToggleSubscriber.prototype.notifyError = function (err) {\n        this.error(err);\n    };\n    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n        if (inner !== this.openSubscription) {\n            this.closeWindow(this.contexts.indexOf(inner.context));\n        }\n    };\n    WindowToggleSubscriber.prototype.closeWindow = function (index) {\n        if (index === -1) {\n            return;\n        }\n        var contexts = this.contexts;\n        var context = contexts[index];\n        var window = context.window, subscription = context.subscription;\n        contexts.splice(index, 1);\n        window.complete();\n        subscription.unsubscribe();\n    };\n    return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowToggle.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/windowToggle.js\n// module id = 802\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowWhen.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks\n *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals (on either `next` or\n * `complete`) when to close the previous window and start a new one.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowWhen\n * @owner Observable\n */\nfunction windowWhen(closingSelector) {\n    return function windowWhenOperatorFunction(source) {\n        return source.lift(new WindowOperator(closingSelector));\n    };\n}\nexports.windowWhen = windowWhen;\nvar WindowOperator = (function () {\n    function WindowOperator(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    WindowOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n    };\n    return WindowOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WindowSubscriber = (function (_super) {\n    __extends(WindowSubscriber, _super);\n    function WindowSubscriber(destination, closingSelector) {\n        _super.call(this, destination);\n        this.destination = destination;\n        this.closingSelector = closingSelector;\n        this.openWindow();\n    }\n    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n        this._error(error);\n    };\n    WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.openWindow(innerSub);\n    };\n    WindowSubscriber.prototype._next = function (value) {\n        this.window.next(value);\n    };\n    WindowSubscriber.prototype._error = function (err) {\n        this.window.error(err);\n        this.destination.error(err);\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype._complete = function () {\n        this.window.complete();\n        this.destination.complete();\n        this.unsubscribeClosingNotification();\n    };\n    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n        if (this.closingNotification) {\n            this.closingNotification.unsubscribe();\n        }\n    };\n    WindowSubscriber.prototype.openWindow = function (innerSub) {\n        if (innerSub === void 0) { innerSub = null; }\n        if (innerSub) {\n            this.remove(innerSub);\n            innerSub.unsubscribe();\n        }\n        var prevWindow = this.window;\n        if (prevWindow) {\n            prevWindow.complete();\n        }\n        var window = this.window = new Subject_1.Subject();\n        this.destination.next(window);\n        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject_1.errorObject) {\n            var err = errorObject_1.errorObject.e;\n            this.destination.error(err);\n            this.window.error(err);\n        }\n        else {\n            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n        }\n    };\n    return WindowSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=windowWhen.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/windowWhen.js\n// module id = 803\n// module chunks = 1","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    return function (source) {\n        var project;\n        if (typeof args[args.length - 1] === 'function') {\n            project = args.pop();\n        }\n        var observables = args;\n        return source.lift(new WithLatestFromOperator(observables, project));\n    };\n}\nexports.withLatestFrom = withLatestFrom;\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/withLatestFrom.js\n// module id = 804\n// module chunks = 1","\"use strict\";\nvar zip_1 = require('./zip');\nfunction zipAll(project) {\n    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };\n}\nexports.zipAll = zipAll;\n//# sourceMappingURL=zipAll.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/rxjs/operators/zipAll.js\n// module id = 805\n// module chunks = 1"],"sourceRoot":""}